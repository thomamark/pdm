/* Copyright 2011 Mark Thomas (mr.thomas gmail)
*/

/*************************************/
/* Global variables                  */
/*************************************/

/* Graphics */
var SPRITE_SCALE = 2;
var BASE_W = 32;
var BASE_H= 16;
var GRID_W = 32*SPRITE_SCALE;
var GRID_H = 16*SPRITE_SCALE;
var WALL_PAD=10*SPRITE_SCALE;
var MAX_COLS = Math.floor(900/GRID_W);
var MAX_ROWS = Math.floor(500/GRID_H);
var BORDER_IMG; 
var SNAKE_IMG; 
var GOAL_IMG; 
var STAR_IMG; 
var PANDA_IMG;
var PORTAL_IMG;
var HEAD_UP_IMG;
var HEAD_DOWN_IMG;
var HEAD_LEFT_IMG;
var HEAD_RIGHT_IMG;
var TAIL_UP_IMG;
var TAIL_DOWN_IMG;
var TAIL_LEFT_IMG;
var TAIL_RIGHT_IMG;
var DOWN_TO_LEFT_IMG;
var DOWN_TO_RIGHT_IMG;
var DOWN_TO_UP_IMG;
var LEFT_TO_DOWN_IMG;
var LEFT_TO_RIGHT_IMG;
var LEFT_TO_UP_IMG;
var RIGHT_TO_DOWN_IMG;
var RIGHT_TO_LEFT_IMG;
var RIGHT_TO_UP_IMG; 
var TILES_IMG_ARRAY;
var WALL_BLOCK_IMG;
var PILLAR_IMG;
var VERTICAL_WALL_IMG;
var HORIZONTAL_WALL_IMG;
var DELETE_IMG;
var WALL_9S_TL_IMG;
var WALL_9S_TC_IMG;
var WALL_9S_TR_IMG;
var WALL_9S_ML_IMG;
var WALL_9S_MC_IMG;
var WALL_9S_MCTR_IMG;
var WALL_9S_MCTL_IMG;
var WALL_9S_MCBR_IMG;
var WALL_9S_MCBL_IMG;
var WALL_9S_MR_IMG;
var WALL_9S_BL_IMG;
var WALL_9S_BC_IMG;
var WALL_9S_BR_IMG;

var POST_ASSET_load_FN; //hacky way to get images to load in lb

var IMGDIR ="assets"
var AUDIODIR ="assets"
var LOAD_ASSETS = true;
var INIT_GAME = true;


/* Maze encoding variables */
var ENC_W = 2; //num of hex digits per square in a string
var WI = 0;
var SIZEI = 1;

/* Isometric rendering */
var COS=Math.cos(0.46365);
var SIN=Math.sin(0.46365);
//var X_ORIGIN=540;
//var Y_ORIGIN=420;
var X_ORIGIN=240;
var Y_ORIGIN=400;
var ISOMETRIC = false;

/* I/O */
var LEFT_ARROW=37;
var UP_ARROW=38;
var RIGHT_ARROW=39;
var DOWN_ARROW=40;
var MOVE_DELAY=10;

/* Game */
var LEVELS = [];
var LEVELS_INITED = false;
var CURRENT_LEVEL; //Will be set during init
var TOTAL_SCORE; //Will be set during init
var LEVEL_SCORE= 0;
var EARNED_POINTS = { "5": 40, "10": 20, "15": 40, "bonus" : 1000};

/* Game elements */
var loadFlags = [];
var gameCanvas; // canvas for moving elements
var gameStage;  
var bgCanvas;  // canvas for static background
var bgStage;
var tileCanvas;  // canvas for static background
var tileStage;  // canvas for static background
var game_state;
var request;
var dragon;
var maze; //the current maze
var dir;
var lastDir;
var nextDir;
var counter;
var TYPES = {
	BLANK : 0,
	WALL : 1,
	PANDA : 2,
	GOAL: 3,
	START: 4
}

var POINTS = {};
POINTS[TYPES.WALL] =  WallPoint;
POINTS[TYPES.PANDA] = PandaPoint;
POINTS[TYPES.GOAL] = GoalPoint;
POINTS[TYPES.START] = StartPoint;

var GAME_STATES = {
  READY : "ready?",
  FAILED: "Maze failed!",
  PLAYING: "playing",
  COMPLETE: "Maze complete!",
  GAME_COMPLETE: "Game complete!"
}
var BLANK = undefined; //Value for ablank space.

/* Audio */
var CHANNEL_MAX = 10;   // number of simultaneous audio channels to allow
var AUDIOCHANNELS = new Array(); // Array of audio elements (initialized below)
var PLAY_FX = true; // whether or not to play sound effects
var PLAY_THEME = true; // whether or not to play sound effects
var AUDIO_SRC= {};  //Caches the playable source strings from the audio elements
var OGG_STR = "audio/ogg";
var THEME;

/*************************************/
/* Game objects                      */
/*************************************/

/*A maze object is a collection of points
 @arg img a an image object to render for this point
 @arg r the row of this object in the maze grid
 @arg c the column of this objection in the maze grid
 @arg isOnFn the function which will be called if the dragon lands on this point
*/
function Point(img,r, c, isOnFn, pointType) {
	this.img=img;
	this.r=r;
	this.c=c;
    //function telling the system what to do if the dragon lands on this point.
    this.isOn = isOnFn;

//	this.yOffset=0-$img.height;
//	this.xOffset=-12;
	this.yOffset=0;
	this.xOffset=0;
    this.obj_type=pointType;
}


// A Wall in the maze
function WallPoint(r,c)  {
	return new Point(WALL_BLOCK_IMG, r, c, mazeCollision, TYPES.WALL);
}

//A goal
function GoalPoint(r,c)  {
	//TODO: add ability to have different results for different goals
	return new Point(PORTAL_IMG, r, c, mazeComplete, TYPES.GOAL);
}

//A Panda
function PandaPoint(r,c) {
  return  new Point(PANDA_IMG, r, c, collectBonus, TYPES.PANDA);
}

//Dragon starting point
function StartPoint(r,c) {
	return new Point(HEAD_DOWN_IMG, r, c, function () {}, TYPES.START);
}

//Special point for background tiles. These are used initially to render
//background images only, so there's no need for an isOn function
function TilePoint(img, r, c) {
   var img = TILES_IMG_ARRAY[Math.floor(Math.random()*TILES_IMG_ARRAY.length)];
   return new Point(img, r, c, null); 
}

//A PointArr defines a rectangular region of points within the maze
//pointType is an optional string describing the type of point this is. 
//
//function PointArr(r1, c1, r2, c2, imgArr, fn, pointType) {
// function PointArr(r1, c1, r2, c2, pointConstructor) {
// 
//         //make sure we always create rects from upper-left to bottom-right
//         sr = Math.min(r1, r2);
//         er = Math.max(r1, r2);
//         sc = Math.min(c1, c2);
//         ec = Math.max(c1, c2);
// 
//         var points = [];
//         //var myimg;
//         for (var myr = sr; myr<=er; myr++){
//                 for (var myc = sc; myc <=ec; myc++) { 
//                         //Pick a random image from the set given to give
//                         //the rectangle a little visual spice
//                         //myimg = imgArr[Math.floor(Math.random()*imgArr.length)]
//                         //points.push(new Point(myimg, myr, myc, fn, pointType));
//                         points.push(new pointConstructor(myr, myc));
//                 }
//         }
//         return points;
// }

// //A Wall is a PointArr where all points are collisions
// function WallArr(sr, sc, er, ec) {
// 	//accept single-point inputs (i.e.just sr, sc).
// 	er = er ? er : sr;
// 	ec = ec ? ec : sc;
//         this.points = new PointArr(sr, sc, er, ec, WallPoint);
// //        for(var i = 0; i<this.points.length; i++) {
// //            this.points[i].obj_type=TYPES.WALL;
// //        }
// }



// //The goal is just a PointArrect whose points call the mazeComplete function
// function GoalArr(sr, sc, er, ec) {
// 	//accept single-point inputs (i.e.just sr, sc).
// 	er = er ? er : sr;
// 	ec = ec ? ec : sc;
//         this.points = new PointArr(sr, sc, er, ec, GoalPoint);
// }

//PandaPoints are points that can be collected. They are placed in hard-to-reach 
//locations to increase the difficulty of the maze.
// function PandaArr(r,c) {
//     this.points = [new Point(PANDA_IMG, r, c, collectBonus)];
// }

/*Defines a square maze
 * c number of columns (width)
 * r number of rows (height)
 * sr the starting row of the dragon
 * sc the starting column of the dragon
 * sx, sy x and y pixel offsets 
 * objs an array of MazeObjects
*/
//function Maze (r, c, sr, sc, sx, sy, objs) {
function Maze (s) {
	if (!s) { throw "Maze must be initialized with a valid string"; }
//    this.cols = c;
//    this.rows = r;
//	this.sr = sr;
//	this.sc = sc;
	//Set for future calculations, but use sx, sy for brevity below
	// this.xOffset = 0;
	// this.yOffset = 0;
// 	this.points = [];
// //    this.objs = objs;
//     this.objs = [];
    this.doneBonuses = 0;
    this.gotBonuses = 0;
	this.s = s;

	this.load(s);

	//this.initPoints();
}

Maze.prototype.reset = function() {
	this.load(s);
}

// Sets the Maze's size in rows (height) and columns (width)
Maze.prototype.setSize = function (r,c) {
	this.rows = r;
	this.cols = c;
}

/* Sets the Dragon's starting point */
Maze.prototype.setStart = function(r,c) {
	this.sr = r;
	this.sc = c;
}

Maze.prototype.unsetStart = function() {
	this.sr = undefined;
	this.sc = undefined;	
}

Maze.prototype.grid2canvas= function (r, c) {
	return [(c-1) * GRID_W,
            (r-1) * GRID_H];
}

Maze.prototype.getCenterX = function () {
	return Math.round(((this.cols)*GRID_W+this.xOffset)/2);
}

Maze.prototype.getCenterY = function () {
	return Math.round(((this.rows)*GRID_H+this.yOffset)/2);
}

Maze.prototype.getStart = function () {
 	return [this.sr, this.sc];
}

Maze.prototype.collectBonus = function(){
    this.gotBonuses +=1;
    LEVEL_SCORE += EARNED_POINTS['bonus'];
}

Maze.prototype.complete = function () {
   this.doneBonuses = this.gotBonuses;
}

Maze.prototype.addBorders = function () {
	for (var i =1; i<=this.rows; i++) {
		if (!this.hasPoint(i,1)) {
			this.addPoint(new WallPoint(i,1));
		}
		if (!this.hasPoint(i,this.cols)) {
			this.addPoint(new WallPoint(i,this.cols));
		}
		for (var j=1; j<=this.cols; j++){
			if (!this.hasPoint(1, j)) {
				this.addPoint(new WallPoint(1,j));				
			}
			if (!this.hasPoint(this.rows,j)){
				this.addPoint(new WallPoint(this.rows,j));
			}
		}
	}
	
	this.fixWallImages();
}

/* Deletes all objects on the borders of the maze */
Maze.prototype.removeBorders = function () {
	for (var i =1; i<=this.rows; i++) {
			this.removePoint(i,1);
			this.removePoint(i,this.cols);
		for (var j=1; j<=this.cols; j++){
				this.removePoint(1,j);				
				this.removePoint(this.rows,j);
		}
	}
}

Maze.prototype.toString = function () {
	/* Maze string representation:
	*  1 hex digit for number of hex digits per square (N)
	*  N hex digits for num rows (R)
	*  N hex digits for num cols (C)
	*  N hex digits for each of the RxC squares in the maze
	*/

	//Fn for extending the length of a hex string to <width> chars
	var pad = function (hexstr, width) {
		var p = width - hexstr.length;
		if (p >0) { return Array(p+1).join("0")+hexstr; }
		else if (p<0) { throw "Too long to encode into a Maze string "+hexstr;}
		else { return hexstr; }
	};
	var s = ""+Number(ENC_W).toString(16) + 
					pad(Number(this.rows).toString(16), ENC_W) +
					pad(Number(this.cols).toString(16),ENC_W);
	try {
		for (var i = 0; i< this.rows; i++) {
			for ( var j = 0; j<this.cols; j++) {
				s+= pad( Number((this.points[i][j]) ? this.points[i][j].obj_type : 0).toString(16), ENC_W);
			}
		}
	} catch (err){
		console.log("Error at row " + (i+1) + " and column " + (j+1) + 
			"\n"+ err.message);
		return null;
	}
	return s;
}

/* Constructs a maze given a string rep of a maze (see toString above) */
Maze.prototype.load = function(s) {
	try {
		var w      = parseInt(s.charAt(WI), 16);
		var rows   = parseInt(s.substring(SIZEI,SIZEI+w), 16);
		var cols   = parseInt(s.substring(SIZEI+w, SIZEI+2*w), 16); 
		var HEADL  = SIZEI+2*w;
		if (s.length != HEADL + rows*cols*w) {
			throw "Invalid maze string length. Expected: "+(HEADL+rows*cols*w) + " Actual: " + s.length;
		}
		this.setSize(rows, cols);
		this.initPoints();
		for (var i = HEADL; i < rows*cols*w; i+=w){
			var p    = Number(s.substring(i, i+w).toString(16));
			if (p != TYPES.BLANK) {
				var c = (((i-HEADL)/w) % cols) +1;	
				var r = Math.floor(((i-HEADL)/w) / this.cols) +1;	
				if (!POINTS[p]) { throw "Unknown point type found: " + p;}
				this.addPoint(new POINTS[p](r, c));
			}
		}
		if (!(this.getStart()[0] && this.getStart()[1])) {
			throw "Maze has no starting point defined!";
		}
	} catch (err) {
		throw "Error loading maze: " + err;
	}
	this.fixWallImages();
}

/* initializes the points array for this Maze */
Maze.prototype.initPoints = function() {
	if (!(this.rows && this.cols)) {
		throw "Rows and columns are undefined. Cannot initialize points.";
	}
	this.points = [];
	this.gotBonuses = 0;
	for (var i=0; i<this.rows; i++){
		this.points[i]=[];
		this.points[i][this.cols-1]=BLANK;
 	}
}


// Maze.prototype.initObs = function() {
// 	this.points = [];
//     this.gotBonuses = 0;
// 	//Create an array with an entry for every point in this maze
// 	for (var i=0; i<this.rows; i++){
// 		this.points[i]=[];
// 		this.points[i][this.cols-1]=BLANK;
//  }
// 
// 	//Add borders
// 	this.addBorders();
// //    this.objs.unshift(new WallArr(1,1,1,this.cols));
// //    this.objs.unshift(new WallArr(this.rows,1,this.rows,this.cols));
// //    this.objs.unshift(new WallArr(2,1,this.rows-1,1));
// //    this.objs.unshift(new WallArr(2,this.cols,this.rows-1,this.cols));
// 
//     for (var i=0; i<this.objs.length; i++) {
//             var o = this.objs[i];
//             for (var p=0; p<o.points.length; p++){
//                     this.addPoint(o.points[p]);
//             }
//     }
// 
//     this.fixWallImages();
// 	
// }

Maze.prototype.fixWallImages = function() {
    for (var i = 0; i<this.rows; i++) {
        for (var j= 0; j<this.cols;j++) {
           //We only care about walls, so skip everything else
//            try {
//           		if (!this.points[i][j] || !this.isType(i,j,TYPES.WALL) ||
//									!this.isType(i,j,TYPES.GOAL)) {
//           		     continue;
//           		 }
//            } catch(err) {
//                console.log("Error fixing wall images! i="+i+" j="+j);
//            }


			if (this.isType(i,j,TYPES.GOAL) && 
						(i == 0 || i == this.rows-1 || j == 0 || j == this.cols-1)) {
						this.points[i][j].img=undefined;
	          this.points[i][j].yOffset=0;
			} else if (this.isType(i,j,TYPES.WALL)) {
					//Build 9-slice
					if (this.isType(i-1,j-1,TYPES.WALL) &&
							this.isType(i-1,j,TYPES.WALL) &&
							this.isType(i-1,j+1,TYPES.WALL) &&
							this.isType(i,j-1,TYPES.WALL) &&
							this.isType(i,j,TYPES.WALL) &&
							this.isType(i,j+1,TYPES.WALL) &&
							this.isType(i+1,j-1,TYPES.WALL) &&
							this.isType(i+1,j,TYPES.WALL) &&
							this.isType(i+1,j+1,TYPES.WALL)) {
								//Middle-center wall
								this.points[i][j].img=WALL_9S_MC_IMG;
	              this.points[i][j].yOffset=0;
							} else if (
								this.isType(i-1,j-1,TYPES.WALL) &&
								this.isType(i-1,j,TYPES.WALL) &&
								this.isType(i-1,j+1,TYPES.WALL) &&
								this.isType(i,j-1,TYPES.WALL) &&
								this.isType(i,j,TYPES.WALL) &&
								this.isType(i,j+1,TYPES.WALL) &&
								!(this.isType(i+1,j-1,TYPES.WALL) &&
									this.isType(i+1,j,TYPES.WALL)) &&
								!(this.isType(i+1,j+1,TYPES.WALL) && 
									this.isType(i+1,j,TYPES.WALL))) {
									//Bottom-center wall
									this.points[i][j].img=WALL_9S_BC_IMG;
	            	  this.points[i][j].yOffset=0;
							} else if (
								!(this.isType(i-1,j-1,TYPES.WALL) &&
									this.isType(i-1,j,TYPES.WALL)) &&
								!(this.isType(i-1,j+1,TYPES.WALL) &&
									this.isType(i-1,j,TYPES.WALL)) &&
								this.isType(i,j-1,TYPES.WALL) &&
								this.isType(i,j,TYPES.WALL) &&
								this.isType(i,j+1,TYPES.WALL) &&
								this.isType(i+1,j-1,TYPES.WALL) &&
								this.isType(i+1,j,TYPES.WALL) &&
								this.isType(i+1,j+1,TYPES.WALL)) {
									//top-center wall
									this.points[i][j].img=WALL_9S_TC_IMG;
	            	  this.points[i][j].yOffset=0;
							} else if (
								!(this.isType(i-1,j-1,TYPES.WALL) &&
									this.isType(i,j-1,TYPES.WALL)) &&
								this.isType(i-1,j,TYPES.WALL) &&
								this.isType(i-1,j+1,TYPES.WALL) &&
								this.isType(i,j,TYPES.WALL) &&
								this.isType(i,j+1,TYPES.WALL) &&
								!(this.isType(i+1,j-1,TYPES.WALL) &&
									this.isType(i,j-1,TYPES.WALL)) &&
								this.isType(i+1,j,TYPES.WALL) &&
								this.isType(i+1,j+1,TYPES.WALL)) {
									//middle-left wall
									this.points[i][j].img=WALL_9S_ML_IMG;
	            	  this.points[i][j].yOffset=0;
							} else if (
								this.isType(i-1,j,TYPES.WALL) &&
								this.isType(i-1,j+1,TYPES.WALL) &&
								!(this.isType(i-1,j-1,TYPES.WALL) &&
								  this.isType(i,j-1,TYPES.WALL)) &&
								this.isType(i,j,TYPES.WALL) &&
								this.isType(i,j+1,TYPES.WALL) &&
								!(this.isType(i+1,j,TYPES.WALL) &&
								  this.isType(i+1,j+1,TYPES.WALL))) {
									//bottom-left wall
									this.points[i][j].img=WALL_9S_BL_IMG;
	            	  this.points[i][j].yOffset=0;
							} else if (
								!(this.isType(i-1,j,TYPES.WALL) &&
									this.isType(i-1,j+1,TYPES.WALL)) &&
								!(this.isType(i,j-1,TYPES.WALL) &&
									this.isType(i+1,j-1,TYPES.WALL)) &&
								this.isType(i,j,TYPES.WALL) &&
								this.isType(i,j+1,TYPES.WALL) &&
								this.isType(i+1,j,TYPES.WALL) &&
								this.isType(i+1,j+1,TYPES.WALL)) {
									//top-left wall
									this.points[i][j].img=WALL_9S_TL_IMG;
	            	  this.points[i][j].yOffset=0;
							} else if (
								this.isType(i-1,j-1,TYPES.WALL) &&
								this.isType(i-1,j,TYPES.WALL) &&
								!(this.isType(i-1,j+1,TYPES.WALL) &&
									this.isType(i,j+1,TYPES.WALL)) &&
								this.isType(i,j-1,TYPES.WALL) &&
								this.isType(i,j,TYPES.WALL) &&
								this.isType(i+1,j-1,TYPES.WALL) &&
								this.isType(i+1,j,TYPES.WALL) &&
								!(this.isType(i,j+1,TYPES.WALL) &&
								this.isType(i+1,j+1,TYPES.WALL))) {
									//middle-right wall
									this.points[i][j].img=WALL_9S_MR_IMG;
	            	  this.points[i][j].yOffset=0;
							} else if (
								this.isType(i-1,j-1,TYPES.WALL) &&
								this.isType(i-1,j,TYPES.WALL) &&
								!(this.isType(i-1,j+1,TYPES.WALL) &&
									this.isType(i,j+1,TYPES.WALL)) &&
								this.isType(i,j-1,TYPES.WALL) &&
								this.isType(i,j,TYPES.WALL) &&
								!(this.isType(i+1,j-1,TYPES.WALL) &&
									this.isType(i+1,j,TYPES.WALL))) {
									//bottom-right wall
									this.points[i][j].img=WALL_9S_BR_IMG;
	            	  this.points[i][j].yOffset=0;
							} else if (
								!(this.isType(i-1,j-1,TYPES.WALL) &&
									this.isType(i-1,j,TYPES.WALL)) &&
								this.isType(i,j-1,TYPES.WALL) &&
								this.isType(i,j,TYPES.WALL) &&
								!(this.isType(i,j+1,TYPES.WALL) &&
									this.isType(i+1,j+1,TYPES.WALL)) &&
								this.isType(i+1,j-1,TYPES.WALL) &&
								this.isType(i+1,j,TYPES.WALL)) {
									//top-right wall
									this.points[i][j].img=WALL_9S_TR_IMG;
	            	  this.points[i][j].yOffset=0;
							} else if (this.isType(i-1,j-1,TYPES.WALL) &&
                this.isType(i-1,j,TYPES.WALL) &&
                this.isType(i-1,j+1,TYPES.WALL) &&
                this.isType(i,j-1,TYPES.WALL) &&
                this.isType(i,j,TYPES.WALL) &&
                this.isType(i,j+1,TYPES.WALL) &&
                this.isType(i+1,j-1,TYPES.WALL) &&
                this.isType(i+1,j,TYPES.WALL) &&
                !this.isType(i+1,j+1,TYPES.WALL)) {
                    //9-slice with bottom-right missing
                    this.points[i][j].img = WALL_9S_MCBR_IMG;
                    this.points[i][j].yOffset=0;
              } else if (this.isType(i-1,j-1,TYPES.WALL) &&
                this.isType(i-1,j,TYPES.WALL) &&
                this.isType(i-1,j+1,TYPES.WALL) &&
                this.isType(i,j-1,TYPES.WALL) &&
                this.isType(i,j,TYPES.WALL) &&
                this.isType(i,j+1,TYPES.WALL) &&
                !this.isType(i+1,j-1,TYPES.WALL) &&
                this.isType(i+1,j,TYPES.WALL) &&
                this.isType(i+1,j+1,TYPES.WALL)) {
                    //9-slice with bottom-left missing
                    this.points[i][j].img = WALL_9S_MCBL_IMG;
                    this.points[i][j].yOffset=0;
              } else if (this.isType(i-1,j-1,TYPES.WALL) &&
                this.isType(i-1,j,TYPES.WALL) &&
                !this.isType(i-1,j+1,TYPES.WALL) &&
                this.isType(i,j-1,TYPES.WALL) &&
                this.isType(i,j,TYPES.WALL) &&
                this.isType(i,j+1,TYPES.WALL) &&
                this.isType(i+1,j-1,TYPES.WALL) &&
                this.isType(i+1,j,TYPES.WALL) &&
                this.isType(i+1,j+1,TYPES.WALL)) {
                    //9-slice with top-right missing
                    this.points[i][j].img = WALL_9S_MCTR_IMG;
                    this.points[i][j].yOffset=0;
              } else if (
                !this.isType(i-1,j-1,TYPES.WALL) &&
                this.isType(i-1,j,TYPES.WALL) &&
                this.isType(i-1,j+1,TYPES.WALL) &&
                this.isType(i,j-1,TYPES.WALL) &&
                this.isType(i,j,TYPES.WALL) &&
                this.isType(i,j+1,TYPES.WALL) &&
                this.isType(i+1,j-1,TYPES.WALL) &&
                this.isType(i+1,j,TYPES.WALL) &&
                this.isType(i+1,j+1,TYPES.WALL)) {
                    //9-slice with top-left missing
                    this.points[i][j].img = WALL_9S_MCTL_IMG;
                    this.points[i][j].yOffset=0;
              } else if (this.isType(i,j-1,TYPES.WALL) &&
								this.isType(i, j+1, TYPES.WALL) &&
								(this.isType(i+1, j, TYPES.WALL) ||
									this.isType(i-1, j, TYPES.WALL))) {
											//Fix T-shaped and inverse T-shaped walls
											this.points[i][j].img=WALL_BLOCK_IMG;
	                		this.points[i][j].yOffset=0;
							 } else if (this.isType(i-1,j,TYPES.WALL) && 
											this.isType(i+1,j,TYPES.WALL) &&
											(this.isType(i,j-1,TYPES.WALL) ||
													this.isType(i,j+1,TYPES.WALL))) {
													//Fix -| and |- walls
													this.points[i][j].img = WALL_BLOCK_IMG;
                      		this.points[i][j].yOffset=0;
							} else if (this.isType(i-1,j,TYPES.WALL) &&
							  this.isType(i+1,j,TYPES.WALL) &&
							  !this.isType(i, j-1, TYPES.WALL) &&
								!this.isType(i,j+1, TYPES.WALL)) {
                    //Fix vertical wall image
                    this.points[i][j].img=VERTICAL_WALL_IMG;
           	  } else if (this.isType(i,j-1,TYPES.WALL) &&
								this.isType(i, j+1, TYPES.WALL) &&
								!this.isType(i-1,j, TYPES.WALL) &&
								!this.isType(i+1,j, TYPES.WALL)) {
                    //Fix horizontal wall image
                    this.points[i][j].img=HORIZONTAL_WALL_IMG;
                    this.points[i][j].yOffset=3*SPRITE_SCALE;
              } else {
										//default to the pillar wall
										this.points[i][j].img = WALL_BLOCK_IMG; 
	              		this.points[i][j].yOffset=0;
        		}
		}
    }
  } 
}

/**
* Given a row, column and and object type, returns true if the point at
* at this.points[i][j] has obj_type==type
* Note that maze rows and columns are not 0-indexed (first row/col is 1,1).
*/
Maze.prototype.isType = function (i,j,type) {
	return (i>=0 && i<this.rows && j>=0 && j<this.cols &&
					this.points[i][j]!=undefined &&
					this.points[i][j].obj_type==type);
}

// // Adds an array of Point Objects to this Maze
// // Takes arr an Array of Point objects
// Maze.prototype.addObjs= function(arr) {
// 	this.objs = this.objs.concat(arr);
// }

// Maze.prototype.addObj= function(obj) {
// 	this.objs.push(obj)
// }

// Adds a point object to this Maze
Maze.prototype.addPoint = function(pt) {
	// Ensure you can only add points within the maze
	if (pt.r >0 && pt.r <= this.rows && pt.c > 0 && pt.c <= this.cols) {
		this.points[pt.r-1][pt.c-1] = pt;
		if (pt.obj_type == TYPES.START) {
			this.setStart(pt.r, pt.c);
		}
    	return pt;
	}
}

// Adds a point object to this Maze
Maze.prototype.removePoint = function(r, c) {
	if (r >0 && r <= this.rows && c > 0 && c <= this.cols) {
		var pt = this.points[r-1][c-1];
		if (pt && pt.obj_type == TYPES.START) {
			//If you're removing a start, unset the start position
			this.unsetStart();
		}
		this.points[r-1][c-1]=BLANK;
	}
}

/*
* Returns a point at r, c in the maze or undefined if none exists
*/
Maze.prototype.hasPoint = function(r, c) {
	return this.points[r-1][c-1];
}

Maze.prototype.getPoint = function(r,c) {
	return this.points[r-1][c-1];
}

Maze.prototype.isOn = function (r, c) {
        var pt = this.getPoint(r,c);
        if (pt && pt.isOn) {
                pt.isOn();
        }
}

Maze.prototype.render = function (stage) {
	for (var i =0; i<this.rows; i++) {
		for (var j =0; j<this.cols; j++) {
            //render the background tiles the first time we render the maze.
            if (game_state != GAME_STATES.FAILED) {
                renderObject(
                    new TilePoint(i+1, j+1),
                    tileStage);
            }
			if (this.points[i][j]) {
				renderObject(this.points[i][j], stage);
			}
		}
	}
}

/*************************************/
/* Maze events                       */
/*************************************/

function cleanUp() {
    printState();
    stopGameLoop();
}

function mazeCollision() {
    game_state = GAME_STATES.FAILED;
    stopMusic();
    playMultiSound('defeat');
    LEVEL_SCORE = 0;
    cleanUp();
}

function mazeComplete() {
    game_state = GAME_STATES.COMPLETE;
    stopMusic();
    playMultiSound('victory');
    maze.complete();
    TOTAL_SCORE += LEVEL_SCORE;
    LEVEL_SCORE = 0;
    CURRENT_LEVEL+=1;
    saveGameState();
    renderScore();
    cleanUp();
}

function collectBonus() {
    maze.collectBonus();
    playMultiSound('pick_up');
}

function gameComplete() {
    game_state = GAME_STATES.GAME_COMPLETE;
    CURRENT_LEVEL=0;
    for (var i=0; i<LEVELS.length;i++) {
        LEVELS[i].initPoints();
    }
    cleanUp();
}


/*************************************/
/* Initialization functions          */
/*************************************/

function init(fn) { 
    POST_ASSET_LOAD_FN = fn;

    //Short-circuit if we don't want to load assets.
    if (!LOAD_ASSETS) { return;}
    loadAssets(); 


}

function saveGameState() {
  $.cookie("CurrentLevel",CURRENT_LEVEL);
  $.cookie("TotalScore",TOTAL_SCORE);
}

function initGameState() {
  CURRENT_LEVEL = $.cookie("CurrentLevel") ? parseInt($.cookie("CurrentLevel")) : 0;
  TOTAL_SCORE = $.cookie("TotalScore") ? parseInt($.cookie("TotalScore")) : 0;
}

function loadAssets() {
    if (ISOMETRIC) {
        GRID_W = 28;
        GRID_H = 28;
	    BORDER_IMG = createImgAsset("border", 
            "<%= asset_path('border_iso.png') %>");
	    SNAKE_IMG = createImgAsset("snake", 
            "<%= asset_path('snake_iso.png') %>");
	    GOAL_IMG = createImgAsset("goal",
            "<%= asset_path('goal_iso.png') %>");
    } else {
//	    BORDER_IMG = createImgAsset("border",
//            "<%= asset_path('border_19x19.png') %>");
//	    SNAKE_IMG = createImgAsset("dragon",
//            "<%= asset_path('mover_19x19.png') %>");
//	    GOAL_IMG = createImgAsset("goal",
//            "<%= asset_path('goal_19x19.png') %>");
//	    STAR_IMG = createImgAsset("star",
//            "<%= asset_path('star_19x19.png') %>");
	    PANDA_IMG = createImgAsset("panda",
            "<%= asset_path('Panda.png') %>");
	    PORTAL_IMG = createImgAsset("portal",
            "<%= asset_path('Goal_1.png') %>");
	    HEAD_UP_IMG = createImgAsset("head_up",
            "<%= asset_path('Head_Up.png') %>");
	    HEAD_DOWN_IMG = createImgAsset("head_down",
            "<%= asset_path('Head_Down.png') %>");
	    HEAD_LEFT_IMG = createImgAsset("head_left",
            "<%= asset_path('Head_Left.png') %>");
	    HEAD_RIGHT_IMG = createImgAsset("head_right",
            "<%= asset_path('Head_Right.png') %>");

	    TAIL_UP_IMG = createImgAsset("tail_up",
            "<%= asset_path('Tail_Up.png') %>");
	    TAIL_DOWN_IMG = createImgAsset("tail_down",
            "<%= asset_path('Tail_Down.png') %>");
	    TAIL_LEFT_IMG = createImgAsset("tail_left",
            "<%= asset_path('Tail_Right.png') %>");
	    TAIL_RIGHT_IMG = createImgAsset("tail_right",
            "<%= asset_path('Tail_Left.png') %>");
        DOWN_TO_LEFT_IMG = createImgAsset("dtl",
            "<%= asset_path('Body_UpToLeft.png') %>");
        DOWN_TO_RIGHT_IMG = createImgAsset("dtr",
            "<%= asset_path('Body_UpToRight.png') %>");
        DOWN_TO_UP_IMG = createImgAsset("dtu",
            "<%= asset_path('Body_DownToUp.png') %>");
        LEFT_TO_DOWN_IMG= createImgAsset("ltd",
            "<%= asset_path('Body_RightToDown.png') %>");
        LEFT_TO_RIGHT_IMG= createImgAsset("ltr",
            "<%= asset_path('Body_RightToLeft.png') %>");
        LEFT_TO_UP_IMG= createImgAsset("ltu",
            "<%= asset_path('Body_RightToUp.png') %>");
        RIGHT_TO_DOWN_IMG= createImgAsset("rtd",
            "<%= asset_path('Body_LeftToDown.png') %>");
        RIGHT_TO_LEFT_IMG= createImgAsset("rtl",
            "<%= asset_path('Body_LeftToRight.png') %>");
        RIGHT_TO_UP_IMG= createImgAsset("rtu",
            "<%= asset_path('Body_UpToLeft.png') %>");
        UP_TO_DOWN_IMG= createImgAsset("utd",
            "<%= asset_path('Body_UpToDown.png') %>");
        UP_TO_LEFT_IMG= createImgAsset("utl",
            "<%= asset_path('Body_DownToLeft.png') %>");
        UP_TO_RIGHT_IMG= createImgAsset("utr",
            "<%= asset_path('Body_DownToRight.png') %>");

        TILES_IMG_ARRAY= [];
        TILES_IMG_ARRAY.push(createImgAsset("tile_1",
              "<%= asset_path('tiles.png') %>"));
        TILES_IMG_ARRAY.push(createImgAsset("tile_2",
              "<%= asset_path('tiles_2.png') %>"));
        TILES_IMG_ARRAY.push(createImgAsset("tile_3",
              "<%= asset_path('tiles_3.png') %>"));
        TILES_IMG_ARRAY.push(createImgAsset("tile_4",
              "<%= asset_path('tiles_4.png') %>"));

				//load wall images
        VERTICAL_WALL_IMG = createImgAsset("vw",
            "<%= asset_path('wall_stright_horizontal.png') %>");
        HORIZONTAL_WALL_IMG = createImgAsset("hw",
            "<%= asset_path('wall_stright_vertical.png') %>");
	    	WALL_BLOCK_IMG = createImgAsset("pillar",
            "<%= asset_path('wall_block.png') %>");

				WALL_9S_TL_IMG = createImgAsset('wall_9s_tl', 
            "<%= asset_path('wall_9slice_tl.png') %>");
				WALL_9S_TC_IMG = createImgAsset('wall_9s_tc', 
				    "<%= asset_path('wall_9slice_tc.png') %>");
				WALL_9S_TR_IMG= createImgAsset('wall_9s_tr', 
				    "<%= asset_path('wall_9slice_tr.png') %>");
				WALL_9S_ML_IMG= createImgAsset('wall_9s_ml', 
				    "<%= asset_path('wall_9slice_ml.png') %>");
				WALL_9S_MC_IMG = createImgAsset('wall_9s_mc', 
				    "<%= asset_path('wall_9slice_mc.png') %>");
				WALL_9S_MR_IMG= createImgAsset('wall_9s_mr', 
				    "<%= asset_path('wall_9slice_mr.png') %>");
				WALL_9S_BL_IMG= createImgAsset('wall_9s_bl', 
				    "<%= asset_path('wall_9slice_bl.png') %>");
				WALL_9S_BC_IMG= createImgAsset('wall_9s_bc', 
				    "<%= asset_path('wall_9slice_bc.png') %>");
				WALL_9S_BR_IMG= createImgAsset('wall_9s_br', 
            "<%= asset_path('wall_9slice_br.png') %>");
	
				//All the corner walls within a 9 slice are the same right now.
				//FIXME: add real images for 9-slice corners
				WALL_9S_MCTR_IMG= 
						WALL_9S_MCTL_IMG= 
						WALL_9S_MCBR_IMG= 
						WALL_9S_MCBL_IMG=
						WALL_9S_MC_IMG;


				//Only used in level builder
        DELETE_IMG = createImgAsset("delete", 
            "<%= asset_path('delete.png') %>");

    }
}


function createImgAsset($id,$src) {
	var img=new Image();
	loadFlags[$id]=0;
	img.onload=function(){onAssetLoaded($id);};
	img.src=$src;
//    img.height = GRID_H;
//    img.width = GRID_W;
	return img;
}

function onAssetLoaded($asset_id) {
	loadFlags[$asset_id]=1;
    //Don't start the game until everything's been loaded
	for(flag in loadFlags) {
		if(!loadFlags[flag]) {return;}
	}
    //Only continue if we want to continue the game
    if (POST_ASSET_LOAD_FN) {POST_ASSET_LOAD_FN();}
    if (!INIT_GAME) { return;}
	game_init();
}

function game_init() {

    //Init stuff you'll need if you're playing
    initGameState();
    //Init configuration panel
    $("input[name=speed]:radio").click(function() {changeSpeed(this.value);});
    $("#ctrl_fx").click(function() {toggleFX(this.checked);});
    $("#ctrl_music").click(function() {toggleMusic(this.checked)});
    $("#options_link").click(function() {toggleOptions()});
    $("#options_done").click(function() {toggleOptions()});
    $("#quit").click(function() {quit()});
    initSound();


    //Set up graphics
	gameCanvas = document.getElementById('maze-canvas');
	bgCanvas = document.getElementById('maze-canvas-background');
    tileCanvas = document.getElementById('tile-canvas');
	gameStage = gameCanvas.getContext("2d");
	bgStage = bgCanvas.getContext("2d");
	tileStage = tileCanvas.getContext("2d");
	counter = 0;
	CanvasTextFunctions.enable(gameStage);
    init_levels();
    maze_init();
}

function maze_init(){
    if(game_state == GAME_STATES.COMPLETE) {
		tileStage.clearRect(0,0,bgCanvas.width,bgCanvas.height);
        if (CURRENT_LEVEL>=LEVELS.length){
            gameComplete();
            return;
        }

    } 

    if (game_state != GAME_STATES.FAILED) {
      if (CURRENT_LEVEL >= LEVELS.length) { 
        //Ran into messed up cookie values.
        CURRENT_LEVEL = 0; 
        TOTAL_SCORE = 0;
      }
        maze = LEVELS[CURRENT_LEVEL];
        var hpx = MAX_ROWS*GRID_H+WALL_PAD;
        var wpx = MAX_COLS*GRID_W;
        $(gameCanvas).attr("height", hpx);
        $(gameCanvas).attr("width", wpx);
        $(bgCanvas).attr("height", hpx);
        $(bgCanvas).attr("width", wpx);
        $(tileCanvas).attr("height", hpx);
        $(tileCanvas).attr("width", wpx);
    } else {
        maze.initPoints();
    }

	maze.render(bgStage);
	game_state = GAME_STATES.READY;
    printState();
    renderScore();
	var rc = maze.getStart();
    //Do nothing if Dragon is on itself.
	dragon = new StartPoint(rc[0], rc[1]);
    dir="start";
    startMusic();
	startGameLoop();
}

/*************************************/
/* Configuation functions            */
/*************************************/

function changeSpeed(s) {
     //console.log("Changing speed from "+MOVE_DELAY+" to "+s);
     MOVE_DELAY=parseInt(s);
}

/* Music and sound effects functions */

//Set up audio channels for seamless, simultaneous play of multiple sounds
//Thanks to http://www.storiesinflight.com/html5/audio.html 
function initSound() {
    //Code courtesy of http://html5doctor.com/native-audio-in-the-browser/
    var myAudio = $('#theme'); 
    if (myAudio.canPlayType) {
       // Currently canPlayType(type) returns: "", "maybe" or "probably" 
       //canPlayMp3 = !!myAudio.canPlayType && 
       //                 "" != myAudio.canPlayType('audio/mpeg');
       var canPlayOgg = !!myAudio.canPlayType && 
                        "" != myAudio.canPlayType('audio/ogg; codecs="vorbis"');
    }
    //Cache the appropriate audio source
    $.each($("audio"), function (i, v) {
                $.each($(v).children(), function (i2, v2) {
                        //Use ogg by default because it's smaller and open =)
                        if (v2.type == OGG_STR && canPlayOgg) {
                            AUDIO_SRC[v.id] = v2.src;
                        } else if (!canPlayOgg) {
                            //Otherwise set to MP3
                            AUDIO_SRC[v.id] = v2.src;
                        }
                    }
                )});
    
    for (a=0;a<CHANNEL_MAX;a++) { // prepare the channels
        AUDIOCHANNELS[a] = new Array();
        AUDIOCHANNELS[a]['channel'] = new Audio();// create a new audio object
        AUDIOCHANNELS[a]['finished'] = -1;// expected end time for this channel
    }
    //Workaround for Firefox and Safari
    THEME = new Audio();
    THEME.load();
    THEME.src=AUDIO_SRC['theme'];
    THEME.volume=.3;
    THEME.loop="loop";
    //Loop the theme track
    $(THEME).bind('ended', function() {this.currentTime=0});
}

function startMusic() {
    if (PLAY_THEME) {
        THEME.play();
        //$('#theme')[0].load();
        //$('#theme').bind('ended', function() {this.currentTime=0});
        //$('#theme')[0].volume=.3;
        //$('#theme')[0].play();
    }
}

function stopMusic() {
    //$('#theme')[0].pause();
    THEME.pause();
}

function toggleFX(on) {
    PLAY_FX = on;
}

function toggleMusic(on) {
    PLAY_THEME = on;
    if (PLAY_THEME) {
        startMusic();
    } else {
        stopMusic();
    }
}

function toggleOptions() {
  $("#lightbox").toggle();
}

function deleteCookie() {
  $.removeCookie("CurrentLevel");
  $.removeCookie("TotalScore");
}

function quit() {
  deleteCookie();
  window.location = "/";
}

//Plays multiple sounds simultaneously a bit more smoothly than would happen normally.
//Courtesy of http://www.storiesinflight.com/html5/audio.html. Thanks!
function playMultiSound(s) {
    if (PLAY_FX) {
        for (a=0;a<AUDIOCHANNELS.length;a++) {
            thistime = new Date();
            if (AUDIOCHANNELS[a]['finished'] < thistime.getTime()) {            // is this channel finished?
                AUDIOCHANNELS[a]['finished'] = thistime.getTime() + document.getElementById(s).duration*1000;
                AUDIOCHANNELS[a]['channel'].src = AUDIO_SRC[s];
                AUDIOCHANNELS[a]['channel'].load();
                AUDIOCHANNELS[a]['channel'].play();
                break;
            }
        }
    }
}


/*************************************/
/* Mazes                             */
/*************************************/

function init_levels() {
	var l1 = new Maze("20f0e010101010101010101010101010101040000000000000000000000010100000000000000000000000001010000000000000100000000000101000000000000010000000000010100000000000001000000000001010000000002000100000200000301000000000000010000000000030100000000000001000000000003010000000000000100000000000101000000000000010000000000010100000000000001000000000001010000000000000000000000000101000000000000000000000000010101010101010101010101010101");
	LEVELS.push(l1);


    //Wesley's maze
	// //     objs = [];
	// //     objs.push(new WallArr(5,2,16,3));
	// //     objs.push(new WallArr(2,6,3,24));
	// //     objs.push(new WallArr(4,6,5,7));
	// //     objs.push(new WallArr(2,5,6,5));
	// //     objs.push(new WallArr(9,5,9,7));
	// //     objs.push(new WallArr(10,7,15,7));
	// //     objs.push(new WallArr(15,8,15,11));
	// //     objs.push(new WallArr(13,11,14,11));
	// //     objs.push(new WallArr(6,6,6,8));
	// //     objs.push(new WallArr(5,8,5,8));
	// //     objs.push(new WallArr(4,8,4,23));
	// //     objs.push(new WallArr(7,8,7,8));
	// //     objs.push(new WallArr(6,11,6,22));
	// //     objs.push(new WallArr(6,11,6,22));
	// //     objs.push(new WallArr(9,11,9,17));
	// //     objs.push(new WallArr(10,17,16,17));
	// //     objs.push(new WallArr(13,15,15,15));
	// //     objs.push(new WallArr(10,19,15,19));
	// //     objs.push(new WallArr(10,20,10,21));
	// //     objs.push(new WallArr(10,18,10,18));
	// //     objs.push(new WallArr(6,22,6,22));
	// //     objs.push(new WallArr(8,22,10,22));
	// //     objs.push(new WallArr(12,22,13,22));
	// //     objs.push(new WallArr(15,23,15,24));
	// //     objs.push(new WallArr(15,16,15,16));
	// //     objs.push(new GoalArr(16,24,16,24));
	// //     var wm = new Maze();
	// //   wm.setSize(17,25);
	// //   wm.setStart( 3,3);
	// // 	wm.addObjs(objs);
	// // 	wm.initObs();
	// // 
	// // 
	// //     //Josh's maze
	// //     objs = [];
	// //     objs.push(new WallArr(2,2,3,2));
	// //     objs.push(new WallArr(6,2,6,2));
	// //     objs.push(new WallArr(2,5,5,7));
	// //     objs.push(new WallArr(2,4,2,4));
	// //     objs.push(new WallArr(4,4,5,4));
	// //     objs.push(new WallArr(7,4,7,7));
	// //     objs.push(new WallArr(8,7,13,7));
	// //     objs.push(new WallArr(9,3,10,5));
	// //     objs.push(new WallArr(11,3,11,4));
	// //     objs.push(new WallArr(13,4,13,6));
	// //     objs.push(new WallArr(14,4,15,4));
	// //     objs.push(new WallArr(15,5,15,7));
	// //     objs.push(new WallArr(3,9,4,11));
	// //     objs.push(new WallArr(6,9,12,9));
	// //     objs.push(new WallArr(14,9,15,9));
	// //     objs.push(new WallArr(6,11,7,11));
	// //     objs.push(new WallArr(9,10,9,12));
	// //     objs.push(new WallArr(11,11,12,14));
	// //     objs.push(new WallArr(14,11,15,14));
	// //     objs.push(new WallArr(2,12,5,12));
	// //     objs.push(new WallArr(6,13,9,14));
	// //     objs.push(new WallArr(10,14,10,14));
	// //     objs.push(new WallArr(2,14,2,14));
	// //     objs.push(new WallArr(4,14,4,16));
	// //     objs.push(new WallArr(3,16,3,16));
	// //     objs.push(new WallArr(6,12,6,12));
	// //     objs.push(new WallArr(6,16,6,16));
	// //     objs.push(new WallArr(12,8,12,8));
	// //     objs.push(new WallArr(13,11,13,11));
	// //     objs.push(new WallArr(9,16,10,16));
	// //     objs.push(new WallArr(13,16,16,16));
	// //     objs.push(new PandaArr(11,5));
	// //     objs.push(new PandaArr(13,8));
	// //     objs.push(new PandaArr(11,16));
	// //     objs.push(new GoalArr(2,16,2,16));
	// //     var jm = new Maze();
	// //   jm.setSize(17,17);
	// //   jm.setStart( 2,8);
	// // 	jm.addObjs(objs);
	// // 	jm.initObs();
	// // 
	// //     //Level 1
	// // 	//     objs = [];
	// // 	//     objs.push(new WallArr(6,6,6,10));
	// // 	//     objs.push(new WallArr(7,10,12,10));
	// // 	//     objs.push(new GoalArr(7,20,9,20));
	// // 	//     //var l1 = new Maze(20,20, 2, 2, 0, 0, objs);
	// // 	//     var l1 = new Maze();
	// // 	// 	  l1.setSize(20,20);
	// // 	// 	  l1.setStart(2,2);
	// // 	// l1.addObjs(objs);
	// // 	// l1.initObs();
	// var l1 = new Maze();
	// l1.load("20f0e010101010101010101010101010101040000000000000000000000010100000000000000000000000001010000000000000100000000000101000000000000010000000000010100000000000001000000000001010000000002000100000200000301000000000000010000000000030100000000000001000000000003010000000000000100000000000101000000000000010000000000010100000000000001000000000001010000000000000000000000000101000000000000000000000000010101010101010101010101010101")

    //First walls
		//     objs = [];
		//     objs.push(new WallArr(2,6,9,6));
		//     objs.push(new WallArr(12,6,14,6));
		//     objs.push(new WallArr(12,7,12,11));
		//     objs.push(new WallArr(11,11,5,11));
		//     objs.push(new GoalArr(15,7,15,8));
		//     var fw = new Maze();
		// 	  fw.setSize(15,15);
		// 	  fw.setStart( 2,2);
		// fw.addObjs(objs);
		// fw.initObs();
		// 
		// 
		// 
		//     //Impossible start
		//     objs = [];
		//     objs.push(new WallArr(2,2,2,4));
		//     objs.push(new WallArr(2,3,2,14));
		//     objs.push(new WallArr(3,14,3,14));
		//     objs.push(new WallArr(4,4,11,4));
		//     objs.push(new WallArr(4,12,11,12));
		//     objs.push(new WallArr(6,3,6,3));
		//     objs.push(new WallArr(11,5,11,11));
		//     objs.push(new WallArr(9,6,9,9));
		//     objs.push(new WallArr(6,7,6,9));
		//     objs.push(new WallArr(7,7,7,7));
		//     objs.push(new WallArr(7,9,7,9));
		//     objs.push(new GoalArr(15,8,15,8));
		//     objs.push(new PandaArr(9,5));        
		//     objs.push(new PandaArr(9,10));       
		//     objs.push(new PandaArr(7,3)); 
		//     //var is = new Maze(15,15, 7, 8, 0, 0, objs);
		//     var is = new Maze();
		// 	  is.setSize(15,15);
		// 	  is.setStart( 7,8);
		// is.addObjs(objs);
		// is.initObs();
		// 
		//     //Spiral
		//     objs = [];
		//     objs.push(new WallArr(3,3,3,10));
		//     objs.push(new WallArr(4,3,10,3));
		//     objs.push(new WallArr(10,4,10,9));
		//     objs.push(new WallArr(9,9,5,9));
		//     objs.push(new WallArr(5,8,5,5));
		//     objs.push(new WallArr(6,5,8,5));
		//     objs.push(new WallArr(8,6,8,7));
		//     objs.push(new WallArr(7,7,7,7));
		//     objs.push(new GoalArr(7,6,7,6));
		//     //var sm = new Maze(12,11, 2, 10, 0, 0, objs);
		//     var sm = new Maze(12,11, 2, 10, 0, 0, objs);
		// 	  sm.setSize(12,11);
		// 	  sm.setStart( 2,10);
		// sm.addObjs(objs);
		// sm.initObs();
		// 
		//     //X
		//     objs = []
		//     objs.push(new WallArr(2,2,2,2));
		//     objs.push(new WallArr(3,3,3,3));
		//     objs.push(new WallArr(4,4,4,4));
		//     objs.push(new WallArr(5,5,5,5));
		//     objs.push(new WallArr(7,7,7,7));
		//     objs.push(new WallArr(8,8,8,8));
		//     objs.push(new WallArr(10,10,10,10));
		//     objs.push(new WallArr(11,11,11,11));
		//     objs.push(new WallArr(10,3,10,3));
		//     objs.push(new WallArr(9,4,9,4));
		//     objs.push(new WallArr(8,5,8,5));
		//     objs.push(new WallArr(7,6,7,6));
		//     objs.push(new WallArr(6,7,6,7));
		//     objs.push(new WallArr(5,8,5,8));
		//     objs.push(new WallArr(4,9,4,9));
		//     objs.push(new WallArr(3,10,3,10));
		//     objs.push(new WallArr(2,11,2,11));
		//     objs.push(new GoalArr(3,11,3,11));
		//     //var xm = new Maze(12,12, 2, 10, 0, 0, objs);
		//     var xm = new Maze();
		// 	  xm.setSize(12,12);
		// 	  xm.setStart(2,10);
		// xm.addObjs(objs);
		// xm.initObs();
		// 
		//     //Falldown
		//     objs = []
		//     objs.push(new WallArr(3,5,3,7));
		//     objs.push(new WallArr(5,2,5,4));
		//     objs.push(new WallArr(5,2,5,4));
		//     objs.push(new WallArr(7,5,7,7));
		//     objs.push(new WallArr(8,5,8,7));
		//     objs.push(new GoalArr(8,6,8,6));
		//     //var fd = new Maze(10,8,2,7, 0, 0, objs);
		//     var fd = new Maze();
		// 	  fd.setSize(10,8);
		// 	  fd.setStart(2,7);
		// fd.addObjs(objs);
		// fd.initObs();
		// 
		//     //corridors
		//     objs = []
		//     objs.push(new WallArr(3,5,13,5));
		//     objs.push(new WallArr(2,7,12,7));
		//     objs.push(new WallArr(3,9,13,9));
		//     objs.push(new GoalArr(6,11,6,11));          
		//     //var cm = new Maze(14,11,13,3, 0, 0, objs);       
		//     var cm = new Maze();       
		// 	  cm.setSize(14,11);
		// 	  cm.setStart(13,3);
		// cm.addObjs(objs);
		// cm.initObs();
		//          
		//     //Maginot        
		//     objs = []        
		//     objs.push(new WallArr(3,3,3,3));        
		//     objs.push(new WallArr(5,3,5,3));        
		//     objs.push(new WallArr(7,3,7,3));        
		//     objs.push(new WallArr(9,3,9,3));        
		//     objs.push(new WallArr(2,5,2,5));        
		//     objs.push(new WallArr(4,5,4,5));        
		//     objs.push(new WallArr(6,5,6,5));        
		//     objs.push(new WallArr(8,5,8,5));        
		//     objs.push(new WallArr(3,7,3,7));        
		//     objs.push(new WallArr(5,7,5,7));        
		//     objs.push(new WallArr(7,7,7,7));        
		//     objs.push(new WallArr(9,7,9,7));        
		//     objs.push(new PandaArr(2,4));        
		//     objs.push(new PandaArr(2,6));        
		//     objs.push(new PandaArr(9,8));        
		//     objs.push(new GoalArr(10,9,10,9));          
		//     //var mg = new Maze(10,10,9,2, 0, 0, objs);        
		//     var mg = new Maze();        
		// 	  mg.setSize(10,10);
		// 	  mg.setStart(9,2);
		// mg.addObjs(objs);
		// mg.initObs();
		//          
		//     //Carpal Tunnel          
		//     objs = []        
		//     objs.push(new WallArr(2,3,5,3));        
		//     objs.push(new WallArr(7,2,8,2));        
		//     objs.push(new WallArr(5,4,10,4));       
		//     objs.push(new WallArr(10,3,10,3));          
		//     objs.push(new WallArr(3,5,3,8));        
		//     objs.push(new WallArr(5,4,5,6));        
		//     objs.push(new WallArr(7,5,7,8));        
		//     objs.push(new WallArr(9,6,9,6));        
		//     objs.push(new WallArr(9,6,9,6));        
		//     objs.push(new WallArr(6,8,10,8));       
		//     objs.push(new WallArr(10,9,10,9));          
		//     objs.push(new WallArr(7,10,8,10));          
		//     objs.push(new WallArr(4,9,5,9));        
		//     objs.push(new WallArr(2,10,2,10));          
		//     objs.push(new PandaArr(8,6));        
		//     objs.push(new PandaArr(10,6));       
		//     objs.push(new PandaArr(5,8));        
		//     objs.push(new GoalArr(6,5,6,5));        
		//     //var ct = new Maze(12,11,2,2, 0, 0, objs); 
		//     var ct = new Maze(); 
		// 	  ct.setSize(12,11);
		// 	  ct.setStart(2,2);
		// ct.addObjs(objs);
		// ct.initObs();
    
    // LEVELS.push(l1);
    // LEVELS.push(fw);
    // LEVELS.push(xm);
    // LEVELS.push(fd);
    // LEVELS.push(cm);
    // LEVELS.push(sm);
    // LEVELS.push(mg);         
    // LEVELS.push(is);         
    // LEVELS.push(ct);         
    //LEVELS.push(wm);       
    //LEVELS.push(jm); 

}

/*************************************/
/* I/O functions                     */
/*************************************/

function onKeyDown($evt){
	$evt.preventDefault();
	if (game_state==GAME_STATES.READY) {
		gameStage.clearRect(0,0,gameCanvas.width,gameCanvas.height);
		//bgStage.clearRect(0,0,bgCanvas.width,bgCanvas.height);
		//maze.render(bgStage);
		renderObject(dragon, gameStage);
		game_state=GAME_STATES.PLAYING;
	}
	if(game_state==GAME_STATES.PLAYING){
         //Save the last direction
		 if($evt.keyCode==LEFT_ARROW){
			 nextDir = "left";
		 }
		 if ($evt.keyCode==RIGHT_ARROW){
			 nextDir = "right";
		 }
		 if ($evt.keyCode==DOWN_ARROW){
			 nextDir = "down";
		 }
		 if ($evt.keyCode==UP_ARROW){
			 nextDir = "up";
	  	 }
	} else {
		gameStage.clearRect(0,0,gameCanvas.width,gameCanvas.height);
		bgStage.clearRect(0,0,bgCanvas.width,bgCanvas.height);
		maze_init();
	}
}

/*************************************/
/* Game loop control functions       */
/*************************************/

// Thanks Paul Irish. shim layer with setTimeout fallback
//Note this seems to break in Firefox and Safari, so I'm not using it.
//window.requestAnimFrame = (function(){
//  return  window.requestAnimationFrame       || 
//          window.webkitRequestAnimationFrame || 
//          window.mozRequestAnimationFrame    || 
//          window.oRequestAnimationFrame      || 
//          window.msRequestAnimationFrame     || 
//          function(/* function */ callback, /* DOMElement */ element){
//            window.setTimeout(callback, 1000 / 60);
//          };
//})();

//window.cancelRequestAnimFrame = ( function() {
//    return window.cancelAnimationFrame          ||
//        window.webkitCancelRequestAnimationFrame    ||
//        window.mozCancelRequestAnimationFrame       ||
//        window.oCancelRequestAnimationFrame     ||
//        window.msCancelRequestAnimationFrame        ||
//        window.clearTimeout;
//} )();


function startGameLoop() {
	window.onkeydown=onKeyDown;
	gameLoop();
}

function gameLoop() {
	//request=window.requestAnimFrame(gameLoop,gameCanvas);
    request = window.setTimeout(gameLoop, 1000 / 60);
	update();
}

function stopGameLoop() {
	//window.cancelRequestAnimFrame(request);
    window.clearTimeout(request);
}

//Prints the game state string in the center of the maze
function printState () {
	gameStage.drawTextCenter("sans", 16, maze.getCenterX(), 
                    maze.getCenterY(), game_state); 
}

function update() {
    //gameStage.clearRect(0,0,gameCanvas.width,gameCanvas.height);
    //maze.render(bgStage);

    //Set the right head image depending on the direction
    switch(dir) {
        case "left":
            dragon.img=HEAD_LEFT_IMG;
            dragon.yOffset = -15*SPRITE_SCALE;
            break;
        case "right":
            dragon.img=HEAD_RIGHT_IMG;
            dragon.yOffset = -15*SPRITE_SCALE;
            break;
        case "up":
            dragon.img=HEAD_UP_IMG;
            dragon.yOffset = 0;
            break;
        case "down":
            dragon.img=HEAD_DOWN_IMG;
            dragon.yOffset = -15*SPRITE_SCALE;
            break;
        default:
            dragon.img=HEAD_DOWN_IMG;
            dragon.yOffset = -15*SPRITE_SCALE;
            break;
    }
    renderObject(dragon, gameStage);
    if (game_state == GAME_STATES.PLAYING) {
    	counter += 1;
    	if (counter>MOVE_DELAY) {
    		var oldR = dragon.r;
    		var oldC = dragon.c;
            lastDir = dir;
            dir = nextDir;
    	
    		if (dir=="left") {
    			dragon.c = dragon.c - 1;
    			counter =0;
    		}
    		if (dir=="right") {
    			dragon.c = dragon.c + 1;
    			counter =0;
    		}
    		if (dir=="up") {
    			dragon.r = dragon.r - 1;
    			counter =0;
    		}
    		if (dir=="down") {
    			dragon.r = dragon.r + 1;
    			counter =0;
    		}	
    	
    		maze.isOn(dragon.r, dragon.c)
		    if (game_state != GAME_STATES.PLAYING) { return; }
    
              if (dir!="start") {
                LEVEL_SCORE += EARNED_POINTS[MOVE_DELAY];
                renderScore();
    		}

	        var xy = maze.grid2canvas(oldR,oldC);
	        gameStage.clearRect(xy[0]+dragon.xOffset,xy[1]+dragon.yOffset,
		  xy[0]+dragon.img.width*SPRITE_SCALE,
		  xy[1]+dragon.img.height*SPRITE_SCALE);
                switch(lastDir) {
                    case "start":
                        switch(dir) {
                            case "left":
                                renderObject(maze.addPoint(new Point(TAIL_LEFT_IMG, oldR, oldC, mazeCollision)), bgStage);
                                break;
                            case "right":
                                renderObject(maze.addPoint(new Point(TAIL_RIGHT_IMG, oldR, oldC, mazeCollision)), bgStage);
                                break;
                            case "up":
                                renderObject(maze.addPoint(new Point(TAIL_UP_IMG, oldR, oldC, mazeCollision)), bgStage);
                                break;
                            case "down":
                                renderObject(maze.addPoint(new Point(TAIL_DOWN_IMG, oldR, oldC, mazeCollision)), bgStage);
                                break;
                        }
                        break;

                    case "left":
                        switch(dir) {
                            case "left":
                                renderObject(maze.addPoint(new Point(LEFT_TO_RIGHT_IMG, oldR, oldC, mazeCollision)), bgStage);
                                break;
                            case "up":
                                renderObject(maze.addPoint(new Point(LEFT_TO_UP_IMG, oldR, oldC, mazeCollision)), bgStage);
                                break;
                            case "down":
                                renderObject(maze.addPoint(new Point(LEFT_TO_DOWN_IMG, oldR, oldC, mazeCollision)), bgStage);
                                break;
                        }
                        break;

                    case "right":
                        switch(dir) {
                            case "right":
                                renderObject(maze.addPoint(new Point(RIGHT_TO_LEFT_IMG, oldR, oldC, mazeCollision)), bgStage);
                                break;
                            case "up":
                                renderObject(maze.addPoint(new Point(RIGHT_TO_UP_IMG, oldR, oldC, mazeCollision)), bgStage);
                                break;
                            case "down":
                                renderObject(maze.addPoint(new Point(RIGHT_TO_DOWN_IMG, oldR, oldC, mazeCollision)), bgStage);
                                break;
                        }
                        break;

                    case "up":
                        switch(dir) {
                            case "right":
                                renderObject(maze.addPoint(new Point(UP_TO_RIGHT_IMG, oldR, oldC, mazeCollision)), bgStage);
                                break;
                            case "left":
                                renderObject(maze.addPoint(new Point(UP_TO_LEFT_IMG, oldR, oldC, mazeCollision)), bgStage);
                                break;
                            case "up":
                                renderObject(maze.addPoint(new Point(DOWN_TO_UP_IMG, oldR, oldC, mazeCollision)), bgStage);
                                break;
                        }
                        break;
                     
                    case "down":
                        switch(dir) {
                            case "right":
                                renderObject(maze.addPoint(new Point(DOWN_TO_RIGHT_IMG, oldR, oldC, mazeCollision)), bgStage);
                                break;
                            case "left":
                                renderObject(maze.addPoint(new Point(DOWN_TO_LEFT_IMG, oldR, oldC, mazeCollision)), bgStage);
                                break;
                            case "down":
                                renderObject(maze.addPoint(new Point(UP_TO_DOWN_IMG, oldR, oldC, mazeCollision)), bgStage);
                                break;
                        }
                        break;
                    default:
                         case "right":
                             renderObject(maze.addPoint(new Point(LEFT_TO_RIGHT_IMG, oldR, oldC, mazeCollision)), bgStage);
                             break;
                         case "left":
                             renderObject(maze.addPoint(new Point(RIGHT_TO_LEFT_IMG, oldR, oldC, mazeCollision)), bgStage);
                             break;
                         case "up":
                             renderObject(maze.addPoint(new Point(DOWN_TO_UP_IMG, oldR, oldC, mazeCollision)), bgStage);
                             break;
                         case "down":
                             renderObject(maze.addPoint(new Point(UP_TO_DOWN_IMG, oldR, oldC, mazeCollision)), bgStage);
                             break;
                        
                        break;

                    }
                
                lastDir = dir;
                }

        }
	}

/*
 * updates the current score by adding p points to it
 */
function updateScore(p) {
       SCORE += p;
}

/*
 * prints the new score
 */
function renderScore() {
        $('#total_score').text(TOTAL_SCORE);
        $('#level_score').text(LEVEL_SCORE);
        $('#current_level').text(CURRENT_LEVEL+1);
}

/*************************************/
/* Rendering functions               */
/*************************************/

function renderObject($obj, stage) {
	if ($obj.img == undefined){ return; }
	var xy=maze.grid2canvas($obj.r, $obj.c);
    var x = xy[0]+$obj.xOffset;
    var y = xy[1]+$obj.yOffset;
//    if (ISOMETRIC) {
//	    x=getScreenX(x,y)+$obj.xOffset;
//	    y=getScreenY(x,y)+$obj.yOffset;
//    }
	try {
		stage.drawImage($obj.img,x,y, $obj.img.width*SPRITE_SCALE, $obj.img.height*SPRITE_SCALE);
	} catch($error) {}
}

/* Only used in Isometric mode */
function getScreenX($x,$y) {
	var x=(($x-$y)*COS)+X_ORIGIN;
	//var x=(($x-$y)*COS);
	return x;
}

function getScreenY($x,$y) {
	var y=Y_ORIGIN-(($x+$y)*SIN);
	//var y=(($x+$y)*SIN);
	return y;
}

//Main functions held in respective pages.
