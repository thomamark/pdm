/* Copyright 2013 Mark Thomas (mr.thomas gmail)
*/

/*************************************/
/* Global variables                  */
/*************************************/

var pdm = {};
pdm.state = {};

/* Graphics */
var SPRITE_SCALE = 2;
var BASE_W = 32;
var BASE_H= 16;
var GRID_W = BASE_W*SPRITE_SCALE;
var GRID_H = BASE_H*SPRITE_SCALE;
var OPTIONS_BAR_HEIGHT = 128;
var WALL_PAD=10*SPRITE_SCALE;
var MAX_COLS = Math.floor(900/GRID_W);
var MAX_ROWS = Math.floor(500/GRID_H);
var MAP_ICON_POS = MAX_COLS-2;
var PAUSE_ICON_POS = MAX_COLS;
var DEFAULT_WALL_YOFFSET = -10*SPRITE_SCALE;	//Need to get rid of this hack eventually
var DEFAULT_STARTPT_YOFFSET = -13*SPRITE_SCALE;
var DEFAULT_GOAL_YOFFSET = -GRID_H;
var DEBUG = false;
var PDM_SS_IMG;
var BORDER_IMG; 
var SNAKE_IMG; 
var STAR_IMG; 
var GOAL_IMG; 
var PANDA_IMG;
var PORTAL_IMG;
var HEAD_UP_IMG;
var HEAD_DOWN_IMG;
var HEAD_LEFT_IMG;
var HEAD_RIGHT_IMG;
var TAIL_UP_IMG;
var TAIL_DOWN_IMG;
var TAIL_LEFT_IMG;
var TAIL_RIGHT_IMG;
var DOWN_TO_LEFT_IMG;
var DOWN_TO_RIGHT_IMG;
var DOWN_TO_UP_IMG;
var LEFT_TO_DOWN_IMG;
var LEFT_TO_RIGHT_IMG;
var LEFT_TO_UP_IMG;
var RIGHT_TO_DOWN_IMG;
var RIGHT_TO_LEFT_IMG;
var RIGHT_TO_UP_IMG; 
var TILES_IMG_ARRAY;
var WALL_BLOCK_IMG;
var PILLAR_IMG;
var VERTICAL_WALL_IMG;
var HORIZONTAL_WALL_IMG;
var DELETE_IMG;
var PIX_IMG;
var WALL_9S_TL_IMG;
var WALL_9S_TC_IMG;
var WALL_9S_TR_IMG;
var WALL_9S_ML_IMG;
var WALL_9S_MC_IMG;
var WALL_9S_MCTR_IMG;
var WALL_9S_MCTL_IMG;
var WALL_9S_MCBR_IMG;
var WALL_9S_MCBL_IMG;
var WALL_9S_MR_IMG;
var WALL_9S_BL_IMG;
var WALL_9S_BC_IMG;
var WALL_9S_BR_IMG;
var MAP_IMG;
var COMPLETE_IMG;
var CROWN_IMG;
var MAP_DRAGON_IMG;
var MAP_ICON;
var PAUSE_ICON;
var MAP_HEADER_BG;
var BACK_IMG;

var OPS_HOME_IMG;
var OPS_FX_ON_IMG;
var OPS_FX_OFF_IMG;
var OPS_SOUND_ON_IMG;
var OPS_SOUND_OFF_IMG;
var OPS_SOUND_IMG;
var OPS_FX_IMG;
var OPS_SPEED_FAST_IMG;
var OPS_SPEED_SLOW_IMG;
var OPS_SPEED_IMG;
var optionsX = 100*SPRITE_SCALE;
var optionsW = 257*SPRITE_SCALE;
var optionsH = 100*SPRITE_SCALE;
var OPS_TARGET_W = 120*(SPRITE_SCALE/2);
var OPS_TARGET_H = 105*(SPRITE_SCALE/2);
var opsPad = 5*SPRITE_SCALE;


var MAP_VISIBLE = false;

//Hacky way to get images to JSON.stringify. See removeCyclicalStructures
var IMG_PREFIX = "img";
var IMG_CACHE = {};

var POST_ASSET_LOAD_FN; //hacky way to get images to load in lb

var IMGDIR ="assets"
var AUDIODIR ="assets"
var LOAD_ASSETS = true;
var INIT_GAME = true;


/* Maze encoding variables */
var ENC_W = 2; //num of digits per point in a string
var DEFAULT_BASE = 16; //Default digit base for string output (currently hexadecimal)
var WI = 0;
var SIZEI = 1;

/* Isometric rendering */
var COS=Math.cos(0.46365);
var SIN=Math.sin(0.46365);
//var X_ORIGIN=540;
//var Y_ORIGIN=420;
var X_ORIGIN=240;
var Y_ORIGIN=400;
var ISOMETRIC = false;

/* I/O */
var LEFT_ARROW=37;
var UP_ARROW=38;
var RIGHT_ARROW=39;
var DOWN_ARROW=40;
var ESC=27;
var MOVE_DELAY=10;

/* Game */
pdm.state.map = undefined; // holds the current world.
var LEVELS_INITED = false;
//var pdm.state.currentLevel; //Will be set during init
//var pdm.state.totalScore; //Will be set during init
var LEVEL_SCORE= 0;
var EARNED_POINTS = { "5": 40, "10": 20, "15": 40, "bonus" : 1000};

var GAME_STATES = {
  UNINIT : "uninit",
  READY : "ready?",
  FAILED: "Maze failed!",
  PLAYING: "playing",
  COMPLETE: "Maze complete!",
  PAUSED: "Paused",
  GAME_COMPLETE: "Game complete!"
}

/* Game elements */
var loadFlags = [];
var gameCanvas; // canvas for moving elements
var gameStage;  
var wallCanvas;  // canvas for static background
var wallStage;	// stage for rendering walls
var mapCanvas;  // canvas for dragon body
//var mapStage;	// stage for rendering dragon body
var tileCanvas;  // canvas for static background
var tileStage;  // canvas for static background
var game_state = GAME_STATES.UNINIT;
var PREPAUSE_GAME_STATE;
var request;
var dragon;
var maze; //the current maze
var dir;
var lastDir;
var nextDir;
var counter;
var TYPES = {
	BLANK : 0,
	WALL : 1,
	PANDA : 2,
	GOAL: 3,
	START: 4, 
}

var DIFFICULTIES= {
	EASY: 0,
	NORMAL: 1,
	HARD : 2,
}

var POINTS = {};
POINTS[TYPES.WALL] =  WallPoint;
POINTS[TYPES.PANDA] = PandaPoint;
POINTS[TYPES.GOAL] = GoalPoint;
POINTS[TYPES.START] = StartPoint;

var BLANK = undefined; //Value for ablank space.

/* Audio */
var CHANNEL_MAX = 10;   // number of simultaneous audio channels to allow
var AUDIOCHANNELS = new Array(); // Array of audio elements (initialized below)
var PLAY_FX = true; // whether or not to play sound effects
var PLAY_THEME = true; // whether or not to play sound effects
var AUDIO_SRC= {};  //Caches the playable source strings from the audio elements
var OGG_STR = "audio/ogg";
var THEME;

/*************************************/
/* Game objects                      */
/*************************************/

/*
* Sprites wrap images and allow for things like animations
* and efficient use of sprite sheets.
*/

/*A maze object is a collection of points
 @arg img a an image object to render for this point
 @arg r the row of this object in the maze grid
 @arg c the column of this objection in the maze grid
 @arg isOnFn the function which will be called if the dragon lands on this point
 @arg pointType the type ID for this point
 @arg yoff optional yoffset in pixels
 @arg xoff optiona xoffset in pixels
*/
function Point(img,r, c, isOnFn, pointType, yoff, xoff) {
	this.img=img;
	this.r=r;
	this.c=c;
    this.isOn = isOnFn;
	this.yOffset= (yoff) ? yoff : 0;
	this.xOffset= (xoff) ? xoff : 0;
    this.obj_type=pointType;
}

/*
 * Returns an object with two components
 *   - obj.pt the first point object encoded in the given string or undefined if blank
 *   - obj.n (num_chars_read_from_s)/pad_w
 * Arguments:
 * s a string with the first pad_w digits specifying a point type
 * r the row for this point
 * c the column for this point 
 * base the base in which elements in this string have been encoded
 * pad_w the encoding width in number of digits in base for each point 
 */
function PointFactory (s, r, c, base, pad_w) {
	var base = (base) ? base : DEFAULT_BASE;
	var pad_w = (pad_w) ? pad_w : ENC_W;
	var n = 1;
	var t = parseInt(s.substring(0, pad_w), base);
	var pt = undefined;
	
	switch (t) {
		case TYPES.GOAL:
			// Next encoded digit specifies destination
			var d = parseInt(s.substring(pad_w, 2*pad_w), base);
			n += 1;
			pt = new POINTS[t](r,c,d);
			break;
		case TYPES.BLANK:
			//Blank points should keep the point undefined, so do nothing here.
			break;
		default:
			//Simple version for most points
			pt = new POINTS[t](r,c);
	}
	return {"pt" : pt, "n" : n };
}

/* Encodes the point as a string. See Maze.prototype.toString for more information. */
Point.prototype.toString = function(base, pad_w){
	//Set default vars
	var base = (base) ? base : DEFAULT_BASE;
	var pad_w = (pad_w) ? pad_w : ENC_W;
	switch(this.obj_type) {
		case TYPES.GOAL:
			if (this.destination!=0 && !this.destination) {
				throw "Error: goal point at " + this.r + ", " + this.c + " has no destination!"
				return undefined;
			} else {
				return pad(Number(this.obj_type).toString(base), pad_w) + pad(Number(this.destination).toString(base), pad_w);
			}
			break;
		case undefined:
			console.log("Warning: point at " + this.r + "," + this.c + " has no type! Assuming it is blank.");
			return pad(Number(TYPES.BLANK).toString(base), pad_w);
			break;
		default:
			return pad(Number(this.obj_type).toString(base), pad_w);
	}
}

/* A Wall in the maze */
function WallPoint(r,c)  {
	return new Point(WALL_BLOCK_IMG, r, c, mazeCollision, TYPES.WALL, DEFAULT_WALL_YOFFSET);
}

/* A goal. 
 * dest: an int ID for another maze where this goal will take you.
 */ 
function GoalPoint(r, c, dest)  {
	var pt = new Point(PORTAL_IMG, r, c, mazeComplete(dest), TYPES.GOAL, DEFAULT_GOAL_YOFFSET);
	pt.destination = dest;
	return pt;
}

//A Panda
function PandaPoint(r,c) {
	return new Point(PANDA_IMG, r, c, collectBonus, TYPES.PANDA, -20, 10);
}

//Dragon starting point
function StartPoint(r,c) {
	return new Point(HEAD_DOWN_IMG, r, c, function () {}, TYPES.START, DEFAULT_STARTPT_YOFFSET);
}

//Special point for background tiles. These are used initially to render
//background images only, so there's no need for an isOn function
function TilePoint(r, c) {
   var img = TILES_IMG_ARRAY[Math.floor(Math.random()*TILES_IMG_ARRAY.length)];
   return new Point(img, r, c, null); 
}

/* A maze */
function Maze (s) {
	if (!s) { throw "Maze must be initialized with a valid string"; }
    this.doneBonuses = 0;
    this.gotBonuses = 0;
	this.s = s;
	this.maxPandas = 0;
	this.load(s);
	this.xOffset = 0;
	this.yOffset = -DEFAULT_WALL_YOFFSET;
}

Maze.prototype.reset = function() {
	this.load(this.s);
	//enter the maze from where you exited the last one.
	if (pdm.state.exitr && pdm.state.exitc && pdm.state.exitdir) {
		maze.setEntry(pdm.state.exitr, pdm.state.exitc, pdm.state.exitdir);
	}
}

// Sets the Maze's size in rows (height) and columns (width)
Maze.prototype.setSize = function (r,c) {
	this.rows = r;
	this.cols = c;
}

//Sets the entry row/column for this maze
Maze.prototype.setEntry = function(r,c, dir) {
	var tr, tc;
	switch (r) {
		case MAX_ROWS:
			this.er = 2;
			tr = 1;
			break;
		case 1:
			this.er = MAX_ROWS-1;
			tr = MAX_ROWS;
			break;
		default:
			this.er = tr = r;
			break;
	}
	switch (c) {
		case MAX_COLS:
			this.ec = 2;
			tc = 1;
			break;
		case 1:
			this.ec = MAX_COLS-1;
			tc = MAX_COLS;
			break;
		default:
			this.ec = tc = c;
	}
	//Make sure the tail image for the exit row is correct.
	this.getPoint(tr,tc).img = getTailImg(dir);
}

// Sets the Dragon's starting/drop point
// Note this will be overridden by the entry point unless being dropped.
Maze.prototype.setStart = function(r,c) {
	this.sr = r;
	this.sc = c;
}

Maze.prototype.unsetStart = function() {
	this.sr = undefined;
	this.sc = undefined;	
}

//Given a row and a column, returns an array with x and y pixel coordinates
Maze.prototype.grid2canvas= function (r, c) {
	return {"x" : ((c-1) * GRID_W + this.xOffset),
            "y" : ((r-1) * GRID_H + this.yOffset)
			};
}

Maze.prototype.getCenterX = function () {
	return Math.round(((this.cols)*GRID_W+this.xOffset)/2);
}

Maze.prototype.getCenterY = function () {
	return Math.round(((this.rows)*GRID_H+this.yOffset)/2);
}

Maze.prototype.getEntry = function () {
	return (this.er && this.ec) ? {"r" : this.er, "c" : this.ec} : undefined;
 	//return [this.er, this.ec];
}

Maze.prototype.getStart = function () {
	return (this.sr && this.sc) ? {"r" : this.sr, "c" : this.sc} : undefined;
 	//return (this.sr && this.sc) ? [this.sr, this.sc] : undefined;
}

Maze.prototype.collectBonus = function(){
    this.gotBonuses +=1;
	LEVEL_SCORE += 1;
    //LEVEL_SCORE += EARNED_POINTS['bonus'];
}

Maze.prototype.complete = function () {
   if (this.gotBonuses==this.maxPandas) {
		pdm.state.map.levels[pdm.state.currentLevel].completed = true;
		pdm.state.map.levels[pdm.state.currentLevel].currentMazeStr = this.toString();
	} 
	if (pdm.state.difficulty == DIFFICULTIES.EASY) {
		//Allow saving of partial states if not on hard.
		pdm.state.map.levels[pdm.state.currentLevel].currentMazeStr = this.toString();
	}
	setHeadImg(maze.getPoint(dragon.r, dragon.c), dir);
	pdm.state.exitr = dragon.r;
	pdm.state.exitc = dragon.c;
	pdm.state.exitdir = dir;
}

Maze.prototype.addBorders = function () {
	for (var i =1; i<=this.rows; i++) {
		if (!this.hasPoint(i,1)) {
			this.addPoint(new WallPoint(i,1));
		}
		if (!this.hasPoint(i,this.cols)) {
			this.addPoint(new WallPoint(i,this.cols));
		}
		for (var j=1; j<=this.cols; j++){
			if (!this.hasPoint(1, j)) {
				this.addPoint(new WallPoint(1,j));				
			}
			if (!this.hasPoint(this.rows,j)){
				this.addPoint(new WallPoint(this.rows,j));
			}
		}
	}
	
	this.fixWallImages();
}

/* Deletes all objects on the borders of the maze */
Maze.prototype.removeBorders = function () {
	for (var i =1; i<=this.rows; i++) {
			this.removePoint(i,1);
			this.removePoint(i,this.cols);
		for (var j=1; j<=this.cols; j++){
				this.removePoint(1,j);				
				this.removePoint(this.rows,j);
		}
	}
}

//Fn for extending the length of a hex string to <width> chars
function pad(hexstr, width) {
	var p = width - hexstr.length;
	if (p >0) { return Array(p+1).join("0")+hexstr; }
	else if (p<0) { throw "Too long to encode into a Maze string "+hexstr;}
	else { return hexstr; }
};

/* Returns a string representation of this maze
*  Maze string representation:
*  1 hex digit for number of hex digits per square (N)
*  N hex digits for num rows (R)
*  N hex digits for num cols (C)
*  N hex digits for each of the RxC squares in the maze
*/
Maze.prototype.toString = function () {
	var s = "" + Number(ENC_W).toString(DEFAULT_BASE) + 
					pad(Number(this.rows).toString(DEFAULT_BASE), ENC_W) +
					pad(Number(this.cols).toString(DEFAULT_BASE),ENC_W);
	try {
		for (var i = 0; i< this.rows; i++) {
			for ( var j = 0; j<this.cols; j++) {

				if (i+1 == this.sr && j+1 == this.sc) {
					s+=new StartPoint(i+1, j+1).toString();
				} else {
						s+= (this.points[i][j]) ? this.points[i][j].toString(DEFAULT_BASE, ENC_W) : pad( Number(TYPES.BLANK).toString(DEFAULT_BASE), ENC_W);
				}
			}
		}
	} catch (err){
		console.log("Error at row " + (i+1) + " and column " + (j+1) + 
			"\n"+ err.message);
		return null;
	}
	return s;
}

/* Constructs a maze given a string rep of a maze (see toString above) */
Maze.prototype.load = function(s) {
	try {
		var base = 16; //TODO: need to read this from the string.
		var w      = parseInt(s.charAt(WI), base);
		var rows   = parseInt(s.substring(SIZEI,SIZEI+w), base);
		var cols   = parseInt(s.substring(SIZEI+w, SIZEI+2*w), base); 
		var head_len  = SIZEI+2*w;
		//FIXME: not as easy to verify length of string when points contain extra info (e.g. goal points)
		// if (s.length != head_len + rows*cols*w) {
		// 	throw "Invalid maze string length. Expected: "+(head_len+rows*cols*w) + " Actual: " + s.length;
		// }
		this.setSize(rows, cols);
		this.initPoints();
		this.maxPandas = 0;
		var r = 1;
		var c = 1;
		for (var i = head_len; i < s.length; i+=w) {
			var pt_n    = PointFactory(s.substring(i, s.length), r, c, base, w);
			i += (pt_n.n - 1) * w;	//If we read more than one encoded char, advance the incr accordingly
			if (pt_n.pt) { 
				this.addPoint(pt_n.pt); 
			}		
			//Keep track of which row/column we're on. Note that maze is loaded in columns-first order.
			c += 1;
			if (c > this.cols) {
				c = 1;
				r += 1;
			}
		}
		if (!(this.getStart())) {
			throw "Maze has no starting point defined!";
		}
	} catch (err) {
		throw "Error loading maze: " + err;
	}
	this.fixWallImages();
}

/* initializes the points array for this Maze */
Maze.prototype.initPoints = function() {
	if (!(this.rows && this.cols)) {
		throw "Rows and columns are undefined. Cannot initialize points.";
	}
	this.points = [];
	this.gotBonuses = 0;
	for (var i=0; i<this.rows; i++){
		this.points[i]=[];
		this.points[i][this.cols-1]=BLANK;
 	}
}

Maze.prototype.fixWallImages = function() {
    for (var i = 0; i<this.rows; i++) {
        for (var j= 0; j<this.cols;j++) {
           //We only care about walls, so skip everything else
//            try {
//           		if (!this.points[i][j] || !this.isType(i,j,TYPES.WALL) ||
//									!this.isType(i,j,TYPES.GOAL)) {
//           		     continue;
//           		 }
//            } catch(err) {
//                console.log("Error fixing wall images! i="+i+" j="+j);
//            }


			if (this.isType(i,j,TYPES.GOAL) && 
						(i == 0 || i == this.rows-1 || j == 0 || j == this.cols-1)) {
						this.points[i][j].img = (DEBUG) ? PIX_IMG : undefined;
	          			this.points[i][j].yOffset=0;
			} else if (this.isType(i,j,TYPES.WALL)) {
					//TODO: fixme! Reset wall offset
					this.points[i][j].yOffset=DEFAULT_WALL_YOFFSET;
					//Build 9-slice
					if (this.isType(i-1,j-1,TYPES.WALL) &&
							this.isType(i-1,j,TYPES.WALL) &&
							this.isType(i-1,j+1,TYPES.WALL) &&
							this.isType(i,j-1,TYPES.WALL) &&
							this.isType(i,j,TYPES.WALL) &&
							this.isType(i,j+1,TYPES.WALL) &&
							this.isType(i+1,j-1,TYPES.WALL) &&
							this.isType(i+1,j,TYPES.WALL) &&
							this.isType(i+1,j+1,TYPES.WALL)) {
								//Middle-center wall
								this.points[i][j].img=WALL_9S_MC_IMG;
				           //   this.points[i][j].yOffset=0;
							} else if (
								this.isType(i-1,j-1,TYPES.WALL) &&
								this.isType(i-1,j,TYPES.WALL) &&
								this.isType(i-1,j+1,TYPES.WALL) &&
								this.isType(i,j-1,TYPES.WALL) &&
								this.isType(i,j,TYPES.WALL) &&
								this.isType(i,j+1,TYPES.WALL) &&
								!(this.isType(i+1,j-1,TYPES.WALL) &&
									this.isType(i+1,j,TYPES.WALL)) &&
								!(this.isType(i+1,j+1,TYPES.WALL) && 
									this.isType(i+1,j,TYPES.WALL))) {
									//Bottom-center wall
									this.points[i][j].img=WALL_9S_BC_IMG;
	            	  				//this.points[i][j].yOffset=0;
							} else if (
								!(this.isType(i-1,j-1,TYPES.WALL) &&
									this.isType(i-1,j,TYPES.WALL)) &&
								!(this.isType(i-1,j+1,TYPES.WALL) &&
									this.isType(i-1,j,TYPES.WALL)) &&
								this.isType(i,j-1,TYPES.WALL) &&
								this.isType(i,j,TYPES.WALL) &&
								this.isType(i,j+1,TYPES.WALL) &&
								this.isType(i+1,j-1,TYPES.WALL) &&
								this.isType(i+1,j,TYPES.WALL) &&
								this.isType(i+1,j+1,TYPES.WALL)) {
									//top-center wall
									this.points[i][j].img=WALL_9S_TC_IMG;
	            	  				//this.points[i][j].yOffset=0;
							} else if (
								!(this.isType(i-1,j-1,TYPES.WALL) &&
									this.isType(i,j-1,TYPES.WALL)) &&
								this.isType(i-1,j,TYPES.WALL) &&
								this.isType(i-1,j+1,TYPES.WALL) &&
								this.isType(i,j,TYPES.WALL) &&
								this.isType(i,j+1,TYPES.WALL) &&
								!(this.isType(i+1,j-1,TYPES.WALL) &&
									this.isType(i,j-1,TYPES.WALL)) &&
								this.isType(i+1,j,TYPES.WALL) &&
								this.isType(i+1,j+1,TYPES.WALL)) {
									//middle-left wall
									this.points[i][j].img=WALL_9S_ML_IMG;
	            	  				//this.points[i][j].yOffset=0;
							} else if (
								this.isType(i-1,j,TYPES.WALL) &&
								this.isType(i-1,j+1,TYPES.WALL) &&
								!(this.isType(i-1,j-1,TYPES.WALL) &&
								  this.isType(i,j-1,TYPES.WALL)) &&
								this.isType(i,j,TYPES.WALL) &&
								this.isType(i,j+1,TYPES.WALL) &&
								!(this.isType(i+1,j,TYPES.WALL) &&
								  this.isType(i+1,j+1,TYPES.WALL))) {
									//bottom-left wall
									this.points[i][j].img=WALL_9S_BL_IMG;
	            	  				//this.points[i][j].yOffset=0;
							} else if (
								!(this.isType(i-1,j,TYPES.WALL) &&
									this.isType(i-1,j+1,TYPES.WALL)) &&
								!(this.isType(i,j-1,TYPES.WALL) &&
									this.isType(i+1,j-1,TYPES.WALL)) &&
								this.isType(i,j,TYPES.WALL) &&
								this.isType(i,j+1,TYPES.WALL) &&
								this.isType(i+1,j,TYPES.WALL) &&
								this.isType(i+1,j+1,TYPES.WALL)) {
									//top-left wall
									this.points[i][j].img=WALL_9S_TL_IMG;
	            	  				//this.points[i][j].yOffset=0;
							} else if (
								this.isType(i-1,j-1,TYPES.WALL) &&
								this.isType(i-1,j,TYPES.WALL) &&
								!(this.isType(i-1,j+1,TYPES.WALL) &&
									this.isType(i,j+1,TYPES.WALL)) &&
								this.isType(i,j-1,TYPES.WALL) &&
								this.isType(i,j,TYPES.WALL) &&
								this.isType(i+1,j-1,TYPES.WALL) &&
								this.isType(i+1,j,TYPES.WALL) &&
								!(this.isType(i,j+1,TYPES.WALL) &&
								this.isType(i+1,j+1,TYPES.WALL))) {
									//middle-right wall
									this.points[i][j].img=WALL_9S_MR_IMG;
	            	  				//this.points[i][j].yOffset=0;
							} else if (
								this.isType(i-1,j-1,TYPES.WALL) &&
								this.isType(i-1,j,TYPES.WALL) &&
								!(this.isType(i-1,j+1,TYPES.WALL) &&
									this.isType(i,j+1,TYPES.WALL)) &&
								this.isType(i,j-1,TYPES.WALL) &&
								this.isType(i,j,TYPES.WALL) &&
								!(this.isType(i+1,j-1,TYPES.WALL) &&
									this.isType(i+1,j,TYPES.WALL))) {
									//bottom-right wall
									this.points[i][j].img=WALL_9S_BR_IMG;
	            	  				//this.points[i][j].yOffset=0;
							} else if (
								!(this.isType(i-1,j-1,TYPES.WALL) &&
									this.isType(i-1,j,TYPES.WALL)) &&
								this.isType(i,j-1,TYPES.WALL) &&
								this.isType(i,j,TYPES.WALL) &&
								!(this.isType(i,j+1,TYPES.WALL) &&
									this.isType(i+1,j+1,TYPES.WALL)) &&
								this.isType(i+1,j-1,TYPES.WALL) &&
								this.isType(i+1,j,TYPES.WALL)) {
									//top-right wall
									this.points[i][j].img=WALL_9S_TR_IMG;
	            	  				//this.points[i][j].yOffset=0;
							} else if (this.isType(i-1,j-1,TYPES.WALL) &&
                this.isType(i-1,j,TYPES.WALL) &&
                this.isType(i-1,j+1,TYPES.WALL) &&
                this.isType(i,j-1,TYPES.WALL) &&
                this.isType(i,j,TYPES.WALL) &&
                this.isType(i,j+1,TYPES.WALL) &&
                this.isType(i+1,j-1,TYPES.WALL) &&
                this.isType(i+1,j,TYPES.WALL) &&
                !this.isType(i+1,j+1,TYPES.WALL)) {
                    //9-slice with bottom-right missing
                    this.points[i][j].img = WALL_9S_MCBR_IMG;
                    //this.points[i][j].yOffset=0;
              } else if (this.isType(i-1,j-1,TYPES.WALL) &&
                this.isType(i-1,j,TYPES.WALL) &&
                this.isType(i-1,j+1,TYPES.WALL) &&
                this.isType(i,j-1,TYPES.WALL) &&
                this.isType(i,j,TYPES.WALL) &&
                this.isType(i,j+1,TYPES.WALL) &&
                !this.isType(i+1,j-1,TYPES.WALL) &&
                this.isType(i+1,j,TYPES.WALL) &&
                this.isType(i+1,j+1,TYPES.WALL)) {
                    //9-slice with bottom-left missing
                    this.points[i][j].img = WALL_9S_MCBL_IMG;
                    //this.points[i][j].yOffset=0;
              } else if (this.isType(i-1,j-1,TYPES.WALL) &&
                this.isType(i-1,j,TYPES.WALL) &&
                !this.isType(i-1,j+1,TYPES.WALL) &&
                this.isType(i,j-1,TYPES.WALL) &&
                this.isType(i,j,TYPES.WALL) &&
                this.isType(i,j+1,TYPES.WALL) &&
                this.isType(i+1,j-1,TYPES.WALL) &&
                this.isType(i+1,j,TYPES.WALL) &&
                this.isType(i+1,j+1,TYPES.WALL)) {
                    //9-slice with top-right missing
                    this.points[i][j].img = WALL_9S_MCTR_IMG;
                    //this.points[i][j].yOffset=0;
              } else if (
                !this.isType(i-1,j-1,TYPES.WALL) &&
                this.isType(i-1,j,TYPES.WALL) &&
                this.isType(i-1,j+1,TYPES.WALL) &&
                this.isType(i,j-1,TYPES.WALL) &&
                this.isType(i,j,TYPES.WALL) &&
                this.isType(i,j+1,TYPES.WALL) &&
                this.isType(i+1,j-1,TYPES.WALL) &&
                this.isType(i+1,j,TYPES.WALL) &&
                this.isType(i+1,j+1,TYPES.WALL)) {
                    //9-slice with top-left missing
                    this.points[i][j].img = WALL_9S_MCTL_IMG;
                    //this.points[i][j].yOffset=0;
              } else if (this.isType(i,j-1,TYPES.WALL) &&
								this.isType(i, j+1, TYPES.WALL) &&
								(this.isType(i+1, j, TYPES.WALL) ||
									this.isType(i-1, j, TYPES.WALL))) {
											//Fix T-shaped and inverse T-shaped walls
											this.points[i][j].img=WALL_BLOCK_IMG;
	                						//this.points[i][j].yOffset=0;
							 } else if (this.isType(i-1,j,TYPES.WALL) && 
											this.isType(i+1,j,TYPES.WALL) &&
											(this.isType(i,j-1,TYPES.WALL) ||
													this.isType(i,j+1,TYPES.WALL))) {
													//Fix -| and |- walls
													this.points[i][j].img = WALL_BLOCK_IMG;
                      								//this.points[i][j].yOffset=0;
							} else if (this.isType(i-1,j,TYPES.WALL) &&
							  this.isType(i+1,j,TYPES.WALL) &&
							  !this.isType(i, j-1, TYPES.WALL) &&
								!this.isType(i,j+1, TYPES.WALL)) {
                    				//Fix vertical wall image
				                    this.points[i][j].img=VERTICAL_WALL_IMG;
                      				//this.points[i][j].xOffset=16;
           	  } else if (this.isType(i,j-1,TYPES.WALL) &&
								this.isType(i, j+1, TYPES.WALL) &&
								!this.isType(i-1,j, TYPES.WALL) &&
								!this.isType(i+1,j, TYPES.WALL)) {
                    //Fix horizontal wall image
                    this.points[i][j].img=HORIZONTAL_WALL_IMG;
                    this.points[i][j].yOffset=-10;
              } else {
						//default to the pillar wall
						this.points[i][j].img = WALL_BLOCK_IMG; 
						//this.points[i][j].yOffset=-20;
        		}
		}
    }
  } 
}

/**
* Given a row, column and and object type, returns true if the point at
* at this.points[i][j] has obj_type==type
* Note that maze rows and columns are not 0-indexed (first row/col is 1,1).
*/
Maze.prototype.isType = function (i,j,type) {
	return (i>=0 && i<this.rows && j>=0 && j<this.cols &&
					this.points[i][j]!=undefined &&
					this.points[i][j].obj_type==type);
}

// Adds a point object to this Maze
Maze.prototype.addPoint = function(pt) {
	// Ensure you can only add points within the maze
	if (pt.r >0 && pt.r <= this.rows && pt.c > 0 && pt.c <= this.cols) {
		switch(pt.obj_type) {
			case TYPES.START:
				//We don't add start points to the maze
				this.setStart(pt.r, pt.c);
				break;
			case TYPES.PANDA:
				this.maxPandas += 1;
			default:
				this.points[pt.r-1][pt.c-1] = pt;			
		}
    	return pt;
	}
}

/* Removes a point object from this Maze */
Maze.prototype.removePoint = function(r, c) {
	if (r >0 && r <= this.rows && c > 0 && c <= this.cols) {
		var pt = this.points[r-1][c-1];
		switch(pt.obj_type) {
			case TYPES.START:
				//If you're removing a start, unset the start position
				this.unsetStart();
				break;
			default:
				this.points[r-1][c-1]=BLANK;			
		}
		return pt;
	}
}

/*
* Returns a point at r, c in the maze or undefined if none exists
*/
Maze.prototype.hasPoint = function(r, c) {
	return this.points[r-1][c-1];
}

Maze.prototype.getPoint = function(r,c) {
	if (r<=this.rows && r > 0 && c <= this.cols && c > 0) {
		return this.points[r-1][c-1];
	}
}

Maze.prototype.isOn = function (r, c) {
        var pt = this.getPoint(r,c);
        if (pt && pt.isOn) {
                pt.isOn();
        }
}

Maze.prototype.renderTiles = function (stage) {
	for (var i =0; i<this.rows; i++) {
		for (var j =0; j<this.cols; j++) {
            renderMazeObject(new TilePoint(i+1, j+1), stage);
		}
	}
}

Maze.prototype.render = function (stage) {
	for (var i =0; i<this.rows; i++) {
		for (var j =0; j<this.cols; j++) {
            //render the background tiles the first time we render the maze.
            // if (game_state != GAME_STATES.FAILED) {
            //      renderMazeObject(new TilePoint(i+1, j+1),tileStage);
            //  }
 			if (this.points[i][j]) {
				renderMazeObject(this.points[i][j], stage);
			}
		}
	}
}


Maze.prototype.addDragonBody = function(dir, lastDir, oldR, oldC) {
            switch(lastDir) {
                    case "start":
                        maze.addPoint(new Point(getTailImg(dir),
                            oldR, oldC, mazeCollision));
                        break;
                    case "left":
                        switch(dir) {
                            case "left":
                                maze.addPoint(new Point(LEFT_TO_RIGHT_IMG, oldR, oldC, mazeCollision));
                                break;
                            case "up":
                                maze.addPoint(new Point(LEFT_TO_UP_IMG, oldR, oldC, mazeCollision));
                                break;
                            case "down":
                                maze.addPoint(new Point(LEFT_TO_DOWN_IMG, oldR, oldC, mazeCollision));
                                break;
                        }
                        break;

                    case "right":
                        switch(dir) {
                            case "right":
                                maze.addPoint(new Point(RIGHT_TO_LEFT_IMG, oldR, oldC, mazeCollision));
                                break;
                            case "up":
                                maze.addPoint(new Point(RIGHT_TO_UP_IMG, oldR, oldC, mazeCollision));
                                break;
                            case "down":
                                maze.addPoint(new Point(RIGHT_TO_DOWN_IMG, oldR, oldC, mazeCollision));
                                break;
                        }
                        break;

                    case "up":
                        switch(dir) {
                            case "right":
                                maze.addPoint(new Point(UP_TO_RIGHT_IMG, oldR, oldC, mazeCollision));
                                break;
                            case "left":
                                maze.addPoint(new Point(UP_TO_LEFT_IMG, oldR, oldC, mazeCollision));
                                break;
                            case "up":
                                maze.addPoint(new Point(DOWN_TO_UP_IMG, oldR, oldC, mazeCollision));
                                break;
                        }
                        break;

                    case "down":
                        switch(dir) {
                            case "right":
                                maze.addPoint(new Point(DOWN_TO_RIGHT_IMG, oldR, oldC, mazeCollision));
                                break;
                            case "left":
                                maze.addPoint(new Point(DOWN_TO_LEFT_IMG, oldR, oldC, mazeCollision));
                                break;
                            case "down":
                                maze.addPoint(new Point(UP_TO_DOWN_IMG, oldR, oldC, mazeCollision));
                                break;
                        }
                        break;
                    default:
                        switch(dir) {
                            case "right":
                                 maze.addPoint(new Point(LEFT_TO_RIGHT_IMG, oldR, oldC, mazeCollision));
                                 break;
                             case "left":
                                 maze.addPoint(new Point(RIGHT_TO_LEFT_IMG, oldR, oldC, mazeCollision));
                                 break;
                             case "up":
                                 maze.addPoint(new Point(DOWN_TO_UP_IMG, oldR, oldC, mazeCollision));
                                 break;
                             case "down":
                                 maze.addPoint(new Point(UP_TO_DOWN_IMG, oldR, oldC, mazeCollision));
                                 break;
                        }
                }
}

/*************************************/
/* Maze events                       */
/*************************************/

function cleanUp() {
    printState();
    stopGameLoop();
}

function mazeCollision() {
    game_state = GAME_STATES.FAILED;
    stopMusic();
    playMultiSound('defeat');
    LEVEL_SCORE = 0;
    cleanUp();
}

function mazeComplete(dest) {
	return function () {
 	    game_state = GAME_STATES.COMPLETE;
	    stopMusic();
	    playMultiSound('victory');
	    maze.complete();
	    pdm.state.totalScore += LEVEL_SCORE;
	    LEVEL_SCORE = 0;
	    pdm.state.currentLevel = dest;
	    saveGameState();
		renderScreen();
	    cleanUp();
	}
}

function collectBonus() {
    maze.collectBonus();
    playMultiSound('pick_up');
}

function gameComplete() {
    game_state = GAME_STATES.GAME_COMPLETE;
    pdm.state.currentLevel=0;
    // for (var i=0; i<pdm.state.map.levels.length;i++) {
    //     pdm.state.map.levels[i].initPoints();
    // }
    cleanUp();
}


// Sets the Dragon's head image based on direction
function setHeadImg(dragon, dir) {
 switch(dir) {
        case "left":
            dragon.img=HEAD_LEFT_IMG;
            dragon.yOffset = -15*SPRITE_SCALE;
            break;
        case "right":
            dragon.img=HEAD_RIGHT_IMG;
            dragon.yOffset = -15*SPRITE_SCALE;
            break;
        case "up":
            dragon.img=HEAD_UP_IMG;
            dragon.yOffset = -5*SPRITE_SCALE;
            break;
        case "down":
            dragon.img=HEAD_DOWN_IMG;
            dragon.yOffset = -15*SPRITE_SCALE;
            break;
		case "start":
			//leave it be
			break;
        default:
            dragon.img=HEAD_DOWN_IMG;
            dragon.yOffset = -15*SPRITE_SCALE;
            break;
    }
}


/*************************************/
/* Map 						         */
/*************************************/

//Creates levels given serialized JSON object. Used in revivePdm to recreate psuedoObjects
function MapFactory(o) {
	return new Map(o.img, o.rows, o.cols, o.gridH, o.gridW, o.levels, o.completeImg);
}


/* Defines a world map.
* All maps at present must be uniform size (900x500px). 
* They must also reserve the top 128 px for the items toolbar.
*/
function Map (img, rows, cols, gridH, gridW, levels, completeImg) {
	this.img = img;
	this.rows = rows;
	this.cols = cols;
	this.levels = levels;
	this.completeImg = completeImg;
	this.gridH = gridH;
	this.gridW = gridW;
	this.factory="MapFactory";
}

/*************************************/
/* Level   					         */
/*************************************/

//Creates levels given serialized JSON object. Used in revivePdm to recreate psuedoObjects
function LevelFactory(o) {
	return new Level(o.originalMazeStr, o.specialMapImg, o.currentMazeStr, o.completed, o.visited);	
}


/* 
* A Level. Levels are part of a particular map. They hold some state
* factory is the string name of a function which can create this object from JSON data.
*
*/
function Level (originalMazeStr, specialMapImg, currentMazeStr, completed, visited) {
	this.specialImg = (specialMapImg) ? specialMapImg : undefined;
	this.originalMazeStr = originalMazeStr;
	this.currentMazeStr = (currentMazeStr) ? currentMazeStr : originalMazeStr;
	this.completed = completed;
	this.visited = visited;
	this.factory ="LevelFactory";
}


/*************************************/
/* Utility functions                 */
/*************************************/


function replaceCyclicStructures(key, val) {
	//Modified version from http://hagsdev.blogspot.com/2012/06/cyclic-objects-and-jsonstringify.html
	if(typeof val=="object"){
	    var ot=Object.prototype.toString.call(val);
	    if(ot.search("object Object")>-1){
	      return val;
	    }else if(ot.search("HTMLImageElement")>-1){
	      return val.pdmId;
	    }
		//else if(ot.search("HTMLAudioElement")>-1){
	    //  return getAudioPath(val.src);
	    //}else{
	    //  //if(key!==""){
	    //  //  console.log(ot);
	    //  //  console.log(typeof(val)+" : "+key+" : "+val);
	    //  //}
	    //}
	  }
	  return val;
}


function revivePdm(key, val) {
	var factory;
	if (typeof val === "string" && val.substr(0,3) === "img") {
			return IMG_CACHE[val];
	} else if (val && typeof val === 'object') {
        factory = val.factory;
        if (typeof factory === 'string' && typeof window[factory] === 'function') {
            return (window[factory])(val);
        }
    }
	return val;
}


function findPos(obj) {
    var curleft = 0, curtop = 0;
    if (obj.offsetParent) {
        do {
            curleft += obj.offsetLeft;
            curtop += obj.offsetTop;
        } while (obj = obj.offsetParent);
        return { x: curleft, y: curtop };
    }
    return undefined;
}

/*************************************/
/* Initialization functions          */
/*************************************/

function init(fn) { 
    POST_ASSET_LOAD_FN = (fn) ? fn : postAssetLoad;

    //Short-circuit if we don't want to load assets.
    if (!LOAD_ASSETS) { return;}
    loadAssets(); 


}

// Returns true if you can save games
pdm.canSave = function() {
	return typeof Storage !==undefined;
}

// Saves game
function saveGameState() {
	if (pdm.canSave()) {
		deleteSavedGame();
		localStorage.state = JSON.stringify(pdm.state, replaceCyclicStructures);
	} else {
		console.log("Whoops! Web storage not available. That means we can't save your game, so you'll have to beat it in one go like a boss. Go get 'em tiger.");
	}
//	try {
//		var s = JSON.stringify(pdm.state, replaceCyclicStructures);
//		$.cookie("state", s);
//	} catch (e) {
//			console.log(e.message);
//	}
}

pdm.hasSavedGame = function (){
	return pdm.canSave() && localStorage.state !== undefined;
	//return $.cookie("state");
}

//Initializes the game state and returns true if using saved game
function initGameState() {
	if (pdm.hasSavedGame()) {
			//pdm.state = JSON.parse($.cookie("state"), revivePdm);
			pdm.state = JSON.parse(localStorage.state, revivePdm);
			return true;
	} else {
		pdm.state.currentLevel = 0;
		pdm.state.totalScore =0;
		pdm.state.difficulty = DIFFICULTIES.NORMAL;
		return false;
	}
}

function loadAssets() {
//	    PANDA_IMG = createImgAsset("panda",
//            "<%= asset_path('Panda.png') %>");
//	    PORTAL_IMG = createImgAsset("portal",
//            "<%= asset_path('Goal_1.png') %>");
//	    HEAD_UP_IMG = createImgAsset("head_up",
//            "<%= asset_path('Head_Up.png') %>");
//	    HEAD_DOWN_IMG = createImgAsset("head_down",
//            "<%= asset_path('Head_Down.png') %>");
//	    HEAD_LEFT_IMG = createImgAsset("head_left",
//            "<%= asset_path('Head_Left.png') %>");
//	    HEAD_RIGHT_IMG = createImgAsset("head_right",
//            "<%= asset_path('Head_Right.png') %>");
//	    TAIL_UP_IMG = createImgAsset("tail_up",
//            "<%= asset_path('Tail_Up.png') %>");
//	    TAIL_DOWN_IMG = createImgAsset("tail_down",
//            "<%= asset_path('Tail_Down.png') %>");
//	    TAIL_LEFT_IMG = createImgAsset("tail_left",
//            "<%= asset_path('Tail_Right.png') %>");
//	    TAIL_RIGHT_IMG = createImgAsset("tail_right",
//            "<%= asset_path('Tail_Left.png') %>");
//        DOWN_TO_LEFT_IMG = createImgAsset("dtl",
//            "<%= asset_path('Body_UpToLeft.png') %>");
//        DOWN_TO_RIGHT_IMG = createImgAsset("dtr",
//            "<%= asset_path('Body_UpToRight.png') %>");
//        DOWN_TO_UP_IMG = createImgAsset("dtu",
//            "<%= asset_path('Body_DownToUp.png') %>");
//        LEFT_TO_DOWN_IMG= createImgAsset("ltd",
//            "<%= asset_path('Body_RightToDown.png') %>");
//        LEFT_TO_RIGHT_IMG= createImgAsset("ltr",
//            "<%= asset_path('Body_RightToLeft.png') %>");
//        LEFT_TO_UP_IMG= createImgAsset("ltu",
//            "<%= asset_path('Body_RightToUp.png') %>");
//        RIGHT_TO_DOWN_IMG= createImgAsset("rtd",
//            "<%= asset_path('Body_LeftToDown.png') %>");
//        RIGHT_TO_LEFT_IMG= createImgAsset("rtl",
//            "<%= asset_path('Body_LeftToRight.png') %>");
//        RIGHT_TO_UP_IMG= createImgAsset("rtu",
//            "<%= asset_path('Body_UpToLeft.png') %>");
//        UP_TO_DOWN_IMG= createImgAsset("utd",
//            "<%= asset_path('Body_UpToDown.png') %>");
//        UP_TO_LEFT_IMG= createImgAsset("utl",
//            "<%= asset_path('Body_DownToLeft.png') %>");
//        UP_TO_RIGHT_IMG= createImgAsset("utr",
//            "<%= asset_path('Body_DownToRight.png') %>");
//
//        TILES_IMG_ARRAY= [];
//        TILES_IMG_ARRAY.push(createImgAsset("tile_1",
//              "<%= asset_path('tiles.png') %>"));
//        TILES_IMG_ARRAY.push(createImgAsset("tile_2",
//              "<%= asset_path('tiles_2.png') %>"));
//        TILES_IMG_ARRAY.push(createImgAsset("tile_3",
//              "<%= asset_path('tiles_3.png') %>"));
//        TILES_IMG_ARRAY.push(createImgAsset("tile_4",
//              "<%= asset_path('tiles_4.png') %>"));
//
//				//load wall images
//        VERTICAL_WALL_IMG = createImgAsset("vw",
//            "<%= asset_path('wall_stright_horizontal.png') %>");
//        HORIZONTAL_WALL_IMG = createImgAsset("hw",
//            "<%= asset_path('wall_stright_vertical.png') %>");
//	    WALL_BLOCK_IMG = createImgAsset("pillar",
//          "<%= asset_path('wall_block.png') %>");
//
//		WALL_9S_TL_IMG = createImgAsset('wall_9s_tl', 
//          "<%= asset_path('wall_9slice_tl.png') %>");
//		WALL_9S_TC_IMG = createImgAsset('wall_9s_tc', 
//		    "<%= asset_path('wall_9slice_tc.png') %>");
//		WALL_9S_TR_IMG= createImgAsset('wall_9s_tr', 
//		    "<%= asset_path('wall_9slice_tr.png') %>");
//		WALL_9S_ML_IMG= createImgAsset('wall_9s_ml', 
//		    "<%= asset_path('wall_9slice_ml.png') %>");
//		WALL_9S_MC_IMG = createImgAsset('wall_9s_mc', 
//		    "<%= asset_path('wall_9slice_mc.png') %>");
//		WALL_9S_MR_IMG= createImgAsset('wall_9s_mr', 
//		    "<%= asset_path('wall_9slice_mr.png') %>");
//		WALL_9S_BL_IMG= createImgAsset('wall_9s_bl', 
//		    "<%= asset_path('wall_9slice_bl.png') %>");
//		WALL_9S_BC_IMG= createImgAsset('wall_9s_bc', 
//		    "<%= asset_path('wall_9slice_bc.png') %>");
//		WALL_9S_BR_IMG= createImgAsset('wall_9s_br', 
//          "<%= asset_path('wall_9slice_br.png') %>");
//		COMPLETE_IMG = createImgAsset('complete_img', "<%= asset_path('map_complete_128x128.png') %>");
//		CROWN_IMG = createImgAsset('crown_img', "<%= asset_path('map_crown_128x128.png') %>");
//		MAP_DRAGON_IMG = createImgAsset('map_dragon_img', "<%= asset_path('map_dragon_128x128.png') %>");
//		MAP_ICON = createImgAsset('map_icon_img', "<%= asset_path('mapIcon.png') %>");
//		PAUSE_ICON = createImgAsset('pause_icon_img', "<%= asset_path('pauseIcon.png') %>");
//		BACK_IMG = createImgAsset('back_img', "<%= asset_path('backIcon.png') %>");
//		// Options panel images
//		OPS_HOME_IMG = createImgAsset('ops_home', "<%= asset_path('options_home_white.png') %>");
//		OPS_FX_ON_IMG = createImgAsset('ops_fx_on', "<%= asset_path('options_fx_on_white.png') %>");
//		OPS_FX_OFF_IMG = createImgAsset('ops_fx_off', "<%= asset_path('options_fx_off_white.png') %>")
//		OPS_SOUND_ON_IMG = createImgAsset('ops_sound_on', "<%= asset_path('options_sound_on_white.png') %>")
//		OPS_SOUND_OFF_IMG = createImgAsset('ops_sound_off', "<%= asset_path('options_sound_off_white.png') %>")
//		OPS_SPEED_FAST_IMG = createImgAsset('ops_speed_fast', "<%= asset_path('options_speed_fast_white.png') %>")
//		OPS_SPEED_SLOW_IMG = createImgAsset('ops_speed_slow', "<%= asset_path('options_speed_slow_white.png') %>")

		//Sprite sheets
		PDM_SS_IMG = createImgAsset('pdm_static_ss', "<%= asset_path('pdm_dragon_panda.png') %>");
		WALL_TILES_SS_IMG = createImgAsset('wall_tiles_ss', "<%= asset_path('pdm_walls_tiles.png') %>");
		OPTIONS_SS_IMG = createImgAsset('options_map_ss', "<%= asset_path('pdm_options_map.png') %>");
		GOAL_SS_IMG = createImgAsset('Goal_all', "<%= asset_path('Goal_all.png') %>");

		/* one-off images (not in sprite sheet) */
		MAP_IMG = createImgAsset('map', "<%= asset_path('map.png') %>");
		MAP_HEADER_BG = createImgAsset('map_header_bg', "<%= asset_path('optionsHeaderBg.png') %>");

		//Only used in level builder
      	DELETE_IMG = createImgAsset("delete", 
            "<%= asset_path('delete.png') %>");
		PIX_IMG = createImgAsset('pix_1x1', "<%= asset_path('1x1.gif') %>");
}

function postAssetLoad() {
	PANDA_IMG = SPRITES['Panda.png'];
	//PORTAL_IMG = SPRITES['Goal_1.png'];
	PORTAL_IMG = SPRITES['Goal_all'];
	HEAD_UP_IMG = SPRITES['Head_Up.png'];
	HEAD_DOWN_IMG = SPRITES['Head_Down.png'];
	HEAD_LEFT_IMG = SPRITES['Head_Left.png'];
	HEAD_RIGHT_IMG = SPRITES['Head_Right.png'];
	TAIL_UP_IMG = SPRITES['Tail_Up.png'];
	TAIL_DOWN_IMG = SPRITES['Tail_Down.png'];
	TAIL_LEFT_IMG = SPRITES['Tail_Right.png'];
	TAIL_RIGHT_IMG = SPRITES['Tail_Left.png'];
	DOWN_TO_LEFT_IMG = SPRITES['Body_UpToLeft.png'];
	DOWN_TO_RIGHT_IMG = SPRITES['Body_UpToRight.png'];
	DOWN_TO_UP_IMG = SPRITES['Body_DownToUp.png'];
	LEFT_TO_DOWN_IMG= SPRITES['Body_RightToDown.png'];
	LEFT_TO_RIGHT_IMG= SPRITES['Body_RightToLeft.png'];
	LEFT_TO_UP_IMG= SPRITES['Body_RightToUp.png'];
	RIGHT_TO_DOWN_IMG= SPRITES['Body_LeftToDown.png'];
	RIGHT_TO_LEFT_IMG= SPRITES['Body_LeftToRight.png'];
	RIGHT_TO_UP_IMG= SPRITES['Body_UpToLeft.png'];
	UP_TO_DOWN_IMG= SPRITES['Body_UpToDown.png'];
	UP_TO_LEFT_IMG= SPRITES['Body_DownToLeft.png'];
	UP_TO_RIGHT_IMG= SPRITES['Body_DownToRight.png'];

	//load wall images
	VERTICAL_WALL_IMG = SPRITES['wall_stright_horizontal.png'];
	HORIZONTAL_WALL_IMG = SPRITES['wall_stright_vertical.png'];
	WALL_BLOCK_IMG = SPRITES['wall_block.png'];
	WALL_9S_TL_IMG = SPRITES['wall_9slice_tl.png'];
	WALL_9S_TC_IMG = SPRITES['wall_9slice_tc.png'];
	WALL_9S_TR_IMG= SPRITES['wall_9slice_tr.png'];
	WALL_9S_ML_IMG= SPRITES['wall_9slice_ml.png'];
	WALL_9S_MC_IMG = SPRITES['wall_9slice_mc.png'];
	WALL_9S_MR_IMG= SPRITES['wall_9slice_mr.png'];
	WALL_9S_BL_IMG= SPRITES['wall_9slice_bl.png'];
	WALL_9S_BC_IMG= SPRITES['wall_9slice_bc.png'];
	WALL_9S_BR_IMG= SPRITES['wall_9slice_br.png'];
	COMPLETE_IMG = SPRITES['map_complete_128x128.png'];
	CROWN_IMG = SPRITES['map_crown_128x128.png'];
	MAP_DRAGON_IMG = SPRITES['map_dragon_128x128.png'];
	MAP_ICON = SPRITES['mapIcon.png'];
	PAUSE_ICON = SPRITES['pauseIcon.png'];
	BACK_IMG = SPRITES['backIcon.png'];

	// Options panel images
	OPS_HOME_IMG = SPRITES['options_home_white.png'];
	OPS_FX_ON_IMG = SPRITES['options_fx_on_white.png'];

	OPS_FX_OFF_IMG = SPRITES['options_fx_off_white.png']
	OPS_SOUND_ON_IMG = SPRITES['options_sound_on_white.png'];
	OPS_SOUND_OFF_IMG = SPRITES['options_sound_off_white.png'];
	OPS_SPEED_FAST_IMG = SPRITES['options_speed_fast_white.png'];
	OPS_SPEED_SLOW_IMG = SPRITES['options_speed_slow_white.png'];
	
    /* Post-processing for assets */
    TILES_IMG_ARRAY= [
		SPRITES['tiles.png'],
		SPRITES['tiles_2.png'],
		SPRITES['tiles_3.png'],
		SPRITES['tiles_4.png']]

    //TODO: add all tile images to this array
    IMG_CACHE[MAP_IMG.pdmId] = MAP_IMG;
    IMG_CACHE[CROWN_IMG.pdmId] = CROWN_IMG;
    IMG_CACHE[COMPLETE_IMG.pdmId] = COMPLETE_IMG;

    OPS_SOUND_IMG = OPS_SOUND_ON_IMG;
    OPS_FX_IMG = OPS_FX_ON_IMG;
    OPS_SPEED_IMG = OPS_SPEED_FAST_IMG;

    //All the corner walls within a 9 slice are the same right now.
    //FIXME: add real images for 9-slice corners
    WALL_9S_MCTR_IMG=
            WALL_9S_MCTL_IMG=
            WALL_9S_MCBR_IMG=
            WALL_9S_MCBL_IMG=
            WALL_9S_MC_IMG;
}



function createImgAsset($id,$src) {
	var img=new Image();
	loadFlags[$id]=0;
	img.onload=function(){onAssetLoaded($id, img);};
	img.src=$src;
	img.pdmId = IMG_PREFIX + $id;
//    img.height = GRID_H;
//    img.width = GRID_W;
	return img;
}

//Load all images
//for i in sprites, new sprite(ss_img, name)
//have a map of name : sprite properties (including animation)
//renderObject will recognize sprites: reuse img, set offset, animate, etc.

//type : {static, animation}
//Animation-only
//total_frames: 3
//width : 32
//height: 64

function Sprite (img, sx, sy, w, h, scale, total_frames) {
	this.img = img;
	this.pdmId = img.pdmId;
	this.sx = sx;
	this.sy = sy;
	this.sprite = true;
	this.w = w;
	this.h = h;

	this.scale = (scale) ? scale : SPRITE_SCALE;
	this.scaled_w = this.width = w*this.scale;
	this.scaled_h = this.height = h*this.scale;

	//Animation specifics
	this.current = 0;
	this.total_frames = (total_frames) ? total_frames : 1;
}

var SPRITES = {};
var SS_TYPES = {STATIC : 0, ANIMATION: 1}; //enum of sprite sheet types.

function initSprites(id, img) {
	var mySprites = SPRITE_MAP[id];
	if (mySprites == undefined) {return;}
	switch (mySprites.type) {
		case SS_TYPES.STATIC:
			//Need to create sprites for everything in the sheet.
			for (var i in mySprites.sprites) {
				var s = mySprites.sprites[i];
			    SPRITES[i] = new Sprite(img,
					s.frame.x,s.frame.y,
					s.frame.w, s.frame.h,
				 	s.scale);
			}
			break;
		case SS_TYPES.ANIMATION:
			//Create animation sprite.
			var s = mySprites;
			SPRITES[id] = new Sprite(img,
									0,0, s.w,s.h,
									s.scale, s.total_frames);
			break;
		default:
			console.log("Unknown spritesheet type found.");
			break;
		}
}

function onAssetLoaded(asset_id, img) {
	loadFlags[asset_id]=1;
	initSprites(asset_id, img);
    //Don't start the game until everything's been loaded
	for(flag in loadFlags) {
		if(!loadFlags[flag]) {return;}
	}
    if (POST_ASSET_LOAD_FN) {POST_ASSET_LOAD_FN();}
    //Only continue if we want to continue the game
    if (!INIT_GAME) { return;}
	game_init();
}

function game_init() {
    initSound();
	initUi();
	//Load game state if present, otherwise create initial state
    if (!initGameState()) {
		init_map();
	}
    maze_init();
}

function getTailImg(dir) {
	switch(dir) {
	    case "left":
	        return TAIL_LEFT_IMG;
	        break;
	    case "right":
	        return TAIL_RIGHT_IMG;
	        break;
	    case "up":
	        return TAIL_UP_IMG;
	        break;
	    case "down":
	        return TAIL_DOWN_IMG;
	        break;
	}
}

function pauseClick(e, evt) {
		var e = (evt) ? evt : e; 
        var pos = findPos(this);
        var x = e.pageX - pos.x - maze.xOffset - optionsX - opsPad;
        var y = e.pageY - pos.y - maze.yOffset;
		if (y>= GRID_H*5+opsPad && y <= GRID_H*5+opsPad+optionsH && x>=0) {
			if (x< OPS_TARGET_W) {
				changeSpeed();
			} else if (x <=OPS_TARGET_W*2+opsPad) {
				toggleFX();
			} else if (x <= OPS_TARGET_W*3+2*opsPad) {
				toggleMusic();
			} else if (x <= OPS_TARGET_W*4+3*opsPad) {
				window.location = "/";
			}
			renderScreen(ANIM_OFFSET); 
			renderPauseScreen();
		} else if (y>=GRID_H*4-(BACK_IMG.scaled_h/2) && y <= GRID_H*4+(BACK_IMG.scaled_h/2) &&
					x >= optionsW-(BACK_IMG.scaled_w/2) &&
					x <= optionsW+(BACK_IMG.scaled_w/2) ) {
				togglePauseScreen();
		}
}

function gameClick(e, evt) {
		var e = (evt) ? evt : e; 
        //See if you clicked an option and, if so, call the option fn.
        var pos = findPos(this);
        var x = e.pageX - pos.x - maze.xOffset;
        var y = e.pageY - pos.y - maze.yOffset;
        var c = Math.ceil(x/GRID_W);
        var r = Math.ceil(y/GRID_H);
        if (r==1 && c==PAUSE_ICON_POS) {
            togglePauseScreen();
        }  else if (r==1 && c==MAP_ICON_POS) {
            toggleOptions();
        }
}

function mapClick(e) {
	  if (!MAP_VISIBLE) { 
			// ignore clicks if not visible.
			$("#maze-canvas-background").trigger("click",[e]);
			return; 
		} 
      //See if you clicked an option and, if so, call the option fn.
      var pos = findPos(this);
      var x = e.pageX - pos.x - maze.xOffset;
      var y = e.pageY - pos.y - maze.yOffset;
      if ((x>= 391*SPRITE_SCALE) && (y >= 21*SPRITE_SCALE) && x <= (391*SPRITE_SCALE + BACK_IMG.scaled_w*(SPRITE_SCALE/2)) && y <= (21*SPRITE_SCALE + BACK_IMG.scaled_h*(SPRITE_SCALE/2))) {
          toggleOptions();
      }
}

function initUi() {
    //Init configuration panel
    //$("input[name=speed]:radio").click(function() {changeSpeed(this.value);});
    //$("#ctrl_fx").click(function() {toggleFX(this.checked);});
    //$("#ctrl_music").click(function() {toggleMusic(this.checked)});
    //$("#options_link").click(toggleOptions);
    //$("#mapItem").click(toggleOptions);
    //$("#options_done").click(toggleOptions);
    $("#home").click(function() {window.location="/"});
    $("#alert-close").click(function () {toggleAlert(false);});

    //$("#quit").click(function() {quit()});
    //Set up graphics
	gameCanvas = document.getElementById('maze-canvas');
	wallCanvas = document.getElementById('maze-canvas-background');
	mapCanvas = document.getElementById('map-canvas');
    tileCanvas = document.getElementById('tile-canvas');
    //scoreCanvas = document.getElementById('score-canvas');
	gameStage = gameCanvas.getContext("2d");
	wallStage = wallCanvas.getContext("2d");
	mapStage = mapCanvas.getContext("2d");
	tileStage = tileCanvas.getContext("2d");
	//scoreStage = scoreCanvas.getContext("2d");
	var hpx = MAX_ROWS*GRID_H+WALL_PAD;
    var wpx = MAX_COLS*GRID_W;
    $(gameCanvas).attr("height", hpx);
    $(gameCanvas).attr("width", wpx);
    $(wallCanvas).attr("height", hpx);
    $(wallCanvas).attr("width", wpx);
    $(mapCanvas).attr("height", hpx);
    $(mapCanvas).attr("width", wpx);
    $(tileCanvas).attr("height", hpx);
    $(tileCanvas).attr("width", wpx);
	counter = 0;
	CanvasTextFunctions.enable(gameStage);

    $("#maze-canvas-background").click(gameClick);
	$("#map-canvas").click(mapClick);
}


function maze_init(){
    if(game_state == GAME_STATES.COMPLETE) {
		tileStage.clearRect(0,0,wallCanvas.width,wallCanvas.height);
		pdm.state.exitr = dragon.r;
		pdm.state.exitc = dragon.c;
        if (pdm.state.currentLevel>=pdm.state.map.levels.length){
            gameComplete();
            return;
        }

    } 

    if (game_state != GAME_STATES.FAILED) {
      if (pdm.state.currentLevel >= pdm.state.map.levels.length) { 
        //Ran into messed up cookie values.
        pdm.state.currentLevel = 0; 
        pdm.state.totalScore = 0;
      }
	  	maze = new Maze(pdm.state.map.levels[pdm.state.currentLevel].currentMazeStr);
		pdm.state.map.levels[pdm.state.currentLevel].visited = true;
    }
	maze.reset();
	if (game_state == GAME_STATES.COMPLETE || game_state == GAME_STATES.UNINIT) {
		maze.renderTiles(tileStage);
	}

	game_state = GAME_STATES.READY;
    printState();
	var rc = (maze.getEntry()) ? maze.getEntry(): maze.getStart();
	dragon = new Point(HEAD_DOWN_IMG, rc.r, rc.c, function () {});
	setHeadImg(dragon, pdm.state.exitdir);
	maze.addPoint(dragon);
	maze.render(wallStage);
	renderControls(wallStage);
    dir= (pdm.state.exitdir) ? pdm.state.exitdir : "start";
    startMusic();
	startGameLoop();
}

/*************************************/
/* Configuation functions            */
/*************************************/

function changeSpeed() {
     //console.log("Changing speed from "+MOVE_DELAY+" to "+s);
	 switch (OPS_SPEED_IMG) {
		case OPS_SPEED_FAST_IMG:
			OPS_SPEED_IMG = OPS_SPEED_SLOW_IMG;
			MOVE_DELAY= 15;
			break;
		default:
			OPS_SPEED_IMG = OPS_SPEED_FAST_IMG;
			MOVE_DELAY=10;
			break;
	}
}

/* Music and sound effects functions */

//Set up audio channels for seamless, simultaneous play of multiple sounds
//Thanks to http://www.storiesinflight.com/html5/audio.html 
function initSound() {
    //Code courtesy of http://html5doctor.com/native-audio-in-the-browser/
    var myAudio = $('#theme'); 
    if (myAudio.canPlayType) {
       // Currently canPlayType(type) returns: "", "maybe" or "probably" 
       //canPlayMp3 = !!myAudio.canPlayType && 
       //                 "" != myAudio.canPlayType('audio/mpeg');
       var canPlayOgg = !!myAudio.canPlayType && 
                        "" != myAudio.canPlayType('audio/ogg; codecs="vorbis"');
    }
    //Cache the appropriate audio source
    $.each($("audio"), function (i, v) {
                $.each($(v).children(), function (i2, v2) {
                        //Use ogg by default because it's smaller and open =)
                        if (v2.type == OGG_STR && canPlayOgg) {
                            AUDIO_SRC[v.id] = v2.src;
                        } else if (!canPlayOgg) {
                            //Otherwise set to MP3
                            AUDIO_SRC[v.id] = v2.src;
                        }
                    }
                )});
    
    for (a=0;a<CHANNEL_MAX;a++) { // prepare the channels
        AUDIOCHANNELS[a] = new Array();
        AUDIOCHANNELS[a]['channel'] = new Audio();// create a new audio object
        AUDIOCHANNELS[a]['finished'] = -1;// expected end time for this channel
    }
    //Workaround for Firefox and Safari
    THEME = new Audio();
    THEME.load();
    THEME.src=AUDIO_SRC['theme'];
    THEME.volume=.3;
    THEME.loop="loop";
    //Loop the theme track
    $(THEME).bind('ended', function() {this.currentTime=0});
}

function startMusic() {
    if (PLAY_THEME) {
        THEME.play();
        //$('#theme')[0].load();
        //$('#theme').bind('ended', function() {this.currentTime=0});
        //$('#theme')[0].volume=.3;
        //$('#theme')[0].play();
    }
}

function stopMusic() {
    //$('#theme')[0].pause();
    THEME.pause();
}

function toggleFX() {
    //PLAY_FX = on;
	PLAY_FX = !PLAY_FX;
	OPS_FX_IMG = (PLAY_FX) ? OPS_FX_ON_IMG : OPS_FX_OFF_IMG;
	//$("#fx-on").hasClass("no-display");
//	if (PLAY_FX) {
//		$("#fx-off").addClass("no-display");
//		$("#fx-on").removeClass("no-display");
//	} else {
//		$("#fx-on").addClass("no-display");
//		$("#fx-off").removeClass("no-display");
//	}
}

function toggleMusic() {
    //PLAY_THEME = on;
	PLAY_THEME = !PLAY_THEME;
	//PLAY_THEME = $("#music-on").hasClass("no-display");
    if (PLAY_THEME) {
        startMusic();
		OPS_SOUND_IMG = OPS_SOUND_ON_IMG;
		//$("#music-off").addClass("no-display");
		//$("#music-on").removeClass("no-display");
    } else {
        stopMusic();
		OPS_SOUND_IMG = OPS_SOUND_OFF_IMG;
		//$("#music-on").addClass("no-display");
		//$("#music-off").removeClass("no-display");
    }
}


//Shows an alert or message on the game canvas.
function toggleAlert(msg) {
	if (!msg) {
		$("#alert").addClass("no-display");
		unpause();
	} else {
		pause();
		$("#alert").removeClass("no-display");
		$("#alert-text").text(msg);
	}
}

function toggleOptions() {
  mapStage.clearRect(0,0,mapStage.canvas.width, mapStage.canvas.height);
  if (game_state == GAME_STATES.PAUSED) {
		MAP_VISIBLE = false;
		unpause();
		return;
	} else {
		MAP_VISIBLE = true;
		pause();
	
		//$("#lightbox").toggle();
		
		//draw the background image
		mapStage.drawImage(pdm.state.map.img,0,0);
		mapStage.globalAlpha = 0.5;
		mapStage.fillStyle = "#000000";
		mapStage.fillRect(0, 0, mapStage.canvas.width, pdm.state.map.gridH);
		mapStage.globalAlpha = 1;
	
		mapStage.drawImage(MAP_HEADER_BG,0,0);
		renderObject(mapStage, BACK_IMG,  391*SPRITE_SCALE, 21*SPRITE_SCALE);
		//mapStage.drawImage(BACK_IMG.img, 391*SPRITE_SCALE, 21*SPRITE_SCALE);
		
		
		// var renderOptions = function (stage, map) {
		// 	//Draw the options background
		// 	stage.globalAlpha = 0.5;
		// 	stage.fillStyle = "#000000";
		// 	stage.fillRect(0,0,mapStage.width, map.gridH);
		// 	stage.drawImage(map.optionsBgImg, 0,0);
		// 		
		// 	//draw the options row
		// 	for (var o in OPTIONS) {
		// 		stage.drawImage(OPTIONS[o].getImg(), map.xoff+o*OPTION_GRID_W, map.yoff);
		// 		OPTIONS[o].setPos(map.xoff+o*OPTION_GRID_W, map.yoff);
		// 	}
		// 	
		// }
		// renderOptions(mapStage);
			
		for(var level = 0, numlvls = pdm.state.map.levels.length; level < numlvls; level +=1) {
			var x = pdm.state.map.gridW*(level%pdm.state.map.cols);
			var y = pdm.state.map.gridH*Math.floor(level/pdm.state.map.cols) + OPTIONS_BAR_HEIGHT;
			if (level==pdm.state.currentLevel) {
				mapStage.drawImage(MAP_DRAGON_IMG, x,y);
			} else if (!pdm.state.map.levels[level].visited) {
				mapStage.globalAlpha = 0.5;
				mapStage.fillStyle = "#000000";
				mapStage.fillRect(x, y, pdm.state.map.gridW, pdm.state.map.gridH);
				mapStage.globalAlpha = 1;
			} else if (pdm.state.map.levels[level].specialImg) {
				mapStage.drawImage(pdm.state.map.specialImg, x, y);
			} else if (pdm.state.map.levels[level].completed) {
				mapStage.drawImage(pdm.state.map.completeImg, x, y);
			}
		}
	}
}

function deleteSavedGame() {
	localStorage.clear();
  //$.removeCookie("state");
//  $.removeCookie("CurrentLevel");
//  $.removeCookie("TotalScore");
}

function quit() {
  deleteSavedGame();
  window.location = "/";
}

//Plays multiple sounds simultaneously a bit more smoothly than would happen normally.
//Courtesy of http://www.storiesinflight.com/html5/audio.html. Thanks!
function playMultiSound(s) {
    if (PLAY_FX) {
        for (a=0;a<AUDIOCHANNELS.length;a++) {
            thistime = new Date();
            if (AUDIOCHANNELS[a]['finished'] < thistime.getTime()) {            // is this channel finished?
                AUDIOCHANNELS[a]['finished'] = thistime.getTime() + document.getElementById(s).duration*1000;
                AUDIOCHANNELS[a]['channel'].src = AUDIO_SRC[s];
                AUDIOCHANNELS[a]['channel'].load();
                AUDIOCHANNELS[a]['channel'].play();
                break;
            }
        }
    }
}


/*************************************/
/* Mazes                             */
/*************************************/

function init_map() {
	pdm.state.map = new Map(MAP_IMG, 3, 7, 128, 128, init_levels(), COMPLETE_IMG);
}

function init_levels() {
	lvls = [];
	//0 
	lvls.push(new Level("20f0e010101010101010101010101010101040000000000000000000000010100000000000000000000000001010000000000010000000000000101000000000001000000000000010100000000000100000000000003010100000002000100020000000003010100000000000100000000000003010100000000000100000000000001010000000000010000000000000101000000000001000000000000010100000000000100000000000001010000000000000000000000000101000000000000000000000000010101010101010101010101010101"));
	//1
	lvls.push(new Level("20f0e0101010101010101010101010101010400000000000000000000000101000000000000000000000000010100000101010000010101000001010000000000000000000000000103000001000000000000000001000302030000010000000200000000010003020300000100000000000000000100030201000000000000000000000000010100000000000000000000000001010000010101000001010100000101000000000000000000000000010100000000000000000000000001010000000000000000000000000101010101010103080308010101010101"));
	//2
	lvls.push(new Level("20f0e0101010101010101010101010101010400000000000000000000000101000000000000000000000000010100010101000101000101010001010001000000000000000001000103010001000000000000000001000103010001000002000000020001000103010001000000000000000001000101000100000000000000000100010100010101000101000101010001010000000000000000000000000101000000000000000000000000010100000000000000000000000001010000000000000000000000000101010101010103090309010101010101"));
	//lvls.push(new Level("20f0e010101010101010101010101010101000000000000000000000000010100000000000000000000000001010001000002000001000000000101000000010001000000010000010301000000000000020000000200010301000100000004000100000000010301000000010001000000010000010100000000020000000000000001010001000000000001000000000101000000000000000000000000010100000000000000000000000001010000000000000000000000000101000000000000000000000000010101010101010101010101010101"));
	//3
	lvls.push(new Level("20f0e01010101010101010101010101010104000100000000000100000001010000010001010100010001000101000001000002000001020100010100000100010101000100010001010000010001000100010000000101000201000102010001010101010100000100010001000000000003040100000100010001000101010101010000010001010100010000000101000101000002000001000100010100010000010101000100010201010101000001000100010001000101000000000100010001000000010101030a0101010101010101010101"));
	//4	
	lvls.push(new Level("20f0e01010101010101010101010101010104000000000000000000000001010000000000000000000000000101000000000000000000000000010102020000010100000100000201010200020001000100020202010101020002000100010001000002010303020200000100010002000001010102000000010001000100000201010200000001000100020000010101020000000101000001000002010100000000000000000000000001010000000000000000000000000101000000000000000000000000010101010101030b030b030b010101010101"));
	//5
	lvls.push(new Level("20f0e0101010101010101010101010101010000000000000000000000000101000101010201010102010100010100010000000000000000000001010001020000000000000000000101000100000000000000010101010100010001020101010201000003060100010000000000000001000001010001010101010100000100000101000000000000010000010002010100000101010001000101000101010000000201000100020100020101000000000100010000010000010100000000010401000000000001010101010101030c01010101010101"));

	//6
	lvls.push(new Level("20f0e01010101010101010101010101010100000000000000000000000001010000000201010101010200000101000000010000000000010000010100000001000200020001000001010000000100000000000100000103050000000100000000000100000101000000000100010001000000010100000000020002000200000001010000000102000200020100000101000000000100010001000000010100000000000000000000000001010400000000000000000000000101000000000000000000000000010101010101030d01010101030d010101"));
	//7
	lvls.push(new Level("20f0e01010101010101010101010101010100000000000000000000000001010000000000000000000000000101000100000001000000010000010100020001000200010002000001010000000000000000000000000101000100000001000000010000010100000001000000010000000001010000000200000002000000000101000100000001000000010000010100000001000000010000000001010000000000000000000000000101000000000000040000000000010100000000000000000000000001010101010101030e030e010101010101"));
	//8
	lvls.push(new Level("20f0e0101010101010301030101010101010101040000000000000000000000010100000000000000000000000001010000000101010101010000000101000000010200000201000000010100000001000000000100000001010000000100000000010000000101000000010100000101000000010100000000000000000000000001010001000000000000000001000101000000000000000000000000010100000000000202000000000001010000000000000000000000000101000000000000000000000000010101010101010101010101010101"));
	//9
	lvls.push(new Level("20f0e01010101010103020302010101010101010000000000040000000000000101000000000000000000000000010100000001010101010100000001010000000000000000010000000101000000010201010101000000010100000001000000000100000001010000000101010201010000000101000000010000000001000000010100000001010201010100000001010000000000000000000000000101000000000000000000000000010100000000000000000000000001010000000000000000000000000101010101010103100310010101010101"));
	//10
	lvls.push(new Level("20f0e0101030301010101010101010101010104000000000000000000000001010001000000010000000100000101000000010002000100000000010100000000000000000000000001010101010101010101010101000101000000000000000000000000010100000000000000000000000001010001010101010101010100000101000000000000000000010000010100000000000000000001020001010101010101010101000101010101020000000000000000000000010100000000000000000000000001010101010101010101010103110101"));
	//11
	lvls.push(new Level("20f0e01010101010304030403040101010101010104000000000000000000000001010000000000000000000000000101000100000000000000010000010100010000000000000001000001010001000000020000000100000101020100000101010000010200030c01000100000002000000010000010100010000000000000001000001010001000000000000000100000101000000000000000000000000010100000000000000000000000001010000000000000000000000000101000000000000000000000000010101010101031203120312010101010101"));
	//12
	lvls.push(new Level("20f0e0101010101010305010101010101010100000000000000000000000001010000000000000000000000000101000000000000000000000000030d01000000000000000000010000010100000000000000000002000001030b04000000000000000001000001010000000000000002000200000101000000000000000100010000010100000000000200020002000001010000000000010001000100000101000000000002000200020000030d010001020102010201020100000101000000000000000000000000010101010101010101010101010101"));
	//13
	lvls.push(new Level("20f0e0101010101030601010101030601010101040000010001020201000100010100000001000100000100010001030c000000010000000000000100010100000001010100010101010001010000020000000000000000000101000100010101000102010000010100020000000000000000000001010001000102010001010102000101000002000000000000000000010100010101000102010001000001030c0000000000000000020000000101000102010001010100010000010100000000000000000000000001010101010101010314010101010101"));
	//14
	lvls.push(new Level("20f0e010101010101030703070101010101010100000000000000000000000001010001000000000000000001000101000001020000000002010000010100000001000000000100000001010000000001020001000000000101000000000001010200000004030f01000000000201010000000000030f0100000000010002010000000001010000020100000000010200000101000001000000000000010000010100010000000000000000010001010000000000000000000000000101000000000000000000000000010101010101010101010101010101"));
	//15
	lvls.push(new Level("20f0e010101010101010101010101010101000000000000000000000000010100000000000000000000000001010000010001000001020100000101000002000000000000000000010100000100010000010001000001030e0000000000000400000000000310030e00000000000000000000000003100100000000000000000000000001010000010001000001000100000101000000000000000000020000010100000102010000010001000001010000000000000000000000000101000000000000000000000000010101010101010101010101010101"));
	//16
	lvls.push(new Level("20f0e0101010101010309030901010101010101000000000000000000000000010100000000000000000000000001010000000000000000000000000101000000000000000000000000010100000000000000000000000001030f0000000001000100000000000311030f00000000010201000000000003110100000000010401000000000001010000000001010100000000000101000000000000000000000000010100000000000000000000000001010000000000000000000000000101000000000000000000000000010101010101010101010101010101"));
	//17
	lvls.push(new Level("20f0e0101010101010101010101030a0101010000000000000000010000000101000000000000000001000000010100000000000100000100000001010204000002010200010200000101010101000001000101010100010310000001000001000001020000010310000001000001000001000000010100000100000100000100000001010000010000010002010000000101000001000001000101000000010100000100000100000200000001010000000000010000000000000101000000000001000000000000010101010101010101010101010101"));
	//18
	lvls.push(new Level("20f0e0101010101030b030b030b010101010101010000020100000401020000000101000100010000000100010100010100010001010101010001010001010001000000000000000000000101000101010101010101000000010100000000000000000100000001010101010101010100010001000101020001000003630100010001000313010000010001010100010001000101000001000000000001000100010100000101010101010100010001010000000000000000000000000101000000000000000000000000010101010101010101010101010101"));
	//19
	lvls.push(new Level("20f0e0101010101010101010101010101010000000000000000000000000101000000000101000000000000010100000000010200000101000001010001010000000000010200000101000102000001010000000101010100000000000102000000010003140100000101000000000000010003140312000001020000000000000100031401000000000000010100000101010100000001010001020000000001010000000102000000000000000101000000000000000000000004010100000000000000000000000003140101010101010101010101010101"));
	//20
	lvls.push(new Level("20f0e01010101010101030d0101010101010100000000000004000000000001010000000000000000000000000101000102020201020202010000010100020201020102010202000001010002020002010202020200000103130001020202010202020100000103130002020102020201020200000103130002020202020202020200000101000102020201020202010000010100020201020202010202000001010000000000000000000000000101000000000000000000000000010313000000000000000000000000010101010101010101010101010101"));
	
	return lvls;
}

/*************************************/
/* I/O functions                     */
/*************************************/

function onKeyDown(evt){
	evt.preventDefault();
	switch(game_state) {
		case GAME_STATES.PAUSED:
			switch(evt.keyCode) {
				case ESC:
					toggleOptions();
					break;
				default:
					//Do nothing
			}
			break;
		case GAME_STATES.READY:
			switch(evt.keyCode) {
				case LEFT_ARROW:
				case RIGHT_ARROW:
				case DOWN_ARROW:
				case UP_ARROW:
					gameStage.clearRect(0,0,gameCanvas.width,gameCanvas.height);
					//wallStage.clearRect(0,0,wallCanvas.width,wallCanvas.height);
					//maze.render(wallStage);
					//renderMazeObject(dragon,gameStage);
					renderMazeObject(dragon,wallStage);
					game_state=GAME_STATES.PLAYING;
					break;
				default:
					//Do nothing
			}
		case GAME_STATES.PLAYING:
			switch (evt.keyCode) {
	         	//Store in nextDir to save the last direction
				case LEFT_ARROW:
					nextDir = "left";
					break;
				case RIGHT_ARROW:
					nextDir = "right";
					break;
				case DOWN_ARROW:
					nextDir = "down";
					break;
				case UP_ARROW:
					nextDir = "up";
					break;
				case ESC:
					toggleOptions();
					break;
				default:
					//Do nothing
			}
			break;
		default:
			switch(evt.keyCode) {
				case LEFT_ARROW:
				case RIGHT_ARROW:
				case DOWN_ARROW:
				case UP_ARROW:
					//Only start if you've picked a direction to go in
					gameStage.clearRect(0,0,gameCanvas.width,gameCanvas.height);
					//mapStage.clearRect(0,0,mapCanvas.width,mapCanvas.height);
					wallStage.clearRect(0,0,wallCanvas.width,wallCanvas.height);
					maze_init();
					break;
				default:
					//Do nothing
			}
	}
}

/*************************************/
/* Game loop control functions       */
/*************************************/

// Thanks Paul Irish. shim layer with setTimeout fallback
//Note this seems to break in Firefox and Safari, so I'm not using it.
//window.requestAnimFrame = (function(){
//  return  window.requestAnimationFrame       || 
//          window.webkitRequestAnimationFrame || 
//          window.mozRequestAnimationFrame    || 
//          window.oRequestAnimationFrame      || 
//          window.msRequestAnimationFrame     || 
//          function(/* function */ callback, /* DOMElement */ element){
//            window.setTimeout(callback, 1000 / 60);
//          };
//})();

//window.cancelRequestAnimFrame = ( function() {
//    return window.cancelAnimationFrame          ||
//        window.webkitCancelRequestAnimationFrame    ||
//        window.mozCancelRequestAnimationFrame       ||
//        window.oCancelRequestAnimationFrame     ||
//        window.msCancelRequestAnimationFrame        ||
//        window.clearTimeout;
//} )();

function pause() {
	PREPAUSE_GAME_STATE = game_state;
	game_state = GAME_STATES.PAUSED;
	stopGameLoop();
}

function unpause() {
	game_state = PREPAUSE_GAME_STATE;
	PREPAUSE_GAME_STATE = undefined;
	startGameLoop();
}


function startGameLoop() {
	window.onkeydown=onKeyDown;
	gameLoop();
}

function gameLoop() {
	//request=window.requestAnimFrame(gameLoop,gameCanvas);
	if (request) {
		stopGameLoop();
	}
    request = window.setTimeout(gameLoop, 1000 / 60);
	update();
}

function stopGameLoop() {
	//window.cancelRequestAnimFrame(request);
    window.clearTimeout(request);
	request = undefined;
}

var PAUSE_Y = -103*SPRITE_SCALE;
var ANIM_OFFSET = 0;
var ctrlHidden= false, pauseInPlace = false;

function resetAnimVals() {
	PAUSE_Y = -103*SPRITE_SCALE;
	ANIM_OFFSET = 0;
	ctrlHidden= false, pauseInPlace = false;
}

function togglePauseScreen() {
		if (game_state == GAME_STATES.PAUSED) {
			ctrlHidden = false;
			pauseInPlace = false;
			pauseOutLoop();
		} else {
			pause();
    		$("#maze-canvas-background").unbind("click", gameClick);
			pauseInLoop();
		}
}

function pauseOutLoop() {
	if (ctrlHidden && pauseInPlace) {
			window.clearTimeout(request);
    		$("#maze-canvas-background").unbind("click", pauseClick);
    		$("#maze-canvas-background").click(gameClick);
			resetAnimVals();
			unpause();
			return;
	}
	if (pauseInPlace && !ctrlHidden) {
		ANIM_OFFSET -= 10*SPRITE_SCALE;
	}
	if (!pauseInPlace) {
		PAUSE_Y -= 10*SPRITE_SCALE;
	}
	renderScreen(ANIM_OFFSET); 
	renderPauseScreen();
	pauseInPlace = (PAUSE_Y <= -103*SPRITE_SCALE);
	ctrlHidden = ANIM_OFFSET<=0;
    request = window.setTimeout(pauseOutLoop, 1000 / 60);

}

function pauseInLoop() {
	if (ctrlHidden && pauseInPlace) {
			window.clearTimeout(request);
    		$("#maze-canvas-background").click(pauseClick);
			return;
	}
	if (!ctrlHidden) {
		ANIM_OFFSET += 10*SPRITE_SCALE;
	}
	if (ctrlHidden && !pauseInPlace) {
		PAUSE_Y += 10*SPRITE_SCALE;
	}

	renderScreen(ANIM_OFFSET); 
	renderPauseScreen();
	
	
	//render options images and circle
	
	pauseInPlace = (PAUSE_Y >= 4*GRID_H);
	ctrlHidden = ANIM_OFFSET>GRID_W*3;
    request = window.setTimeout(pauseInLoop, 1000 / 60);
}

function update() {
    //Set the right head image depending on the direction
	setHeadImg(dragon, dir);
	renderScreen();

    if (game_state == GAME_STATES.PLAYING) {
    	counter += 1;
    	if (counter>MOVE_DELAY) {
    		var oldR = dragon.r;
    		var oldC = dragon.c;
            lastDir = dir;
            dir = nextDir;
    	
    		if (dir=="left") {
    			dragon.c = dragon.c - 1;
    			counter =0;
    		}
    		if (dir=="right") {
    			dragon.c = dragon.c + 1;
    			counter =0;
    		}
    		if (dir=="up") {
    			dragon.r = dragon.r - 1;
    			counter =0;
    		}
    		if (dir=="down") {	
    			dragon.r = dragon.r + 1;
    			counter =0;
    		}	

			maze.removePoint(oldR, oldC);
			maze.addDragonBody(dir, lastDir, oldR, oldC);

    		maze.isOn(dragon.r, dragon.c);
		    if (game_state != GAME_STATES.PLAYING) { return; }
            //if (dir!="start") {
            //    //LEVEL_SCORE += EARNED_POINTS[MOVE_DELAY];
    		//}
			maze.addPoint(dragon);

          }
        }
	}


/*************************************/
/* Rendering functions               */
/*************************************/


/** roundRect
 * @author Juan Mendes
 * http://js-bits.blogspot.com/2010/07/canvas-rounded-corner-rectangles.html
 * 
 * Draws a rounded rectangle using the current state of the canvas. 
 * If you omit the last three params, it will draw a rectangle 
 * outline with a 5 pixel border radius 
 * @param {CanvasRenderingContext2D} ctx
 * @param {Number} x The top left x coordinate
 * @param {Number} y The top left y coordinate 
 * @param {Number} width The width of the rectangle 
 * @param {Number} height The height of the rectangle
 * @param {Number} radius The corner radius. Defaults to 5;
 * @param {Boolean} fill string reprsenting color for rectanble fill. 
 * @param {Boolean} stroke Whether to stroke the rectangle. Defaults to true.
 */
function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
  if (typeof stroke == "undefined" ) {
    stroke = true;
  }
  if (typeof radius === "undefined") {
    radius = 5;
  }

  if (typeof fill === "undefined") {
	fill = false;
	}
  ctx.beginPath();
  ctx.moveTo(x + radius, y);
  ctx.lineTo(x + width - radius, y);
  ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
  ctx.lineTo(x + width, y + height - radius);
  ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
  ctx.lineTo(x + radius, y + height);
  ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
  ctx.lineTo(x, y + radius);
  ctx.quadraticCurveTo(x, y, x + radius, y);
  ctx.closePath();
  if (stroke) {
    ctx.stroke();
  }
  if (fill) {
	ctx.fillStyle = fill;
    ctx.fill();
  }        
}

// updates the current score by adding p points to it
function updateScore(p) {
       SCORE += p;
}

//Prints the game state string in the center of the maze
function printState () {
	//gameStage.drawTextCenter("sans", 16, maze.getCenterX(), maze.getCenterY(), game_state); 
}

//Prints text at x and y on the given stage
function stagePrint(text, x, y, stage, fill, font) {
	if (typeof fill === "undefined") {
		fill = "#000";
	}
	if (typeof font === "undefined") {
		font = "18px StarPerv";
	}
	stage.fillStyle = fill;
	stage.font = font;
	stage.textBaseline = 'top';
	stage.fillText(text, x, y);
}


//renders the screen
function renderScreen(offset) {
	var offset = (offset) ? offset : 0;
    wallStage.clearRect(0,0, wallCanvas.width, wallCanvas.height);
    maze.render(wallStage);
	renderControls(wallStage, offset);
}

function renderControls(stage, offset) {
	var offset = (offset) ? offset : 0;
	//draw background box
	roundRect(stage, 10*SPRITE_SCALE-offset, 6*SPRITE_SCALE, 80*SPRITE_SCALE, 12*SPRITE_SCALE, 3*SPRITE_SCALE, "rgba(0,0,0, 0.8)", false);
	//render Panda
	renderObject(stage, PANDA_IMG, 7*SPRITE_SCALE-offset, 3*SPRITE_SCALE, SPRITE_SCALE/2);
	//render total score
	stagePrint("x" + pdm.state.totalScore+" + "+LEVEL_SCORE,  23*SPRITE_SCALE-offset, 8*SPRITE_SCALE, stage, "#fff");
	//render mapicon
	var xy = maze.grid2canvas(1, MAP_ICON_POS);
	renderObject(stage, MAP_ICON, xy.x+offset, 0);

	//render pause 
	xy = maze.grid2canvas(1, PAUSE_ICON_POS);
	renderObject(stage, PAUSE_ICON, xy.x+offset, 0);
}

//Renders the pause screen
function renderPauseScreen() {
	var opsArr = [OPS_SPEED_IMG, OPS_FX_IMG, OPS_SOUND_IMG, OPS_HOME_IMG];
	roundRect(wallStage, optionsX, PAUSE_Y, 
		optionsW, optionsH, 10*SPRITE_SCALE, 
		"rgba(0,0,0, 0.8)", false);
	for (var i=0; i < opsArr.length; i++) {
		var tmpX = optionsX+opsPad+OPS_TARGET_W*i+opsPad*i;
		var tmpY = PAUSE_Y+GRID_H+opsPad;
		renderObject(wallStage, BACK_IMG, optionsX+optionsW-(BACK_IMG.scaled_w/2),
			PAUSE_Y-(BACK_IMG.scaled_h/2));
		renderObject(wallStage, opsArr[i], tmpX, tmpY);
		switch (i) {
			case 0:
				stagePrint("speed", tmpX+opsPad, tmpY+OPS_TARGET_H, wallStage, "#fff", "24px StarPerv");
				break;
			case 1:
				stagePrint("fx", tmpX+opsPad+opsPad+opsPad+opsPad, tmpY+OPS_TARGET_H, wallStage, "#fff", "24px StarPerv");
				break;
			case 2:
				stagePrint("music", tmpX+opsPad, tmpY+OPS_TARGET_H, wallStage, "#fff", "24px StarPerv");
				break;
			case 3:
				stagePrint("home", tmpX+opsPad+opsPad+opsPad, tmpY+OPS_TARGET_H, wallStage, "#fff", "24px StarPerv");
				break;
			default:
				//no op
				break;
		}
	}
}

//Abstract the details of drawing to support multiple platoforms.
//Today, only rendering on HTML5 cavas is supported, but not for long
function renderObject(stage, sprite, x, y, scale) {
	var sx = sprite.sx + sprite.w*sprite.current;
	var sw = (scale) ? sprite.w * scale : sprite.scaled_w;
	var sh = (scale) ? sprite.h * scale : sprite.scaled_h;
	stage.drawImage(sprite.img, 
			sx, sprite.sy, sprite.w, sprite.h,
			x, y, sw, sh);
	sprite.current = (sprite.current + 1 ) % sprite.total_frames;
}

/*
* Default rendering engine
*/
function renderMazeObject($obj, stage) {
	if ($obj.img == undefined){ return; }
	var xy=maze.grid2canvas($obj.r, $obj.c);
    var x = xy.x+$obj.xOffset;
    var y = xy.y+$obj.yOffset;
	try {
		renderObject(stage, $obj.img,x,y);
		if ($obj.obj_type && $obj.obj_type == TYPES.GOAL && DEBUG) {
			stagePrint($obj.destination, xy.x+Math.floor(GRID_W/2), xy.y, stage, "#000", "12px sans-serif");
		}
	} catch($error) {
		alert($error.message);
		console.log("Error rendering object: "+ $error.message)
	}
}

//Main functions held in respective pages.

//maps sprites to the images in which they are held.
var SPRITE_MAP = {
"Goal_all" : {"type": SS_TYPES.ANIMATION,
				"total_frames": 3,
				"w" : 33,
				"h" : 38
				},
"pdm_static_ss": {
		"type" : SS_TYPES.STATIC,
		"sprites": {

"Body_DownToLeft.png":
{
	"frame": {"x":2,"y":2,"w":32,"h":16},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
	"sourceSize": {"w":32,"h":16}
},
"Body_DownToRight.png":
{
	"frame": {"x":36,"y":2,"w":32,"h":16},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
	"sourceSize": {"w":32,"h":16}
},
"Body_DownToUp.png":
{
	"frame": {"x":70,"y":2,"w":32,"h":16},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
	"sourceSize": {"w":32,"h":16}
},
"Body_LeftToDown.png":
{
	"frame": {"x":2,"y":20,"w":32,"h":16},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
	"sourceSize": {"w":32,"h":16}
},
"Body_LeftToRight.png":
{
	"frame": {"x":36,"y":20,"w":32,"h":16},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
	"sourceSize": {"w":32,"h":16}
},
"Body_LeftToUp.png":
{
	"frame": {"x":70,"y":20,"w":32,"h":16},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
	"sourceSize": {"w":32,"h":16}
},
"Body_RightToDown.png":
{
	"frame": {"x":2,"y":38,"w":32,"h":16},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
	"sourceSize": {"w":32,"h":16}
},
"Body_RightToLeft.png":
{
	"frame": {"x":36,"y":38,"w":32,"h":16},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
	"sourceSize": {"w":32,"h":16}
},
"Body_RightToUp.png":
{
	"frame": {"x":70,"y":38,"w":32,"h":16},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
	"sourceSize": {"w":32,"h":16}
},
"Body_UpToDown.png":
{
	"frame": {"x":2,"y":56,"w":32,"h":16},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
	"sourceSize": {"w":32,"h":16}
},
"Body_UpToLeft.png":
{
	"frame": {"x":36,"y":56,"w":32,"h":16},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
	"sourceSize": {"w":32,"h":16}
},
"Body_UpToRight.png":
{
	"frame": {"x":70,"y":56,"w":32,"h":16},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
	"sourceSize": {"w":32,"h":16}
},
"Goal_1.png":
{
	"frame": {"x":2,"y":74,"w":33,"h":38},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":33,"h":38},
	"sourceSize": {"w":33,"h":38}
},
"Head_Down.png":
{
	"frame": {"x":37,"y":74,"w":32,"h":32},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":32,"h":32},
	"sourceSize": {"w":32,"h":32}
},
"Head_Left.png":
{
	"frame": {"x":71,"y":74,"w":32,"h":32},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":32,"h":32},
	"sourceSize": {"w":32,"h":32}
},
"Head_Right.png":
{
	"frame": {"x":2,"y":114,"w":32,"h":32},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":32,"h":32},
	"sourceSize": {"w":32,"h":32}
},
"Head_Up.png":
{
	"frame": {"x":36,"y":114,"w":32,"h":32},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":32,"h":32},
	"sourceSize": {"w":32,"h":32}
},
"Panda.png":
{
	"frame": {"x":70,"y":114,"w":24,"h":25},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":24,"h":25},
	"sourceSize": {"w":24,"h":25}
},
"Tail_Down.png":
{
	"frame": {"x":2,"y":148,"w":32,"h":16},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
	"sourceSize": {"w":32,"h":16}
},
"Tail_Left.png":
{
	"frame": {"x":36,"y":148,"w":32,"h":16},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
	"sourceSize": {"w":32,"h":16}
},
"Tail_Right.png":
{
	"frame": {"x":70,"y":148,"w":32,"h":16},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
	"sourceSize": {"w":32,"h":16}
},
"Tail_Up.png":
{
	"frame": {"x":2,"y":166,"w":32,"h":16},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
	"sourceSize": {"w":32,"h":16}
}}},

"options_map_ss" : {
	"type" : SS_TYPES.STATIC,
	"sprites" :
		{"backIcon.png":
		 {
			"scale" : 1,
			"frame": {"x":2,"y":2,"w":64,"h":56},
			"rotated": false,
			"trimmed": false,
			"spriteSourceSize": {"x":0,"y":0,"w":64,"h":56},
			"sourceSize": {"w":64,"h":56}
		},
		"mapIcon.png":
		{
			"scale" : 1,
			"frame": {"x":68,"y":2,"w":64,"h":56},
			"rotated": false,
			"trimmed": false,
			"spriteSourceSize": {"x":0,"y":0,"w":64,"h":56},
			"sourceSize": {"w":64,"h":56}
		},
		"map_complete_128x128.png":
		{
			"scale" : 1,
			"frame": {"x":134,"y":2,"w":128,"h":128},
			"rotated": false,
			"trimmed": false,
			"spriteSourceSize": {"x":0,"y":0,"w":128,"h":128},
			"sourceSize": {"w":128,"h":128}
		},
		"map_crown_128x128.png":
		{
			"scale" : 1,
			"frame": {"x":264,"y":2,"w":128,"h":128},
			"rotated": false,
			"trimmed": false,
			"spriteSourceSize": {"x":0,"y":0,"w":128,"h":128},
			"sourceSize": {"w":128,"h":128}
		},
		"map_dragon_128x128.png":
		{
			"scale" : 1,
			"frame": {"x":2,"y":132,"w":128,"h":128},
			"rotated": false,
			"trimmed": false,
			"spriteSourceSize": {"x":0,"y":0,"w":128,"h":128},
			"sourceSize": {"w":128,"h":128}
		},
		"options_fx_off_white.png":
		{
			"scale" : 1,
			"frame": {"x":132,"y":132,"w":120,"h":105},
			"rotated": false,
			"trimmed": false,
			"spriteSourceSize": {"x":0,"y":0,"w":120,"h":105},
			"sourceSize": {"w":120,"h":105}
		},
		"options_fx_on_white.png":
		{
			"scale" : 1,
			"frame": {"x":254,"y":132,"w":120,"h":105},
			"rotated": false,
			"trimmed": false,
			"spriteSourceSize": {"x":0,"y":0,"w":120,"h":105},
			"sourceSize": {"w":120,"h":105}
		},
		"options_home_white.png":
		{
			"scale" : 1,
			"frame": {"x":376,"y":132,"w":120,"h":105},
			"rotated": false,
			"trimmed": false,
			"spriteSourceSize": {"x":0,"y":0,"w":120,"h":105},
			"sourceSize": {"w":120,"h":105}
		},
		"options_sound_off_white.png":
		{
			"scale" : 1,
			"frame": {"x":2,"y":262,"w":120,"h":105},
			"rotated": false,
			"trimmed": false,
			"spriteSourceSize": {"x":0,"y":0,"w":120,"h":105},
			"sourceSize": {"w":120,"h":105}
		},
		"options_sound_on_white.png":
		{
			"scale" : 1,
			"frame": {"x":124,"y":262,"w":120,"h":105},
			"rotated": false,
			"trimmed": false,
			"spriteSourceSize": {"x":0,"y":0,"w":120,"h":105},
			"sourceSize": {"w":120,"h":105}
		},
		"options_speed_fast_white.png":
		{
			"scale" : 1,
			"frame": {"x":246,"y":262,"w":120,"h":105},
			"rotated": false,
			"trimmed": false,
			"spriteSourceSize": {"x":0,"y":0,"w":120,"h":105},
			"sourceSize": {"w":120,"h":105}
		},
		"options_speed_slow_white.png":
		{
			"scale" : 1,
			"frame": {"x":368,"y":262,"w":120,"h":105},
			"rotated": false,
			"trimmed": false,
			"spriteSourceSize": {"x":0,"y":0,"w":120,"h":105},
			"sourceSize": {"w":120,"h":105}
		},
		"pauseIcon.png":
		{
			"scale" : 1,
			"frame": {"x":2,"y":369,"w":64,"h":56},
			"rotated": false,
			"trimmed": false,
			"spriteSourceSize": {"x":0,"y":0,"w":64,"h":56},
			"sourceSize": {"w":64,"h":56}
		}}},


"wall_tiles_ss" : {
		"type" : SS_TYPES.STATIC,
		"sprites" : {

			"tiles.png":
			{
				"frame": {"x":2,"y":2,"w":32,"h":16},
				"rotated": false,
				"trimmed": false,
				"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
				"sourceSize": {"w":32,"h":16}
			},
			"tiles_2.png":
			{
				"frame": {"x":36,"y":2,"w":32,"h":16},
				"rotated": false,
				"trimmed": false,
				"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
				"sourceSize": {"w":32,"h":16}
			},
			"tiles_3.png":
			{
				"frame": {"x":70,"y":2,"w":32,"h":16},
				"rotated": false,
				"trimmed": false,
				"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
				"sourceSize": {"w":32,"h":16}
			},
			"tiles_4.png":
			{
				"frame": {"x":2,"y":20,"w":32,"h":16},
				"rotated": false,
				"trimmed": false,
				"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
				"sourceSize": {"w":32,"h":16}
			},
			"wall_9slice_bc.png":
			{
				"frame": {"x":36,"y":20,"w":32,"h":26},
				"rotated": false,
				"trimmed": false,
				"spriteSourceSize": {"x":0,"y":0,"w":32,"h":26},
				"sourceSize": {"w":32,"h":26}
			},
			"wall_9slice_bl.png":
			{
				"frame": {"x":70,"y":20,"w":32,"h":26},
				"rotated": false,
				"trimmed": false,
				"spriteSourceSize": {"x":0,"y":0,"w":32,"h":26},
				"sourceSize": {"w":32,"h":26}
			},
			"wall_9slice_bm.png":
			{
				"frame": {"x":36,"y":20,"w":32,"h":26},
				"rotated": false,
				"trimmed": false,
				"spriteSourceSize": {"x":0,"y":0,"w":32,"h":26},
				"sourceSize": {"w":32,"h":26}
			},
			"wall_9slice_br.png":
			{
				"frame": {"x":2,"y":48,"w":32,"h":26},
				"rotated": false,
				"trimmed": false,
				"spriteSourceSize": {"x":0,"y":0,"w":32,"h":26},
				"sourceSize": {"w":32,"h":26}
			},
			"wall_9slice_mc.png":
			{
				"frame": {"x":36,"y":48,"w":32,"h":16},
				"rotated": false,
				"trimmed": false,
				"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
				"sourceSize": {"w":32,"h":16}
			},
			"wall_9slice_ml.png":
			{
				"frame": {"x":70,"y":48,"w":32,"h":16},
				"rotated": false,
				"trimmed": false,
				"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
				"sourceSize": {"w":32,"h":16}
			},
			"wall_9slice_mr.png":
			{
				"frame": {"x":2,"y":76,"w":32,"h":16},
				"rotated": false,
				"trimmed": false,
				"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
				"sourceSize": {"w":32,"h":16}
			},
			"wall_9slice_tc.png":
			{
				"frame": {"x":36,"y":76,"w":32,"h":16},
				"rotated": false,
				"trimmed": false,
				"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
				"sourceSize": {"w":32,"h":16}
			},
			"wall_9slice_tl.png":
			{
				"frame": {"x":70,"y":76,"w":32,"h":16},
				"rotated": false,
				"trimmed": false,
				"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
				"sourceSize": {"w":32,"h":16}
			},
			"wall_9slice_tr.png":
			{
				"frame": {"x":2,"y":94,"w":32,"h":16},
				"rotated": false,
				"trimmed": false,
				"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
				"sourceSize": {"w":32,"h":16}
			},
			"wall_block.png":
			{
				"frame": {"x":36,"y":94,"w":32,"h":26},
				"rotated": false,
				"trimmed": false,
				"spriteSourceSize": {"x":0,"y":0,"w":32,"h":26},
				"sourceSize": {"w":32,"h":26}
			},
			"wall_block_center.png":
			{
				"frame": {"x":70,"y":94,"w":32,"h":26},
				"rotated": false,
				"trimmed": false,
				"spriteSourceSize": {"x":0,"y":0,"w":32,"h":26},
				"sourceSize": {"w":32,"h":26}
			},
			"wall_stright_horizontal.png":
			{
				"frame": {"x":2,"y":122,"w":32,"h":22},
				"rotated": false,
				"trimmed": false,
				"spriteSourceSize": {"x":0,"y":0,"w":32,"h":22},
				"sourceSize": {"w":32,"h":22}
			},
			"wall_stright_vertical.png":
			{
				"frame": {"x":36,"y":122,"w":32,"h":23},
				"rotated": false,
				"trimmed": false,
				"spriteSourceSize": {"x":0,"y":0,"w":32,"h":23},
				"sourceSize": {"w":32,"h":23}
			}}}

};
