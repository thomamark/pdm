/* Copyright 2013 Mark Thomas (mr.thomas gmail)
*/

/*************************************/
/* Global variables                  */
/*************************************/

/* Graphics */
var SPRITE_SCALE = 2;
var BASE_W = 32;
var BASE_H= 16;
var GRID_W = BASE_W*SPRITE_SCALE;
var GRID_H = BASE_H*SPRITE_SCALE;
var WALL_PAD=10*SPRITE_SCALE;
var MAX_COLS = Math.floor(900/GRID_W);
var MAX_ROWS = Math.floor(500/GRID_H);
var DEFAULT_WALL_YOFFSET = -10*SPRITE_SCALE;	//Need to get rid of this hack eventually
var DEFAULT_STARTPT_YOFFSET = -13*SPRITE_SCALE;
var DEFAULT_GOAL_YOFFSET = -GRID_H;
var DEBUG = false;
var BORDER_IMG; 
var SNAKE_IMG; 
var GOAL_IMG; 
var STAR_IMG; 
var PANDA_IMG;
var PORTAL_IMG;
var HEAD_UP_IMG;
var HEAD_DOWN_IMG;
var HEAD_LEFT_IMG;
var HEAD_RIGHT_IMG;
var TAIL_UP_IMG;
var TAIL_DOWN_IMG;
var TAIL_LEFT_IMG;
var TAIL_RIGHT_IMG;
var DOWN_TO_LEFT_IMG;
var DOWN_TO_RIGHT_IMG;
var DOWN_TO_UP_IMG;
var LEFT_TO_DOWN_IMG;
var LEFT_TO_RIGHT_IMG;
var LEFT_TO_UP_IMG;
var RIGHT_TO_DOWN_IMG;
var RIGHT_TO_LEFT_IMG;
var RIGHT_TO_UP_IMG; 
var TILES_IMG_ARRAY;
var WALL_BLOCK_IMG;
var PILLAR_IMG;
var VERTICAL_WALL_IMG;
var HORIZONTAL_WALL_IMG;
var DELETE_IMG;
var PIX_IMG;
var WALL_9S_TL_IMG;
var WALL_9S_TC_IMG;
var WALL_9S_TR_IMG;
var WALL_9S_ML_IMG;
var WALL_9S_MC_IMG;
var WALL_9S_MCTR_IMG;
var WALL_9S_MCTL_IMG;
var WALL_9S_MCBR_IMG;
var WALL_9S_MCBL_IMG;
var WALL_9S_MR_IMG;
var WALL_9S_BL_IMG;
var WALL_9S_BC_IMG;
var WALL_9S_BR_IMG;

var POST_ASSET_load_FN; //hacky way to get images to load in lb

var IMGDIR ="assets"
var AUDIODIR ="assets"
var LOAD_ASSETS = true;
var INIT_GAME = true;


/* Maze encoding variables */
var ENC_W = 2; //num of digits per point in a string
var DEFAULT_BASE = 16; //Default digit base for string output (currently hexadecimal)
var WI = 0;
var SIZEI = 1;

/* Isometric rendering */
var COS=Math.cos(0.46365);
var SIN=Math.sin(0.46365);
//var X_ORIGIN=540;
//var Y_ORIGIN=420;
var X_ORIGIN=240;
var Y_ORIGIN=400;
var ISOMETRIC = false;

/* I/O */
var LEFT_ARROW=37;
var UP_ARROW=38;
var RIGHT_ARROW=39;
var DOWN_ARROW=40;
var ESC=27;
var MOVE_DELAY=10;

/* Game */
var LEVELS = [];
var LEVELS_INITED = false;
var CURRENT_LEVEL; //Will be set during init
var TOTAL_SCORE; //Will be set during init
var LEVEL_SCORE= 0;
var EARNED_POINTS = { "5": 40, "10": 20, "15": 40, "bonus" : 1000};

var GAME_STATES = {
  UNINIT : "uninit",
  READY : "ready?",
  FAILED: "Maze failed!",
  PLAYING: "playing",
  COMPLETE: "Maze complete!",
  PAUSED: "Paused",
  GAME_COMPLETE: "Game complete!"
}

/* Game elements */
var loadFlags = [];
var gameCanvas; // canvas for moving elements
var gameStage;  
var wallCanvas;  // canvas for static background
var wallStage;	// stage for rendering walls
var dragonBgCanvas;  // canvas for dragon body
var dragonBgStage;	// stage for rendering dragon body
var tileCanvas;  // canvas for static background
var tileStage;  // canvas for static background
var game_state = GAME_STATES.UNINIT;
var PREPAUSE_GAME_STATE;
var request;
var dragon;
var maze; //the current maze
var dir;
var lastDir;
var nextDir;
var counter;
var TYPES = {
	BLANK : 0,
	WALL : 1,
	PANDA : 2,
	GOAL: 3,
	START: 4, 
}

var POINTS = {};
POINTS[TYPES.WALL] =  WallPoint;
POINTS[TYPES.PANDA] = PandaPoint;
POINTS[TYPES.GOAL] = GoalPoint;
POINTS[TYPES.START] = StartPoint;

var BLANK = undefined; //Value for ablank space.

/* Audio */
var CHANNEL_MAX = 10;   // number of simultaneous audio channels to allow
var AUDIOCHANNELS = new Array(); // Array of audio elements (initialized below)
var PLAY_FX = true; // whether or not to play sound effects
var PLAY_THEME = true; // whether or not to play sound effects
var AUDIO_SRC= {};  //Caches the playable source strings from the audio elements
var OGG_STR = "audio/ogg";
var THEME;

/*************************************/
/* Game objects                      */
/*************************************/

/*A maze object is a collection of points
 @arg img a an image object to render for this point
 @arg r the row of this object in the maze grid
 @arg c the column of this objection in the maze grid
 @arg isOnFn the function which will be called if the dragon lands on this point
 @arg pointType the type ID for this point
 @arg yoff optional yoffset in pixels
 @arg xoff optiona xoffset in pixels
*/
function Point(img,r, c, isOnFn, pointType, yoff, xoff) {
	this.img=img;
	this.r=r;
	this.c=c;
    this.isOn = isOnFn;
	this.yOffset= (yoff) ? yoff : 0;
	this.xOffset= (xoff) ? xoff : 0;
    this.obj_type=pointType;
}

/*
 * Returns an object with two components
 *   - obj.pt the first point object encoded in the given string or undefined if blank
 *   - obj.n (num_chars_read_from_s)/pad_w
 * Arguments:
 * s a string with the first pad_w digits specifying a point type
 * r the row for this point
 * c the column for this point 
 * base the base in which elements in this string have been encoded
 * pad_w the encoding width in number of digits in base for each point 
 */
function PointFactory (s, r, c, base, pad_w) {
	var base = (base) ? base : DEFAULT_BASE;
	var pad_w = (pad_w) ? pad_w : ENC_W;
	var n = 1;
	var t = parseInt(s.substring(0, pad_w), base);
	var pt = undefined;
	
	switch (t) {
		case TYPES.GOAL:
			// Next encoded digit specifies destination
			var d = parseInt(s.substring(pad_w, 2*pad_w), base);
			n += 1;
			pt = new POINTS[t](r,c,d);
			break;
		case TYPES.BLANK:
			//Blank points should keep the point undefined, so do nothing here.
			break;
		default:
			//Simple version for most points
			pt = new POINTS[t](r,c);
	}
	return {"pt" : pt, "n" : n };
}

/* Encodes the point as a string. See Maze.prototype.toString for more information. */
Point.prototype.toString = function(base, pad_w){
	//Set default vars
	var base = (base) ? base : DEFAULT_BASE;
	var pad_w = (pad_w) ? pad_w : ENC_W;
	switch(this.obj_type) {
		case TYPES.GOAL:
			if (!this.destination) {
				throw "Error: goal point at " + this.r + ", " + this.c + " has no destination!"
				return undefined;
			} else {
				return pad(Number(this.obj_type).toString(base), pad_w) + pad(Number(this.destination).toString(base), pad_w);
			}
			break;
		case undefined:
			console.log("Warning: point at " + this.r + "," + this.c + " has no type! Assuming it is blank.");
			return pad(Number(TYPES.BLANK.toString(base), pad_w));
			break;
		default:
			return pad(Number(this.obj_type.toString(base), pad_w));
	}
}

/* A Wall in the maze */
function WallPoint(r,c)  {
	return new Point(WALL_BLOCK_IMG, r, c, mazeCollision, TYPES.WALL, DEFAULT_WALL_YOFFSET);
}

/* A goal. 
 * dest: an int ID for another maze where this goal will take you.
 */ 
function GoalPoint(r, c, dest)  {
	var pt = new Point(PORTAL_IMG, r, c, mazeComplete(dest), TYPES.GOAL, DEFAULT_GOAL_YOFFSET);
	pt.destination = dest;
	return pt;
}

//A Panda
function PandaPoint(r,c) {
	return new Point(PANDA_IMG, r, c, collectBonus, TYPES.PANDA, -20, 10);
}

//Dragon starting point
function StartPoint(r,c) {
	return new Point(HEAD_DOWN_IMG, r, c, function () {}, TYPES.START, DEFAULT_STARTPT_YOFFSET);
}

//Special point for background tiles. These are used initially to render
//background images only, so there's no need for an isOn function
function TilePoint(r, c) {
   var img = TILES_IMG_ARRAY[Math.floor(Math.random()*TILES_IMG_ARRAY.length)];
   return new Point(img, r, c, null); 
}

/* A maze */
function Maze (s) {
	if (!s) { throw "Maze must be initialized with a valid string"; }
    this.doneBonuses = 0;
    this.gotBonuses = 0;
	this.s = s;
	this.load(s);
	this.xOffset = 0;
	this.yOffset = -DEFAULT_WALL_YOFFSET;
}

Maze.prototype.reset = function() {
	this.load(this.s);
}

// Sets the Maze's size in rows (height) and columns (width)
Maze.prototype.setSize = function (r,c) {
	this.rows = r;
	this.cols = c;
}

/* Sets the Dragon's starting point */
Maze.prototype.setStart = function(r,c) {
	this.sr = r;
	this.sc = c;
}

Maze.prototype.unsetStart = function() {
	this.sr = undefined;
	this.sc = undefined;	
}

//Given a row and a column, returns an array with x and y pixel coordinates
Maze.prototype.grid2canvas= function (r, c) {
	return {"x" : ((c-1) * GRID_W + this.xOffset),
            "y" : ((r-1) * GRID_H + this.yOffset)
			};
}

Maze.prototype.getCenterX = function () {
	return Math.round(((this.cols)*GRID_W+this.xOffset)/2);
}

Maze.prototype.getCenterY = function () {
	return Math.round(((this.rows)*GRID_H+this.yOffset)/2);
}

Maze.prototype.getStart = function () {
 	return [this.sr, this.sc];
}

Maze.prototype.collectBonus = function(){
    this.gotBonuses +=1;
    LEVEL_SCORE += EARNED_POINTS['bonus'];
}

Maze.prototype.complete = function () {
   this.doneBonuses = this.gotBonuses;
}

Maze.prototype.addBorders = function () {
	for (var i =1; i<=this.rows; i++) {
		if (!this.hasPoint(i,1)) {
			this.addPoint(new WallPoint(i,1));
		}
		if (!this.hasPoint(i,this.cols)) {
			this.addPoint(new WallPoint(i,this.cols));
		}
		for (var j=1; j<=this.cols; j++){
			if (!this.hasPoint(1, j)) {
				this.addPoint(new WallPoint(1,j));				
			}
			if (!this.hasPoint(this.rows,j)){
				this.addPoint(new WallPoint(this.rows,j));
			}
		}
	}
	
	this.fixWallImages();
}

/* Deletes all objects on the borders of the maze */
Maze.prototype.removeBorders = function () {
	for (var i =1; i<=this.rows; i++) {
			this.removePoint(i,1);
			this.removePoint(i,this.cols);
		for (var j=1; j<=this.cols; j++){
				this.removePoint(1,j);				
				this.removePoint(this.rows,j);
		}
	}
}

//Fn for extending the length of a hex string to <width> chars
function pad (hexstr, width) {
	var p = width - hexstr.length;
	if (p >0) { return Array(p+1).join("0")+hexstr; }
	else if (p<0) { throw "Too long to encode into a Maze string "+hexstr;}
	else { return hexstr; }
};

/* Returns a string representation of this maze
*  Maze string representation:
*  1 hex digit for number of hex digits per square (N)
*  N hex digits for num rows (R)
*  N hex digits for num cols (C)
*  N hex digits for each of the RxC squares in the maze
*/
Maze.prototype.toString = function () {
	var s = "" + Number(ENC_W).toString(DEFAULT_BASE) + 
					pad(Number(this.rows).toString(DEFAULT_BASE), ENC_W) +
					pad(Number(this.cols).toString(DEFAULT_BASE),ENC_W);
	try {
		for (var i = 0; i< this.rows; i++) {
			for ( var j = 0; j<this.cols; j++) {
				s+= (this.points[i][j]) ? this.points[i][j].toString(DEFAULT_BASE, ENC_W) : pad( Number(TYPES.BLANK).toString(DEFAULT_BASE), ENC_W);
			}
		}
	} catch (err){
		console.log("Error at row " + (i+1) + " and column " + (j+1) + 
			"\n"+ err.message);
		return null;
	}
	return s;
}

/* Constructs a maze given a string rep of a maze (see toString above) */
Maze.prototype.load = function(s) {
	try {
		var base = 16; //TODO: need to read this from the string.
		var w      = parseInt(s.charAt(WI), base);
		var rows   = parseInt(s.substring(SIZEI,SIZEI+w), base);
		var cols   = parseInt(s.substring(SIZEI+w, SIZEI+2*w), base); 
		var head_len  = SIZEI+2*w;
		//FIXME: not as easy to verify length of string when points contain extra info (e.g. goal points)
		// if (s.length != head_len + rows*cols*w) {
		// 	throw "Invalid maze string length. Expected: "+(head_len+rows*cols*w) + " Actual: " + s.length;
		// }
		this.setSize(rows, cols);
		this.initPoints();
		var r = 1;
		var c = 1;
		for (var i = head_len; i < s.length; i+=w) {
			var pt_n    = PointFactory(s.substring(i, s.length), r, c, base, w);
			i += (pt_n.n - 1) * w;	//If we read more than one encoded char, advance the incr accordingly
			if (pt_n.pt) { 
				this.addPoint(pt_n.pt); 
			}		
			//Keep track of which row/column we're on. Note that maze is loaded in columns-first order.
			c += 1;
			if (c > this.cols) {
				c = 1;
				r += 1;
			}
		}
		if (!(this.getStart()[0] && this.getStart()[1])) {
			throw "Maze has no starting point defined!";
		}
	} catch (err) {
		throw "Error loading maze: " + err;
	}
	this.fixWallImages();
}

/* initializes the points array for this Maze */
Maze.prototype.initPoints = function() {
	if (!(this.rows && this.cols)) {
		throw "Rows and columns are undefined. Cannot initialize points.";
	}
	this.points = [];
	this.gotBonuses = 0;
	for (var i=0; i<this.rows; i++){
		this.points[i]=[];
		this.points[i][this.cols-1]=BLANK;
 	}
}

Maze.prototype.fixWallImages = function() {
    for (var i = 0; i<this.rows; i++) {
        for (var j= 0; j<this.cols;j++) {
           //We only care about walls, so skip everything else
//            try {
//           		if (!this.points[i][j] || !this.isType(i,j,TYPES.WALL) ||
//									!this.isType(i,j,TYPES.GOAL)) {
//           		     continue;
//           		 }
//            } catch(err) {
//                console.log("Error fixing wall images! i="+i+" j="+j);
//            }


			if (this.isType(i,j,TYPES.GOAL) && 
						(i == 0 || i == this.rows-1 || j == 0 || j == this.cols-1)) {
						this.points[i][j].img = (DEBUG) ? PIX_IMG : undefined;
	          			this.points[i][j].yOffset=0;
			} else if (this.isType(i,j,TYPES.WALL)) {
					//TODO: fixme! Reset wall offset
					this.points[i][j].yOffset=DEFAULT_WALL_YOFFSET;
					//Build 9-slice
					if (this.isType(i-1,j-1,TYPES.WALL) &&
							this.isType(i-1,j,TYPES.WALL) &&
							this.isType(i-1,j+1,TYPES.WALL) &&
							this.isType(i,j-1,TYPES.WALL) &&
							this.isType(i,j,TYPES.WALL) &&
							this.isType(i,j+1,TYPES.WALL) &&
							this.isType(i+1,j-1,TYPES.WALL) &&
							this.isType(i+1,j,TYPES.WALL) &&
							this.isType(i+1,j+1,TYPES.WALL)) {
								//Middle-center wall
								this.points[i][j].img=WALL_9S_MC_IMG;
				           //   this.points[i][j].yOffset=0;
							} else if (
								this.isType(i-1,j-1,TYPES.WALL) &&
								this.isType(i-1,j,TYPES.WALL) &&
								this.isType(i-1,j+1,TYPES.WALL) &&
								this.isType(i,j-1,TYPES.WALL) &&
								this.isType(i,j,TYPES.WALL) &&
								this.isType(i,j+1,TYPES.WALL) &&
								!(this.isType(i+1,j-1,TYPES.WALL) &&
									this.isType(i+1,j,TYPES.WALL)) &&
								!(this.isType(i+1,j+1,TYPES.WALL) && 
									this.isType(i+1,j,TYPES.WALL))) {
									//Bottom-center wall
									this.points[i][j].img=WALL_9S_BC_IMG;
	            	  				//this.points[i][j].yOffset=0;
							} else if (
								!(this.isType(i-1,j-1,TYPES.WALL) &&
									this.isType(i-1,j,TYPES.WALL)) &&
								!(this.isType(i-1,j+1,TYPES.WALL) &&
									this.isType(i-1,j,TYPES.WALL)) &&
								this.isType(i,j-1,TYPES.WALL) &&
								this.isType(i,j,TYPES.WALL) &&
								this.isType(i,j+1,TYPES.WALL) &&
								this.isType(i+1,j-1,TYPES.WALL) &&
								this.isType(i+1,j,TYPES.WALL) &&
								this.isType(i+1,j+1,TYPES.WALL)) {
									//top-center wall
									this.points[i][j].img=WALL_9S_TC_IMG;
	            	  				//this.points[i][j].yOffset=0;
							} else if (
								!(this.isType(i-1,j-1,TYPES.WALL) &&
									this.isType(i,j-1,TYPES.WALL)) &&
								this.isType(i-1,j,TYPES.WALL) &&
								this.isType(i-1,j+1,TYPES.WALL) &&
								this.isType(i,j,TYPES.WALL) &&
								this.isType(i,j+1,TYPES.WALL) &&
								!(this.isType(i+1,j-1,TYPES.WALL) &&
									this.isType(i,j-1,TYPES.WALL)) &&
								this.isType(i+1,j,TYPES.WALL) &&
								this.isType(i+1,j+1,TYPES.WALL)) {
									//middle-left wall
									this.points[i][j].img=WALL_9S_ML_IMG;
	            	  				//this.points[i][j].yOffset=0;
							} else if (
								this.isType(i-1,j,TYPES.WALL) &&
								this.isType(i-1,j+1,TYPES.WALL) &&
								!(this.isType(i-1,j-1,TYPES.WALL) &&
								  this.isType(i,j-1,TYPES.WALL)) &&
								this.isType(i,j,TYPES.WALL) &&
								this.isType(i,j+1,TYPES.WALL) &&
								!(this.isType(i+1,j,TYPES.WALL) &&
								  this.isType(i+1,j+1,TYPES.WALL))) {
									//bottom-left wall
									this.points[i][j].img=WALL_9S_BL_IMG;
	            	  				//this.points[i][j].yOffset=0;
							} else if (
								!(this.isType(i-1,j,TYPES.WALL) &&
									this.isType(i-1,j+1,TYPES.WALL)) &&
								!(this.isType(i,j-1,TYPES.WALL) &&
									this.isType(i+1,j-1,TYPES.WALL)) &&
								this.isType(i,j,TYPES.WALL) &&
								this.isType(i,j+1,TYPES.WALL) &&
								this.isType(i+1,j,TYPES.WALL) &&
								this.isType(i+1,j+1,TYPES.WALL)) {
									//top-left wall
									this.points[i][j].img=WALL_9S_TL_IMG;
	            	  				//this.points[i][j].yOffset=0;
							} else if (
								this.isType(i-1,j-1,TYPES.WALL) &&
								this.isType(i-1,j,TYPES.WALL) &&
								!(this.isType(i-1,j+1,TYPES.WALL) &&
									this.isType(i,j+1,TYPES.WALL)) &&
								this.isType(i,j-1,TYPES.WALL) &&
								this.isType(i,j,TYPES.WALL) &&
								this.isType(i+1,j-1,TYPES.WALL) &&
								this.isType(i+1,j,TYPES.WALL) &&
								!(this.isType(i,j+1,TYPES.WALL) &&
								this.isType(i+1,j+1,TYPES.WALL))) {
									//middle-right wall
									this.points[i][j].img=WALL_9S_MR_IMG;
	            	  				//this.points[i][j].yOffset=0;
							} else if (
								this.isType(i-1,j-1,TYPES.WALL) &&
								this.isType(i-1,j,TYPES.WALL) &&
								!(this.isType(i-1,j+1,TYPES.WALL) &&
									this.isType(i,j+1,TYPES.WALL)) &&
								this.isType(i,j-1,TYPES.WALL) &&
								this.isType(i,j,TYPES.WALL) &&
								!(this.isType(i+1,j-1,TYPES.WALL) &&
									this.isType(i+1,j,TYPES.WALL))) {
									//bottom-right wall
									this.points[i][j].img=WALL_9S_BR_IMG;
	            	  				//this.points[i][j].yOffset=0;
							} else if (
								!(this.isType(i-1,j-1,TYPES.WALL) &&
									this.isType(i-1,j,TYPES.WALL)) &&
								this.isType(i,j-1,TYPES.WALL) &&
								this.isType(i,j,TYPES.WALL) &&
								!(this.isType(i,j+1,TYPES.WALL) &&
									this.isType(i+1,j+1,TYPES.WALL)) &&
								this.isType(i+1,j-1,TYPES.WALL) &&
								this.isType(i+1,j,TYPES.WALL)) {
									//top-right wall
									this.points[i][j].img=WALL_9S_TR_IMG;
	            	  				//this.points[i][j].yOffset=0;
							} else if (this.isType(i-1,j-1,TYPES.WALL) &&
                this.isType(i-1,j,TYPES.WALL) &&
                this.isType(i-1,j+1,TYPES.WALL) &&
                this.isType(i,j-1,TYPES.WALL) &&
                this.isType(i,j,TYPES.WALL) &&
                this.isType(i,j+1,TYPES.WALL) &&
                this.isType(i+1,j-1,TYPES.WALL) &&
                this.isType(i+1,j,TYPES.WALL) &&
                !this.isType(i+1,j+1,TYPES.WALL)) {
                    //9-slice with bottom-right missing
                    this.points[i][j].img = WALL_9S_MCBR_IMG;
                    //this.points[i][j].yOffset=0;
              } else if (this.isType(i-1,j-1,TYPES.WALL) &&
                this.isType(i-1,j,TYPES.WALL) &&
                this.isType(i-1,j+1,TYPES.WALL) &&
                this.isType(i,j-1,TYPES.WALL) &&
                this.isType(i,j,TYPES.WALL) &&
                this.isType(i,j+1,TYPES.WALL) &&
                !this.isType(i+1,j-1,TYPES.WALL) &&
                this.isType(i+1,j,TYPES.WALL) &&
                this.isType(i+1,j+1,TYPES.WALL)) {
                    //9-slice with bottom-left missing
                    this.points[i][j].img = WALL_9S_MCBL_IMG;
                    //this.points[i][j].yOffset=0;
              } else if (this.isType(i-1,j-1,TYPES.WALL) &&
                this.isType(i-1,j,TYPES.WALL) &&
                !this.isType(i-1,j+1,TYPES.WALL) &&
                this.isType(i,j-1,TYPES.WALL) &&
                this.isType(i,j,TYPES.WALL) &&
                this.isType(i,j+1,TYPES.WALL) &&
                this.isType(i+1,j-1,TYPES.WALL) &&
                this.isType(i+1,j,TYPES.WALL) &&
                this.isType(i+1,j+1,TYPES.WALL)) {
                    //9-slice with top-right missing
                    this.points[i][j].img = WALL_9S_MCTR_IMG;
                    //this.points[i][j].yOffset=0;
              } else if (
                !this.isType(i-1,j-1,TYPES.WALL) &&
                this.isType(i-1,j,TYPES.WALL) &&
                this.isType(i-1,j+1,TYPES.WALL) &&
                this.isType(i,j-1,TYPES.WALL) &&
                this.isType(i,j,TYPES.WALL) &&
                this.isType(i,j+1,TYPES.WALL) &&
                this.isType(i+1,j-1,TYPES.WALL) &&
                this.isType(i+1,j,TYPES.WALL) &&
                this.isType(i+1,j+1,TYPES.WALL)) {
                    //9-slice with top-left missing
                    this.points[i][j].img = WALL_9S_MCTL_IMG;
                    //this.points[i][j].yOffset=0;
              } else if (this.isType(i,j-1,TYPES.WALL) &&
								this.isType(i, j+1, TYPES.WALL) &&
								(this.isType(i+1, j, TYPES.WALL) ||
									this.isType(i-1, j, TYPES.WALL))) {
											//Fix T-shaped and inverse T-shaped walls
											this.points[i][j].img=WALL_BLOCK_IMG;
	                						//this.points[i][j].yOffset=0;
							 } else if (this.isType(i-1,j,TYPES.WALL) && 
											this.isType(i+1,j,TYPES.WALL) &&
											(this.isType(i,j-1,TYPES.WALL) ||
													this.isType(i,j+1,TYPES.WALL))) {
													//Fix -| and |- walls
													this.points[i][j].img = WALL_BLOCK_IMG;
                      								//this.points[i][j].yOffset=0;
							} else if (this.isType(i-1,j,TYPES.WALL) &&
							  this.isType(i+1,j,TYPES.WALL) &&
							  !this.isType(i, j-1, TYPES.WALL) &&
								!this.isType(i,j+1, TYPES.WALL)) {
                    				//Fix vertical wall image
				                    this.points[i][j].img=VERTICAL_WALL_IMG;
           	  } else if (this.isType(i,j-1,TYPES.WALL) &&
								this.isType(i, j+1, TYPES.WALL) &&
								!this.isType(i-1,j, TYPES.WALL) &&
								!this.isType(i+1,j, TYPES.WALL)) {
                    //Fix horizontal wall image
                    this.points[i][j].img=HORIZONTAL_WALL_IMG;
                    this.points[i][j].yOffset=-10;
              } else {
						//default to the pillar wall
						this.points[i][j].img = WALL_BLOCK_IMG; 
						//this.points[i][j].yOffset=-20;
        		}
		}
    }
  } 
}

/**
* Given a row, column and and object type, returns true if the point at
* at this.points[i][j] has obj_type==type
* Note that maze rows and columns are not 0-indexed (first row/col is 1,1).
*/
Maze.prototype.isType = function (i,j,type) {
	return (i>=0 && i<this.rows && j>=0 && j<this.cols &&
					this.points[i][j]!=undefined &&
					this.points[i][j].obj_type==type);
}

// Adds a point object to this Maze
Maze.prototype.addPoint = function(pt) {
	// Ensure you can only add points within the maze
	if (pt.r >0 && pt.r <= this.rows && pt.c > 0 && pt.c <= this.cols) {
		switch(pt.obj_type) {
			case TYPES.START:
				//We don't add start points to the maze
				this.setStart(pt.r, pt.c);
				break;
			default:
				this.points[pt.r-1][pt.c-1] = pt;			
		}
    	return pt;
	}
}

/* Removes a point object from this Maze */
Maze.prototype.removePoint = function(r, c) {
	if (r >0 && r <= this.rows && c > 0 && c <= this.cols) {
		var pt = this.points[r-1][c-1];
		switch(pt.obj_type) {
			case TYPES.START:
				//If you're removing a start, unset the start position
				this.unsetStart();
				break;
			default:
				this.points[r-1][c-1]=BLANK;			
		}
		return pt;
	}
}

/*
* Returns a point at r, c in the maze or undefined if none exists
*/
Maze.prototype.hasPoint = function(r, c) {
	return this.points[r-1][c-1];
}

Maze.prototype.getPoint = function(r,c) {
	if (r<=this.rows && r > 0 && c <= this.cols && c > 0) {
		return this.points[r-1][c-1];
	}
}

Maze.prototype.isOn = function (r, c) {
        var pt = this.getPoint(r,c);
        if (pt && pt.isOn) {
                pt.isOn();
        }
}

Maze.prototype.renderTiles = function (stage) {
	for (var i =0; i<this.rows; i++) {
		for (var j =0; j<this.cols; j++) {
            renderObject(new TilePoint(i+1, j+1), stage);
		}
	}
}

Maze.prototype.render = function (stage) {
	for (var i =0; i<this.rows; i++) {
		for (var j =0; j<this.cols; j++) {
            //render the background tiles the first time we render the maze.
            // if (game_state != GAME_STATES.FAILED) {
            //      renderObject(new TilePoint(i+1, j+1),tileStage);
            //  }
 			if (this.points[i][j]) {
				renderObject(this.points[i][j], stage);
			}
		}
	}
}

/*************************************/
/* Maze events                       */
/*************************************/

function cleanUp() {
    printState();
    stopGameLoop();
}

function mazeCollision() {
    game_state = GAME_STATES.FAILED;
    stopMusic();
    playMultiSound('defeat');
    LEVEL_SCORE = 0;
    cleanUp();
}

function mazeComplete(dest) {
	return function () {
 	    game_state = GAME_STATES.COMPLETE;
	    stopMusic();
	    playMultiSound('victory');
	    maze.complete();
	    TOTAL_SCORE += LEVEL_SCORE;
	    LEVEL_SCORE = 0;
	    CURRENT_LEVEL = dest;
	    saveGameState();
	    renderScore();
	    cleanUp();
	}
}

function collectBonus() {
    maze.collectBonus();
    playMultiSound('pick_up');
}

function gameComplete() {
    game_state = GAME_STATES.GAME_COMPLETE;
    CURRENT_LEVEL=0;
    for (var i=0; i<LEVELS.length;i++) {
        LEVELS[i].initPoints();
    }
    cleanUp();
}


/*************************************/
/* Initialization functions          */
/*************************************/

function init(fn) { 
    POST_ASSET_LOAD_FN = fn;

    //Short-circuit if we don't want to load assets.
    if (!LOAD_ASSETS) { return;}
    loadAssets(); 


}

function saveGameState() {
  $.cookie("CurrentLevel",CURRENT_LEVEL);
  $.cookie("TotalScore",TOTAL_SCORE);
}

function initGameState() {
  CURRENT_LEVEL = $.cookie("CurrentLevel") ? parseInt($.cookie("CurrentLevel")) : 0;
  TOTAL_SCORE = $.cookie("TotalScore") ? parseInt($.cookie("TotalScore")) : 0;
}

function loadAssets() {
    if (ISOMETRIC) {
        GRID_W = 28;
        GRID_H = 28;
	    BORDER_IMG = createImgAsset("border", 
            "<%= asset_path('border_iso.png') %>");
	    SNAKE_IMG = createImgAsset("snake", 
            "<%= asset_path('snake_iso.png') %>");
	    GOAL_IMG = createImgAsset("goal",
            "<%= asset_path('goal_iso.png') %>");
    } else {
//	    BORDER_IMG = createImgAsset("border",
//            "<%= asset_path('border_19x19.png') %>");
//	    SNAKE_IMG = createImgAsset("dragon",
//            "<%= asset_path('mover_19x19.png') %>");
//	    GOAL_IMG = createImgAsset("goal",
//            "<%= asset_path('goal_19x19.png') %>");
//	    STAR_IMG = createImgAsset("star",
//            "<%= asset_path('star_19x19.png') %>");
	    PANDA_IMG = createImgAsset("panda",
            "<%= asset_path('Panda.png') %>");
	    PORTAL_IMG = createImgAsset("portal",
            "<%= asset_path('Goal_1.png') %>");
	    HEAD_UP_IMG = createImgAsset("head_up",
            "<%= asset_path('Head_Up.png') %>");
	    HEAD_DOWN_IMG = createImgAsset("head_down",
            "<%= asset_path('Head_Down.png') %>");
	    HEAD_LEFT_IMG = createImgAsset("head_left",
            "<%= asset_path('Head_Left.png') %>");
	    HEAD_RIGHT_IMG = createImgAsset("head_right",
            "<%= asset_path('Head_Right.png') %>");

	    TAIL_UP_IMG = createImgAsset("tail_up",
            "<%= asset_path('Tail_Up.png') %>");
	    TAIL_DOWN_IMG = createImgAsset("tail_down",
            "<%= asset_path('Tail_Down.png') %>");
	    TAIL_LEFT_IMG = createImgAsset("tail_left",
            "<%= asset_path('Tail_Right.png') %>");
	    TAIL_RIGHT_IMG = createImgAsset("tail_right",
            "<%= asset_path('Tail_Left.png') %>");
        DOWN_TO_LEFT_IMG = createImgAsset("dtl",
            "<%= asset_path('Body_UpToLeft.png') %>");
        DOWN_TO_RIGHT_IMG = createImgAsset("dtr",
            "<%= asset_path('Body_UpToRight.png') %>");
        DOWN_TO_UP_IMG = createImgAsset("dtu",
            "<%= asset_path('Body_DownToUp.png') %>");
        LEFT_TO_DOWN_IMG= createImgAsset("ltd",
            "<%= asset_path('Body_RightToDown.png') %>");
        LEFT_TO_RIGHT_IMG= createImgAsset("ltr",
            "<%= asset_path('Body_RightToLeft.png') %>");
        LEFT_TO_UP_IMG= createImgAsset("ltu",
            "<%= asset_path('Body_RightToUp.png') %>");
        RIGHT_TO_DOWN_IMG= createImgAsset("rtd",
            "<%= asset_path('Body_LeftToDown.png') %>");
        RIGHT_TO_LEFT_IMG= createImgAsset("rtl",
            "<%= asset_path('Body_LeftToRight.png') %>");
        RIGHT_TO_UP_IMG= createImgAsset("rtu",
            "<%= asset_path('Body_UpToLeft.png') %>");
        UP_TO_DOWN_IMG= createImgAsset("utd",
            "<%= asset_path('Body_UpToDown.png') %>");
        UP_TO_LEFT_IMG= createImgAsset("utl",
            "<%= asset_path('Body_DownToLeft.png') %>");
        UP_TO_RIGHT_IMG= createImgAsset("utr",
            "<%= asset_path('Body_DownToRight.png') %>");

        TILES_IMG_ARRAY= [];
        TILES_IMG_ARRAY.push(createImgAsset("tile_1",
              "<%= asset_path('tiles.png') %>"));
        TILES_IMG_ARRAY.push(createImgAsset("tile_2",
              "<%= asset_path('tiles_2.png') %>"));
        TILES_IMG_ARRAY.push(createImgAsset("tile_3",
              "<%= asset_path('tiles_3.png') %>"));
        TILES_IMG_ARRAY.push(createImgAsset("tile_4",
              "<%= asset_path('tiles_4.png') %>"));

				//load wall images
        VERTICAL_WALL_IMG = createImgAsset("vw",
            "<%= asset_path('wall_stright_horizontal.png') %>");
        HORIZONTAL_WALL_IMG = createImgAsset("hw",
            "<%= asset_path('wall_stright_vertical.png') %>");
	    	WALL_BLOCK_IMG = createImgAsset("pillar",
            "<%= asset_path('wall_block.png') %>");

				WALL_9S_TL_IMG = createImgAsset('wall_9s_tl', 
            "<%= asset_path('wall_9slice_tl.png') %>");
				WALL_9S_TC_IMG = createImgAsset('wall_9s_tc', 
				    "<%= asset_path('wall_9slice_tc.png') %>");
				WALL_9S_TR_IMG= createImgAsset('wall_9s_tr', 
				    "<%= asset_path('wall_9slice_tr.png') %>");
				WALL_9S_ML_IMG= createImgAsset('wall_9s_ml', 
				    "<%= asset_path('wall_9slice_ml.png') %>");
				WALL_9S_MC_IMG = createImgAsset('wall_9s_mc', 
				    "<%= asset_path('wall_9slice_mc.png') %>");
				WALL_9S_MR_IMG= createImgAsset('wall_9s_mr', 
				    "<%= asset_path('wall_9slice_mr.png') %>");
				WALL_9S_BL_IMG= createImgAsset('wall_9s_bl', 
				    "<%= asset_path('wall_9slice_bl.png') %>");
				WALL_9S_BC_IMG= createImgAsset('wall_9s_bc', 
				    "<%= asset_path('wall_9slice_bc.png') %>");
				WALL_9S_BR_IMG= createImgAsset('wall_9s_br', 
            "<%= asset_path('wall_9slice_br.png') %>");
	
				//All the corner walls within a 9 slice are the same right now.
				//FIXME: add real images for 9-slice corners
				WALL_9S_MCTR_IMG= 
						WALL_9S_MCTL_IMG= 
						WALL_9S_MCBR_IMG= 
						WALL_9S_MCBL_IMG=
						WALL_9S_MC_IMG;

				//Only used in level builder
        		DELETE_IMG = createImgAsset("delete", 
		            "<%= asset_path('delete.png') %>");
				PIX_IMG = createImgAsset('pix_1x1', "<%= asset_path('1x1.gif') %>");

    }
}


function createImgAsset($id,$src) {
	var img=new Image();
	loadFlags[$id]=0;
	img.onload=function(){onAssetLoaded($id);};
	img.src=$src;
//    img.height = GRID_H;
//    img.width = GRID_W;
	return img;
}

function onAssetLoaded($asset_id) {
	loadFlags[$asset_id]=1;
    //Don't start the game until everything's been loaded
	for(flag in loadFlags) {
		if(!loadFlags[flag]) {return;}
	}
    //Only continue if we want to continue the game
    if (POST_ASSET_LOAD_FN) {POST_ASSET_LOAD_FN();}
    if (!INIT_GAME) { return;}
	game_init();
}

function game_init() {

    //Init stuff you'll need if you're playing
    initGameState();
    //Init configuration panel
    $("input[name=speed]:radio").click(function() {changeSpeed(this.value);});
    $("#ctrl_fx").click(function() {toggleFX(this.checked);});
    $("#ctrl_music").click(function() {toggleMusic(this.checked)});
    $("#options_link").click(function() {toggleOptions()});
    $("#options_done").click(function() {toggleOptions()});
    $("#quit").click(function() {quit()});
    initSound();


    //Set up graphics
	gameCanvas = document.getElementById('maze-canvas');
	wallCanvas = document.getElementById('maze-canvas-background');
	dragonBgCanvas = document.getElementById('maze-canvas-dragon-bg');
    tileCanvas = document.getElementById('tile-canvas');
	gameStage = gameCanvas.getContext("2d");
	wallStage = wallCanvas.getContext("2d");
	dragonBgStage = dragonBgCanvas.getContext("2d");
	tileStage = tileCanvas.getContext("2d");
	var hpx = MAX_ROWS*GRID_H+WALL_PAD;
    var wpx = MAX_COLS*GRID_W;
    $(gameCanvas).attr("height", hpx);
    $(gameCanvas).attr("width", wpx);
    $(wallCanvas).attr("height", hpx);
    $(wallCanvas).attr("width", wpx);
    $(dragonBgCanvas).attr("height", hpx);
    $(dragonBgCanvas).attr("width", wpx);
    $(tileCanvas).attr("height", hpx);
    $(tileCanvas).attr("width", wpx);
	counter = 0;
	CanvasTextFunctions.enable(gameStage);
    init_levels();
    maze_init();
}

function maze_init(){
    if(game_state == GAME_STATES.COMPLETE) {
		tileStage.clearRect(0,0,wallCanvas.width,wallCanvas.height);
        if (CURRENT_LEVEL>=LEVELS.length){
            gameComplete();
            return;
        }

    } 

    if (game_state != GAME_STATES.FAILED) {
      if (CURRENT_LEVEL >= LEVELS.length) { 
        //Ran into messed up cookie values.
        CURRENT_LEVEL = 0; 
        TOTAL_SCORE = 0;
      }
	  	maze = LEVELS[CURRENT_LEVEL];
    }
    maze.reset();
	if (game_state == GAME_STATES.COMPLETE || game_state == GAME_STATES.UNINIT) {
		maze.renderTiles(tileStage);
	}

	game_state = GAME_STATES.READY;
    printState();
    renderScore();
	var rc = maze.getStart();
	dragon = maze.addPoint(new Point(HEAD_DOWN_IMG, rc[0], rc[1], function () {}));
//	dragon = new StartPoint(rc[0], rc[1]);
	maze.render(wallStage);
    dir="start";
    startMusic();
	startGameLoop();
}

/*************************************/
/* Configuation functions            */
/*************************************/

function changeSpeed(s) {
     //console.log("Changing speed from "+MOVE_DELAY+" to "+s);
     MOVE_DELAY=parseInt(s);
}

/* Music and sound effects functions */

//Set up audio channels for seamless, simultaneous play of multiple sounds
//Thanks to http://www.storiesinflight.com/html5/audio.html 
function initSound() {
    //Code courtesy of http://html5doctor.com/native-audio-in-the-browser/
    var myAudio = $('#theme'); 
    if (myAudio.canPlayType) {
       // Currently canPlayType(type) returns: "", "maybe" or "probably" 
       //canPlayMp3 = !!myAudio.canPlayType && 
       //                 "" != myAudio.canPlayType('audio/mpeg');
       var canPlayOgg = !!myAudio.canPlayType && 
                        "" != myAudio.canPlayType('audio/ogg; codecs="vorbis"');
    }
    //Cache the appropriate audio source
    $.each($("audio"), function (i, v) {
                $.each($(v).children(), function (i2, v2) {
                        //Use ogg by default because it's smaller and open =)
                        if (v2.type == OGG_STR && canPlayOgg) {
                            AUDIO_SRC[v.id] = v2.src;
                        } else if (!canPlayOgg) {
                            //Otherwise set to MP3
                            AUDIO_SRC[v.id] = v2.src;
                        }
                    }
                )});
    
    for (a=0;a<CHANNEL_MAX;a++) { // prepare the channels
        AUDIOCHANNELS[a] = new Array();
        AUDIOCHANNELS[a]['channel'] = new Audio();// create a new audio object
        AUDIOCHANNELS[a]['finished'] = -1;// expected end time for this channel
    }
    //Workaround for Firefox and Safari
    THEME = new Audio();
    THEME.load();
    THEME.src=AUDIO_SRC['theme'];
    THEME.volume=.3;
    THEME.loop="loop";
    //Loop the theme track
    $(THEME).bind('ended', function() {this.currentTime=0});
}

function startMusic() {
    if (PLAY_THEME) {
        THEME.play();
        //$('#theme')[0].load();
        //$('#theme').bind('ended', function() {this.currentTime=0});
        //$('#theme')[0].volume=.3;
        //$('#theme')[0].play();
    }
}

function stopMusic() {
    //$('#theme')[0].pause();
    THEME.pause();
}

function toggleFX(on) {
    PLAY_FX = on;
}

function toggleMusic(on) {
    PLAY_THEME = on;
    if (PLAY_THEME) {
        startMusic();
    } else {
        stopMusic();
    }
}

function toggleOptions() {
  if (game_state == GAME_STATES.PAUSED) {
		unpause();
	} else {
		pause();
	}
  $("#lightbox").toggle();
}

function deleteCookie() {
  $.removeCookie("CurrentLevel");
  $.removeCookie("TotalScore");
}

function quit() {
  deleteCookie();
  window.location = "/";
}

//Plays multiple sounds simultaneously a bit more smoothly than would happen normally.
//Courtesy of http://www.storiesinflight.com/html5/audio.html. Thanks!
function playMultiSound(s) {
    if (PLAY_FX) {
        for (a=0;a<AUDIOCHANNELS.length;a++) {
            thistime = new Date();
            if (AUDIOCHANNELS[a]['finished'] < thistime.getTime()) {            // is this channel finished?
                AUDIOCHANNELS[a]['finished'] = thistime.getTime() + document.getElementById(s).duration*1000;
                AUDIOCHANNELS[a]['channel'].src = AUDIO_SRC[s];
                AUDIOCHANNELS[a]['channel'].load();
                AUDIOCHANNELS[a]['channel'].play();
                break;
            }
        }
    }
}


/*************************************/
/* Mazes                             */
/*************************************/

function init_levels() {
	LEVELS.push(new Maze("20f0e010101010101010101010101010101040000000000000000000000010100000000000000000000000001010000000000000100000000000101000000000000010000000000010100000000000001000000000001010000000002000100000200000301010000000000000100000000000301010000000000000100000000000301010000000000000100000000000101000000000000010000000000010100000000000001000000000001010000000000000000000000000101000000000000000000000000010101010101010101010101010101"));
	LEVELS.push(new Maze("20f0e0101010101010101010101010101010000000000000000000000000101020100000000000000000000010100010001010101010101010001010001000100000000000001000101000100010001010101000100010100010001000104000100010001010001000100000000010001000101000100010101010101000100010100010000000000000000010001010001000000000000000001000101000101010101010101010100010100000000000000000000000003020100000000000000000000000003020101010101010101010101010101"));
	LEVELS.push(new Maze("20f0e01010101010101010101010101010100000000000200000000000001010000000000000000000000000101000100000001000000010000010100020001000200010002000001010000000000000000000000000300010401000000010000000100000300010000000100000001000000000300010000000200000002000000000300010001000000010000000100000101000000010000000100000000010100000000000000000000000001010000000000020000000000000101000000000000000000000000010101010101010101010101010101"));
}

/*************************************/
/* I/O functions                     */
/*************************************/

function onKeyDown(evt){
	evt.preventDefault();
	switch(game_state) {
		case GAME_STATES.PAUSED:
			switch(evt.keyCode) {
				case ESC:
					toggleOptions();
					break;
				default:
					//Do nothing
			}
			break;
		case GAME_STATES.READY:
			switch(evt.keyCode) {
				case LEFT_ARROW:
				case RIGHT_ARROW:
				case DOWN_ARROW:
				case UP_ARROW:
					gameStage.clearRect(0,0,gameCanvas.width,gameCanvas.height);
					//wallStage.clearRect(0,0,wallCanvas.width,wallCanvas.height);
					//maze.render(wallStage);
					//renderObject(dragon,gameStage);
					renderObject(dragon,wallStage);
					game_state=GAME_STATES.PLAYING;
					break;
				default:
					//Do nothing
			}
		case GAME_STATES.PLAYING:
			switch (evt.keyCode) {
	         	//Store in nextDir to save the last direction
				case LEFT_ARROW:
					nextDir = "left";
					break;
				case RIGHT_ARROW:
					nextDir = "right";
					break;
				case DOWN_ARROW:
					nextDir = "down";
					break;
				case UP_ARROW:
					nextDir = "up";
					break;
				case ESC:
					toggleOptions();
					break;
				default:
					//Do nothing
			}
			break;
		default:
			switch(evt.keyCode) {
				case LEFT_ARROW:
				case RIGHT_ARROW:
				case DOWN_ARROW:
				case UP_ARROW:
					//Only start if you've picked a direction to go in
					gameStage.clearRect(0,0,gameCanvas.width,gameCanvas.height);
					dragonBgStage.clearRect(0,0,dragonBgCanvas.width,dragonBgCanvas.height);
					wallStage.clearRect(0,0,wallCanvas.width,wallCanvas.height);
					maze_init();
					break;
				default:
					//Do nothing
			}
	}
}

/*************************************/
/* Game loop control functions       */
/*************************************/

// Thanks Paul Irish. shim layer with setTimeout fallback
//Note this seems to break in Firefox and Safari, so I'm not using it.
//window.requestAnimFrame = (function(){
//  return  window.requestAnimationFrame       || 
//          window.webkitRequestAnimationFrame || 
//          window.mozRequestAnimationFrame    || 
//          window.oRequestAnimationFrame      || 
//          window.msRequestAnimationFrame     || 
//          function(/* function */ callback, /* DOMElement */ element){
//            window.setTimeout(callback, 1000 / 60);
//          };
//})();

//window.cancelRequestAnimFrame = ( function() {
//    return window.cancelAnimationFrame          ||
//        window.webkitCancelRequestAnimationFrame    ||
//        window.mozCancelRequestAnimationFrame       ||
//        window.oCancelRequestAnimationFrame     ||
//        window.msCancelRequestAnimationFrame        ||
//        window.clearTimeout;
//} )();

function pause() {
	PREPAUSE_GAME_STATE = game_state;
	game_state = GAME_STATES.PAUSED;
	stopGameLoop();
}

function unpause() {
	game_state = PREPAUSE_GAME_STATE;
	PREPAUSE_GAME_STATE = undefined;
	startGameLoop();
}


function startGameLoop() {
	window.onkeydown=onKeyDown;
	gameLoop();
}

function gameLoop() {
	//request=window.requestAnimFrame(gameLoop,gameCanvas);
    request = window.setTimeout(gameLoop, 1000 / 60);
	update();
}

function stopGameLoop() {
	//window.cancelRequestAnimFrame(request);
    window.clearTimeout(request);
}

function update() {
    //Set the right head image depending on the direction
    switch(dir) {
        case "left":
            dragon.img=HEAD_LEFT_IMG;
            dragon.yOffset = -15*SPRITE_SCALE;
            break;
        case "right":
            dragon.img=HEAD_RIGHT_IMG;
            dragon.yOffset = -15*SPRITE_SCALE;
            break;
        case "up":
            dragon.img=HEAD_UP_IMG;
            dragon.yOffset = -5*SPRITE_SCALE;
            break;
        case "down":
            dragon.img=HEAD_DOWN_IMG;
            dragon.yOffset = -15*SPRITE_SCALE;
            break;
        default:
            dragon.img=HEAD_DOWN_IMG;
            dragon.yOffset = -15*SPRITE_SCALE;
            break;
    }

    //gameStage.clearRect(0,0,gameCanvas.width,gameCanvas.height);
    wallStage.clearRect(0,0, wallCanvas.width, wallCanvas.height);
    maze.render(wallStage);

    //renderObject(dragon, wallStage);
	//Fix rendering bug in HTML5 canvas
	// var ptup = maze.getPoint(dragon.r-1, dragon.c);
	// if (ptup) {
	// 	renderObject(ptup, gameStage);
	// }
    if (game_state == GAME_STATES.PLAYING) {
    	counter += 1;
    	if (counter>MOVE_DELAY) {
    		var oldR = dragon.r;
    		var oldC = dragon.c;
            lastDir = dir;
            dir = nextDir;
    	
    		if (dir=="left") {
    			dragon.c = dragon.c - 1;
    			counter =0;
    		}
    		if (dir=="right") {
    			dragon.c = dragon.c + 1;
    			counter =0;
    		}
    		if (dir=="up") {
    			dragon.r = dragon.r - 1;
    			counter =0;
    		}
    		if (dir=="down") {	
    			dragon.r = dragon.r + 1;
    			counter =0;
    		}	
    	
    		maze.isOn(dragon.r, dragon.c)
		    if (game_state != GAME_STATES.PLAYING) { return; }
    
              if (dir!="start") {
                LEVEL_SCORE += EARNED_POINTS[MOVE_DELAY];
                renderScore();
    		  }

			maze.removePoint(oldR, oldC);
			maze.addPoint(dragon);
			// wallStage.clearRect(0,0, wallCanvas.width, wallCanvas.height);
			// 		    maze.render(wallStage);
	        var xy = maze.grid2canvas(oldR,oldC);
	        // gameStage.clearRect(xy.x+dragon.xOffset,xy.y+dragon.yOffset,
	        // 		    					xy.x+dragon.img.width*SPRITE_SCALE,
	        // 		    					xy.y+dragon.img.height*SPRITE_SCALE);
            switch(lastDir) {
                    case "start":
                        switch(dir) {
                            case "left":
                                maze.addPoint(new Point(TAIL_LEFT_IMG, oldR, oldC, mazeCollision));
                                break;
                            case "right":
                                maze.addPoint(new Point(TAIL_RIGHT_IMG, oldR, oldC, mazeCollision));
                                break;
                            case "up":
                                maze.addPoint(new Point(TAIL_UP_IMG, oldR, oldC, mazeCollision));
                                break;
                            case "down":
                                maze.addPoint(new Point(TAIL_DOWN_IMG, oldR, oldC, mazeCollision));
                                break;
                        }
                        break;

                    case "left":
                        switch(dir) {
                            case "left":
                                maze.addPoint(new Point(LEFT_TO_RIGHT_IMG, oldR, oldC, mazeCollision));
                                break;
                            case "up":
                                maze.addPoint(new Point(LEFT_TO_UP_IMG, oldR, oldC, mazeCollision));
                                break;
                            case "down":
                                maze.addPoint(new Point(LEFT_TO_DOWN_IMG, oldR, oldC, mazeCollision));
                                break;
                        }
                        break;

                    case "right":
                        switch(dir) {
                            case "right":
                                maze.addPoint(new Point(RIGHT_TO_LEFT_IMG, oldR, oldC, mazeCollision));
                                break;
                            case "up":
                                maze.addPoint(new Point(RIGHT_TO_UP_IMG, oldR, oldC, mazeCollision));
                                break;
                            case "down":
                                maze.addPoint(new Point(RIGHT_TO_DOWN_IMG, oldR, oldC, mazeCollision));
                                break;
                        }
                        break;

                    case "up":
                        switch(dir) {
                            case "right":
                                maze.addPoint(new Point(UP_TO_RIGHT_IMG, oldR, oldC, mazeCollision));
                                break;
                            case "left":
                                maze.addPoint(new Point(UP_TO_LEFT_IMG, oldR, oldC, mazeCollision));
                                break;
                            case "up":
                                maze.addPoint(new Point(DOWN_TO_UP_IMG, oldR, oldC, mazeCollision));
                                break;
                        }
                        break;
                     
                    case "down":
                        switch(dir) {
                            case "right":
                                maze.addPoint(new Point(DOWN_TO_RIGHT_IMG, oldR, oldC, mazeCollision));
                                break;
                            case "left":
                                maze.addPoint(new Point(DOWN_TO_LEFT_IMG, oldR, oldC, mazeCollision));
                                break;
                            case "down":
                                maze.addPoint(new Point(UP_TO_DOWN_IMG, oldR, oldC, mazeCollision));
                                break;
                        }
                        break;
                    default:
						switch(dir) {
                         	case "right":
	                             maze.addPoint(new Point(LEFT_TO_RIGHT_IMG, oldR, oldC, mazeCollision));
	                             break;
	                         case "left":
	                             maze.addPoint(new Point(RIGHT_TO_LEFT_IMG, oldR, oldC, mazeCollision));
	                             break;
	                         case "up":
	                             maze.addPoint(new Point(DOWN_TO_UP_IMG, oldR, oldC, mazeCollision));
	                             break;
	                         case "down":
	                             maze.addPoint(new Point(UP_TO_DOWN_IMG, oldR, oldC, mazeCollision));
	                             break;                        
						}
                }                
			lastDir = dir;
          }
        }
	}


/*************************************/
/* Rendering functions               */
/*************************************/

// updates the current score by adding p points to it
function updateScore(p) {
       SCORE += p;
}

//Prints the game state string in the center of the maze
function printState () {
	gameStage.drawTextCenter("sans", 16, maze.getCenterX(), maze.getCenterY(), game_state); 
}

//Prints text at x and y on the given stage
function stagePrint(text, x, y, stage) {
	stage.fillStyle = '#000';
	stage.font = '12px sans-serif';
	stage.textBaseline = 'top';
	stage.fillText(text, x, y);
}


// prints the new score
function renderScore() {
        $('#total_score').text(TOTAL_SCORE);
        $('#level_score').text(LEVEL_SCORE);
        $('#current_level').text(CURRENT_LEVEL+1);
}

/*
* Default rendering engine
*/
function renderObject($obj, stage) {
	if ($obj.img == undefined){ return; }
	var xy=maze.grid2canvas($obj.r, $obj.c);
    var x = xy.x+$obj.xOffset;
    var y = xy.y+$obj.yOffset;
//    if (ISOMETRIC) {
//	    x=getScreenX(x,y)+$obj.xOffset;
//	    y=getScreenY(x,y)+$obj.yOffset;
//    }
	try {
		stage.drawImage($obj.img,x,y, $obj.img.width*SPRITE_SCALE, $obj.img.height*SPRITE_SCALE);
		if ($obj.obj_type && $obj.obj_type == TYPES.GOAL && DEBUG) {
			stagePrint($obj.destination, xy.x+Math.floor(GRID_W/2), xy.y, stage);
		}
	} catch($error) {
		console.log("Error drawing image: "+ $error.message)
	}
}

/* Only used in Isometric mode */
// function getScreenX($x,$y) {
// 	var x=(($x-$y)*COS)+X_ORIGIN;
// 	//var x=(($x-$y)*COS);
// 	return x;
// }
// 
// function getScreenY($x,$y) {
// 	var y=Y_ORIGIN-(($x+$y)*SIN);
// 	//var y=(($x+$y)*SIN);
// 	return y;
// }

//Main functions held in respective pages.
