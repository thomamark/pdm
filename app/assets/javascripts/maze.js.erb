/**
* Panda Dragon Maze
* Copyright 2011 Mark Thomas (mr.thomas gmail)
*/

/*************************************/
/* Global variables                  */
/*************************************/

/* Graphics */
var SPRITE_SCALE = 2;
var BASE_W = 32;
var BASE_H= 16;
var GRID_W = 32*SPRITE_SCALE;
var GRID_H = 16*SPRITE_SCALE;
var MAX_COLS = Math.floor(900/GRID_W);
var MAX_ROWS = Math.floor(500/GRID_H);
var BORDER_IMG; 
var SNAKE_IMG; 
var GOAL_IMG; 
var STAR_IMG; 
var PANDA_IMG;
var PORTAL_IMG;
var HEAD_UP_IMG;
var HEAD_DOWN_IMG;
var HEAD_LEFT_IMG;
var HEAD_RIGHT_IMG;
var TAIL_UP_IMG;
var TAIL_DOWN_IMG;
var TAIL_LEFT_IMG;
var TAIL_RIGHT_IMG;
var DOWN_TO_LEFT_IMG;
var DOWN_TO_RIGHT_IMG;
var DOWN_TO_UP_IMG;
var LEFT_TO_DOWN_IMG;
var LEFT_TO_RIGHT_IMG;
var LEFT_TO_UP_IMG;
var RIGHT_TO_DOWN_IMG;
var RIGHT_TO_LEFT_IMG;
var RIGHT_TO_UP_IMG; 
var TILES_IMG_ARRAY;
var WALL_BLOCK_IMG;
var PILLAR_IMG;
var VERTICAL_WALL_IMG;
var HORIZONTAL_WALL_IMG;
var DELETE_IMG;

var POST_ASSET_LOAD_FN; //hacky way to get images to load in lb

var IMGDIR ="assets"
var AUDIODIR ="assets"
var LOAD_ASSETS = true;
var INIT_GAME = true;

/* Isometric rendering */
var COS=Math.cos(0.46365);
var SIN=Math.sin(0.46365);
//var X_ORIGIN=540;
//var Y_ORIGIN=420;
var X_ORIGIN=240;
var Y_ORIGIN=400;
var ISOMETRIC = false;

/* I/O */
var LEFT_ARROW=37;
var UP_ARROW=38;
var RIGHT_ARROW=39;
var DOWN_ARROW=40;
var MOVE_DELAY=10;

/* Game */
var LEVELS = [];
var LEVELS_INITED = false;
var CURRENT_LEVEL; //Will be set during init
var TOTAL_SCORE; //Will be set during init
var LEVEL_SCORE= 0;
var EARNED_POINTS = { "5": 40, "10": 20, "15": 40, "bonus" : 1000};

/* Game elements */
var loadFlags = [];
var gameCanvas; // canvas for moving elements
var gameStage;  
var bgCanvas;  // canvas for static background
var bgStage;
var tileCanvas;  // canvas for static background
var tileStage;  // canvas for static background
var game_state;
var request;
var dragon;
var maze; //the current maze
var dir;
var lastDir;
var nextDir;
var counter;
var WALL_TYPE="wall";
var GAME_STATES = {
  READY : "ready?",
  FAILED: "Maze failed!",
  PLAYING: "playing",
  COMPLETE: "Maze complete!",
  GAME_COMPLETE: "Game complete!"
}

/* Audio */
var CHANNEL_MAX = 10;   // number of simultaneous audio channels to allow
var AUDIOCHANNELS = new Array(); // Array of audio elements (initialized below)
var PLAY_FX = true; // whether or not to play sound effects
var PLAY_THEME = true; // whether or not to play sound effects
var AUDIO_SRC= {};  //Caches the playable source strings from the audio elements
var OGG_STR = "audio/ogg";
var THEME;

/*************************************/
/* Game objects                      */
/*************************************/

/*A maze object is a collection of points
 @arg img a an image object to render for this point
 @arg r the row of this object in the maze grid
 @arg c the column of this objection in the maze grid
 @arg isOnFn the function which will be called if the dragon lands on this point
*/
function Point(img,r, c, isOnFn, pointType) {
	this.img=img;
	this.r=r;
	this.c=c;
    //function telling the system what to do if the dragon lands on this point.
    this.isOn = isOnFn;

//	this.yOffset=0-$img.height;
//	this.xOffset=-12;
	this.yOffset=0;
	this.xOffset=0;
    this.obj_type=pointType;
}


// A Wall in the maze
function WallPoint(r,c)  {
	return new Point(WALL_BLOCK_IMG, r, c, mazeCollision, WALL_TYPE);
}

//A goal
function GoalPoint(r,c)  {
	//TODO: add ability to have different results for different goals
	return new Point(PORTAL_IMG, r, c, mazeComplete);
}

//A Panda
function BonusPoint(r,c) {
  return  new Point(PANDA_IMG, r, c, collectBonus);
}

//Dragon starting point
function StartPoint(r,c) {
	return new Point(HEAD_DOWN_IMG, r, c, function () {});
}

//Special point for background tiles. These are used initially to render
//background images only, so there's no need for an isOn function
function TilePoint(img, r, c) {
   var img = TILES_IMG_ARRAY[Math.floor(Math.random()*TILES_IMG_ARRAY.length)];
   return new Point(img, r, c, null); 
}

//A PointArr defines a rectangular region of points within the maze
//pointType is an optional string describing the type of point this is. 
//
//function PointArr(r1, c1, r2, c2, imgArr, fn, pointType) {
function PointArr(r1, c1, r2, c2, pointConstructor) {

        //make sure we always create rects from upper-left to bottom-right
        sr = Math.min(r1, r2);
        er = Math.max(r1, r2);
        sc = Math.min(c1, c2);
        ec = Math.max(c1, c2);

        var points = [];
        //var myimg;
        for (var myr = sr; myr<=er; myr++){
                for (var myc = sc; myc <=ec; myc++) { 
                        //Pick a random image from the set given to give
                        //the rectangle a little visual spice
                        //myimg = imgArr[Math.floor(Math.random()*imgArr.length)]
                        //points.push(new Point(myimg, myr, myc, fn, pointType));
                        points.push(new pointConstructor(myr, myc));
                }
        }
        return points;
}

//A Wall is a PointArr where all points are collisions
function WallArr(sr, sc, er, ec) {
	//accept single-point inputs (i.e.just sr, sc).
	er = er ? er : sr;
	ec = ec ? ec : sc;
        this.points = new PointArr(sr, sc, er, ec, WallPoint);
//        for(var i = 0; i<this.points.length; i++) {
//            this.points[i].obj_type=WALL_TYPE;
//        }
}



//The goal is just a PointArrect whose points call the mazeComplete function
function GoalArr(sr, sc, er, ec) {
	//accept single-point inputs (i.e.just sr, sc).
	er = er ? er : sr;
	ec = ec ? ec : sc;
        this.points = new PointArr(sr, sc, er, ec, GoalPoint);
}

//BonusPoints are points that can be collected. They are placed in hard-to-reach 
//locations to increase the difficulty of the maze.
function BonusArr(r,c) {
    this.points = [new Point(PANDA_IMG, r, c, collectBonus)];
}

/*Defines a square maze
 * c number of columns (width)
 * r number of rows (height)
 * sr the starting row of the dragon
 * sc the starting column of the dragon
 * sx, sy x and y pixel offsets 
 * objs an array of MazeObjects
*/
//function Maze (r, c, sr, sc, sx, sy, objs) {
function Maze () {
//    this.cols = c;
//    this.rows = r;
//	this.sr = sr;
//	this.sc = sc;
	//Set for future calculations, but use sx, sy for brevity below
	this.xOffset = 0;
	this.yOffset = 0;
	this.points = [];
//    this.objs = objs;
    this.objs = [];
    this.doneBonuses = 0;
    this.gotBonuses = 0;

	//this.initPoints();
}


// Sets the Maze's size in rows (height) and columns (width)
Maze.prototype.setSize = function (r,c) {
	this.rows = r;
	this.cols = c;
	this.initPoints();
}

/* Sets the Dragon's starting point */
Maze.prototype.setStart = function(r,c) {
	this.sr = r;
	this.sc = c;

}

Maze.prototype.grid2canvas= function (r, c) {
	return [(c-1) * GRID_W + this.yOffset,
            (r-1) * GRID_H + this.xOffset];
}

Maze.prototype.getCenterX = function () {
	return Math.round(((this.cols)*GRID_W+this.xOffset)/2);
}

Maze.prototype.getCenterY = function () {
	return Math.round(((this.rows)*GRID_H+this.yOffset)/2);
}

Maze.prototype.getSnakeStartRC = function () {
	return [this.sr, this.sc];
}

Maze.prototype.collectBonus = function(){
    this.gotBonuses +=1;
    LEVEL_SCORE += EARNED_POINTS['bonus'];
}

Maze.prototype.complete = function () {
   this.doneBonuses = this.gotBonuses;
}

Maze.prototype.addBorders = function () {
    this.objs.unshift(new WallArr(1,1,1,this.cols));
    this.objs.unshift(new WallArr(this.rows,1,this.rows,this.cols));
    this.objs.unshift(new WallArr(2,1,this.rows-1,1));
    this.objs.unshift(new WallArr(2,this.cols,this.rows-1,this.cols));
//	var createBorder = function () {
//    this.objs.unshift(new WallArr(1,1,1,this.cols));
//    this.objs.unshift(new WallArr(this.rows,1,this.rows,this.cols));
//    this.objs.unshift(new WallArr(2,1,this.rows-1,1));
//    this.objs.unshift(new WallArr(2,this.cols,this.rows-1,this.cols));
//	}
//	try { 
//		createBorder();
//	} catch (err) { 
//		this.initPoints();
//		createBorder();
//	}
}

Maze.prototype.removeBorders = function () {
}

Maze.prototype.initPoints = function() {
	this.points = [];
    this.gotBonuses = 0;
	//Create an array with an entry for every point in this maze
	for (var i=0; i<this.rows; i++){
		this.points[i]=[];
		this.points[i][this.cols-1]=undefined;
	}

	//Add borders
	this.addBorders();
//    this.objs.unshift(new WallArr(1,1,1,this.cols));
//    this.objs.unshift(new WallArr(this.rows,1,this.rows,this.cols));
//    this.objs.unshift(new WallArr(2,1,this.rows-1,1));
//    this.objs.unshift(new WallArr(2,this.cols,this.rows-1,this.cols));

    for (var i=0; i<this.objs.length; i++) {
            var o = this.objs[i];
            for (var p=0; p<o.points.length; p++){
                    this.addPoint(o.points[p]);
            }
    }

    this.fixWallImages();
	
}

Maze.prototype.hasPoint = function(r, c) {
	return this.points[r-1][c-1];
}

Maze.prototype.fixWallImages = function() {
    for (var i = 0; i<this.rows; i++) {
        for (var j= 0; j<this.cols;j++) {
           //We only care about walls, so skip everything else
            try {
           if (!this.points[i][j] || this.points[i][j].obj_type!=WALL_TYPE) {
                continue;
            }
            } catch(err) {
                alert("caught the error");
                console.log("error! i="+i+" j="+j);
            }

           if ((i!=0 && i!=this.rows-1) && 
                (this.points[i-1][j]!=undefined && 
                 this.points[i-1][j].obj_type==WALL_TYPE && 
                 this.points[i+1][j]!=undefined &&
                 this.points[i+1][j].obj_type==WALL_TYPE &&
                 (j==0 || this.points[i][j-1]==undefined || 
                    this.points[i][j-1].obj_type!=WALL_TYPE) && 
                 (j==this.cols-1||this.points[i][j+1]==undefined || 
                    this.points[i][j+1].obj_type!=WALL_TYPE))) {
                    //Fix horizontal wall image
                    this.points[i][j].img=VERTICAL_WALL_IMG;
           } else if ((j!=0 && j!=this.cols-1) &&
                (this.points[i][j-1]!=undefined && 
                 this.points[i][j-1].obj_type==WALL_TYPE && 
                 this.points[i][j+1]!=undefined &&
                 this.points[i][j+1].obj_type==WALL_TYPE &&
                 (i==0 || this.points[i-1][j]==undefined || 
                    this.points[i-1][j].obj_type!=WALL_TYPE) && 
                 (i==this.rows-1||this.points[i+1][j]==undefined || 
                    this.points[i+1][j].obj_type!=WALL_TYPE))) {
                      //Fix vertical wall image
                      this.points[i][j].img=HORIZONTAL_WALL_IMG;
                      this.points[i][j].yOffset=3*SPRITE_SCALE;
                 }
        }
    }
}

// Adds an array of Point Objects to this Maze
// Takes arr an Array of Point objects
Maze.prototype.addObjs= function(arr) {
	this.objs = this.objs.concat(arr);
}

Maze.prototype.addObj= function(obj) {
	this.objs.push(obj)
}

// Adds a point object to this Maze
Maze.prototype.addPoint = function(pt) {
	this.points[pt.r-1][pt.c-1]=pt;
    return pt;
}

Maze.prototype.getPoint = function(r,c) {
	return this.points[r-1][c-1];
}

Maze.prototype.isOn = function (r, c) {
        var pt = this.getPoint(r,c);
        if (pt && pt.isOn) {
                pt.isOn();
        }
}

Maze.prototype.render = function (stage) {
	for (var i =0; i<this.rows; i++) {
		for (var j =0; j<this.cols; j++) {
            //render the background tiles the first time we render the maze.
            if (game_state != GAME_STATES.FAILED) {
                renderObject(
                    new TilePoint(i+1, j+1),
                    tileStage);
            }
			if (this.points[i][j]) {
				renderObject(this.points[i][j], stage);
			}
		}
	}
}

/*************************************/
/* Maze events                       */
/*************************************/

function cleanUp() {
    printState();
    stopGameLoop();
}

function mazeCollision() {
    game_state = GAME_STATES.FAILED;
    stopMusic();
    playMultiSound('defeat');
    LEVEL_SCORE = 0;
    cleanUp();
}

function mazeComplete() {
    game_state = GAME_STATES.COMPLETE;
    stopMusic();
    playMultiSound('victory');
    maze.complete();
    TOTAL_SCORE += LEVEL_SCORE;
    LEVEL_SCORE = 0;
    CURRENT_LEVEL+=1;
    saveGameState();
    renderScore();
    cleanUp();
}

function collectBonus() {
    maze.collectBonus();
    playMultiSound('pick_up');
}

function gameComplete() {
    game_state = GAME_STATES.GAME_COMPLETE;
    CURRENT_LEVEL=0;
    for (var i=0; i<LEVELS.length;i++) {
        LEVELS[i].initPoints();
    }
    cleanUp();
}


/*************************************/
/* Initialization functions          */
/*************************************/

function init(fn) { 
    POST_ASSET_LOAD_FN = fn;

    //Short-circuit if we don't want to load assets.
    if (!LOAD_ASSETS) { return;}
    loadAssets(); 


}

function saveGameState() {
  $.cookie("CurrentLevel",CURRENT_LEVEL);
  $.cookie("TotalScore",TOTAL_SCORE);
}

function initGameState() {
  CURRENT_LEVEL = $.cookie("CurrentLevel") ? parseInt($.cookie("CurrentLevel")) : 0;
  TOTAL_SCORE = $.cookie("TotalScore") ? parseInt($.cookie("TotalScore")) : 0;
}

function loadAssets() {
    if (ISOMETRIC) {
        GRID_W = 28;
        GRID_H = 28;
	    BORDER_IMG = createImgAsset("border", 
            "<%= asset_path('border_iso.png') %>");
	    SNAKE_IMG = createImgAsset("snake", 
            "<%= asset_path('snake_iso.png') %>");
	    GOAL_IMG = createImgAsset("goal",
            "<%= asset_path('goal_iso.png') %>");
    } else {
//	    BORDER_IMG = createImgAsset("border",
//            "<%= asset_path('border_19x19.png') %>");
//	    SNAKE_IMG = createImgAsset("dragon",
//            "<%= asset_path('mover_19x19.png') %>");
//	    GOAL_IMG = createImgAsset("goal",
//            "<%= asset_path('goal_19x19.png') %>");
//	    STAR_IMG = createImgAsset("star",
//            "<%= asset_path('star_19x19.png') %>");
	    PANDA_IMG = createImgAsset("panda",
            "<%= asset_path('Panda.png') %>");
	    PORTAL_IMG = createImgAsset("portal",
            "<%= asset_path('Goal_1.png') %>");
	    HEAD_UP_IMG = createImgAsset("head_up",
            "<%= asset_path('Head_Up.png') %>");
	    HEAD_DOWN_IMG = createImgAsset("head_down",
            "<%= asset_path('Head_Down.png') %>");
	    HEAD_LEFT_IMG = createImgAsset("head_left",
            "<%= asset_path('Head_Left.png') %>");
	    HEAD_RIGHT_IMG = createImgAsset("head_right",
            "<%= asset_path('Head_Right.png') %>");

	    TAIL_UP_IMG = createImgAsset("tail_up",
            "<%= asset_path('Tail_Up.png') %>");
	    TAIL_DOWN_IMG = createImgAsset("tail_down",
            "<%= asset_path('Tail_Down.png') %>");
	    TAIL_LEFT_IMG = createImgAsset("tail_left",
            "<%= asset_path('Tail_Right.png') %>");
	    TAIL_RIGHT_IMG = createImgAsset("tail_right",
            "<%= asset_path('Tail_Left.png') %>");
        DOWN_TO_LEFT_IMG = createImgAsset("dtl",
            "<%= asset_path('Body_UpToLeft.png') %>");
        DOWN_TO_RIGHT_IMG = createImgAsset("dtr",
            "<%= asset_path('Body_UpToRight.png') %>");
        DOWN_TO_UP_IMG = createImgAsset("dtu",
            "<%= asset_path('Body_DownToUp.png') %>");
        LEFT_TO_DOWN_IMG= createImgAsset("ltd",
            "<%= asset_path('Body_RightToDown.png') %>");
        LEFT_TO_RIGHT_IMG= createImgAsset("ltr",
            "<%= asset_path('Body_RightToLeft.png') %>");
        LEFT_TO_UP_IMG= createImgAsset("ltu",
            "<%= asset_path('Body_RightToUp.png') %>");
        RIGHT_TO_DOWN_IMG= createImgAsset("rtd",
            "<%= asset_path('Body_LeftToDown.png') %>");
        RIGHT_TO_LEFT_IMG= createImgAsset("rtl",
            "<%= asset_path('Body_LeftToRight.png') %>");
        RIGHT_TO_UP_IMG= createImgAsset("rtu",
            "<%= asset_path('Body_UpToLeft.png') %>");
        UP_TO_DOWN_IMG= createImgAsset("utd",
            "<%= asset_path('Body_UpToDown.png') %>");
        UP_TO_LEFT_IMG= createImgAsset("utl",
            "<%= asset_path('Body_DownToLeft.png') %>");
        UP_TO_RIGHT_IMG= createImgAsset("utr",
            "<%= asset_path('Body_DownToRight.png') %>");

        TILES_IMG_ARRAY= [];
        TILES_IMG_ARRAY.push(createImgAsset("tile_1",
              "<%= asset_path('tiles.png') %>"));
        TILES_IMG_ARRAY.push(createImgAsset("tile_2",
              "<%= asset_path('tiles_2.png') %>"));
        TILES_IMG_ARRAY.push(createImgAsset("tile_3",
              "<%= asset_path('tiles_3.png') %>"));
        TILES_IMG_ARRAY.push(createImgAsset("tile_4",
              "<%= asset_path('tiles_4.png') %>"));
        VERTICAL_WALL_IMG = createImgAsset("vw",
            "<%= asset_path('wall_stright_horizontal.png') %>");
        HORIZONTAL_WALL_IMG = createImgAsset("hw",
            "<%= asset_path('wall_stright_vertical.png') %>");
	    WALL_BLOCK_IMG = createImgAsset("pillar",
            "<%= asset_path('wall_block.png') %>");
        DELETE_IMG = createImgAsset("delete", 
            "<%= asset_path('delete.png') %>");

    }
}


function createImgAsset($id,$src) {
	var img=new Image();
	loadFlags[$id]=0;
	img.onload=function(){onAssetLoaded($id);};
	img.src=$src;
//    img.height = GRID_H;
//    img.width = GRID_W;
	return img;
}

function onAssetLoaded($asset_id) {
	loadFlags[$asset_id]=1;
    //Don't start the game until everything's been loaded
	for(flag in loadFlags) {
		if(!loadFlags[flag]) {return;}
	}
    //Only continue if we want to continue the game
    if (POST_ASSET_LOAD_FN) {POST_ASSET_LOAD_FN();}
    if (!INIT_GAME) { return;}
	game_init();
}

function game_init() {

    //Init stuff you'll need if you're playing
    initGameState();
    //Init configuration panel
    $("input[name=speed]:radio").click(function() {changeSpeed(this.value);});
    $("#ctrl_fx").click(function() {toggleFX(this.checked);});
    $("#ctrl_music").click(function() {toggleMusic(this.checked)});
    $("#options_link").click(function() {toggleOptions()});
    $("#options_done").click(function() {toggleOptions()});
    $("#quit").click(function() {quit()});
    initSound();


    //Set up graphics
	gameCanvas = document.getElementById('maze-canvas');
	bgCanvas = document.getElementById('maze-canvas-background');
    tileCanvas = document.getElementById('tile-canvas');
	gameStage = gameCanvas.getContext("2d");
	bgStage = bgCanvas.getContext("2d");
	tileStage = tileCanvas.getContext("2d");
	counter = 0;
	CanvasTextFunctions.enable(gameStage);
    init_levels();
    maze_init();
}

function maze_init(){
    if(game_state == GAME_STATES.COMPLETE) {
		tileStage.clearRect(0,0,bgCanvas.width,bgCanvas.height);
        if (CURRENT_LEVEL>=LEVELS.length){
            gameComplete();
            return;
        }

    } 

    if (game_state != GAME_STATES.FAILED) {
      if (CURRENT_LEVEL >= LEVELS.length) { 
        //Ran into messed up cookie values.
        CURRENT_LEVEL = 0; 
        TOTAL_SCORE = 0;
      }
        maze = LEVELS[CURRENT_LEVEL];
        $(gameCanvas).attr("height", maze.cols*26);
        $(gameCanvas).attr("width", maze.rows*GRID_W);
        $(bgCanvas).attr("height", maze.cols*26);
        $(bgCanvas).attr("width", maze.rows*GRID_W);
        $(tileCanvas).attr("height", maze.cols*26);
        $(tileCanvas).attr("width", maze.rows*GRID_W);
    } else {
        maze.initPoints();
    }

	maze.render(bgStage);
	game_state = GAME_STATES.READY;
    printState();
    renderScore();
	var rc = maze.getSnakeStartRC();
    //Do nothing if Snake is on itself.
	dragon = new Point(HEAD_DOWN_IMG, rc[0], rc[1], function () {});
    dir="start";
    startMusic();
	startGameLoop();
}

/*************************************/
/* Configuation functions            */
/*************************************/

function changeSpeed(s) {
     //console.log("Changing speed from "+MOVE_DELAY+" to "+s);
     MOVE_DELAY=parseInt(s);
}

/* Music and sound effects functions */

//Set up audio channels for seamless, simultaneous play of multiple sounds
//Thanks to http://www.storiesinflight.com/html5/audio.html 
function initSound() {
    //Code courtesy of http://html5doctor.com/native-audio-in-the-browser/
    var myAudio = $('#theme'); 
    if (myAudio.canPlayType) {
       // Currently canPlayType(type) returns: "", "maybe" or "probably" 
       //canPlayMp3 = !!myAudio.canPlayType && 
       //                 "" != myAudio.canPlayType('audio/mpeg');
       var canPlayOgg = !!myAudio.canPlayType && 
                        "" != myAudio.canPlayType('audio/ogg; codecs="vorbis"');
    }
    //Cache the appropriate audio source
    $.each($("audio"), function (i, v) {
                $.each($(v).children(), function (i2, v2) {
                        //Use ogg by default because it's smaller and open =)
                        if (v2.type == OGG_STR && canPlayOgg) {
                            AUDIO_SRC[v.id] = v2.src;
                        } else if (!canPlayOgg) {
                            //Otherwise set to MP3
                            AUDIO_SRC[v.id] = v2.src;
                        }
                    }
                )});
    
    for (a=0;a<CHANNEL_MAX;a++) { // prepare the channels
        AUDIOCHANNELS[a] = new Array();
        AUDIOCHANNELS[a]['channel'] = new Audio();// create a new audio object
        AUDIOCHANNELS[a]['finished'] = -1;// expected end time for this channel
    }
    //Workaround for Firefox and Safari
    THEME = new Audio();
    THEME.load();
    THEME.src=AUDIO_SRC['theme'];
    THEME.volume=.3;
    THEME.loop="loop";
    //Loop the theme track
    $(THEME).bind('ended', function() {this.currentTime=0});
}

function startMusic() {
    if (PLAY_THEME) {
        THEME.play();
        //$('#theme')[0].load();
        //$('#theme').bind('ended', function() {this.currentTime=0});
        //$('#theme')[0].volume=.3;
        //$('#theme')[0].play();
    }
}

function stopMusic() {
    //$('#theme')[0].pause();
    THEME.pause();
}

function toggleFX(on) {
    PLAY_FX = on;
}

function toggleMusic(on) {
    PLAY_THEME = on;
    if (PLAY_THEME) {
        startMusic();
    } else {
        stopMusic();
    }
}

function toggleOptions() {
  $("#lightbox").toggle();
}

function deleteCookie() {
  $.removeCookie("CurrentLevel");
  $.removeCookie("TotalScore");
}

function quit() {
  deleteCookie();
  window.location = "/";
}

//Plays multiple sounds simultaneously a bit more smoothly than would happen normally.
//Courtesy of http://www.storiesinflight.com/html5/audio.html. Thanks!
function playMultiSound(s) {
    if (PLAY_FX) {
        for (a=0;a<AUDIOCHANNELS.length;a++) {
            thistime = new Date();
            if (AUDIOCHANNELS[a]['finished'] < thistime.getTime()) {            // is this channel finished?
                AUDIOCHANNELS[a]['finished'] = thistime.getTime() + document.getElementById(s).duration*1000;
                AUDIOCHANNELS[a]['channel'].src = AUDIO_SRC[s];
                AUDIOCHANNELS[a]['channel'].load();
                AUDIOCHANNELS[a]['channel'].play();
                break;
            }
        }
    }
}


/*************************************/
/* Mazes                             */
/*************************************/

function init_levels() {

    //Wesley's maze
    objs = [];
    objs.push(new WallArr(5,2,16,3));
    objs.push(new WallArr(2,6,3,24));
    objs.push(new WallArr(4,6,5,7));
    objs.push(new WallArr(2,5,6,5));
    objs.push(new WallArr(9,5,9,7));
    objs.push(new WallArr(10,7,15,7));
    objs.push(new WallArr(15,8,15,11));
    objs.push(new WallArr(13,11,14,11));
    objs.push(new WallArr(6,6,6,8));
    objs.push(new WallArr(5,8,5,8));
    objs.push(new WallArr(4,8,4,23));
    objs.push(new WallArr(7,8,7,8));
    objs.push(new WallArr(6,11,6,22));
    objs.push(new WallArr(6,11,6,22));
    objs.push(new WallArr(9,11,9,17));
    objs.push(new WallArr(10,17,16,17));
    objs.push(new WallArr(13,15,15,15));
    objs.push(new WallArr(10,19,15,19));
    objs.push(new WallArr(10,20,10,21));
    objs.push(new WallArr(10,18,10,18));
    objs.push(new WallArr(6,22,6,22));
    objs.push(new WallArr(8,22,10,22));
    objs.push(new WallArr(12,22,13,22));
    objs.push(new WallArr(15,23,15,24));
    objs.push(new WallArr(15,16,15,16));
    objs.push(new GoalArr(16,24,16,24));
    var wm = new Maze();
	  wm.setSize(17,25);
	  wm.setStart( 3,3);
		wm.addObjs(objs);
		wm.initPoints();


    //Josh's maze
    objs = [];
    objs.push(new WallArr(2,2,3,2));
    objs.push(new WallArr(6,2,6,2));
    objs.push(new WallArr(2,5,5,7));
    objs.push(new WallArr(2,4,2,4));
    objs.push(new WallArr(4,4,5,4));
    objs.push(new WallArr(7,4,7,7));
    objs.push(new WallArr(8,7,13,7));
    objs.push(new WallArr(9,3,10,5));
    objs.push(new WallArr(11,3,11,4));
    objs.push(new WallArr(13,4,13,6));
    objs.push(new WallArr(14,4,15,4));
    objs.push(new WallArr(15,5,15,7));
    objs.push(new WallArr(3,9,4,11));
    objs.push(new WallArr(6,9,12,9));
    objs.push(new WallArr(14,9,15,9));
    objs.push(new WallArr(6,11,7,11));
    objs.push(new WallArr(9,10,9,12));
    objs.push(new WallArr(11,11,12,14));
    objs.push(new WallArr(14,11,15,14));
    objs.push(new WallArr(2,12,5,12));
    objs.push(new WallArr(6,13,9,14));
    objs.push(new WallArr(10,14,10,14));
    objs.push(new WallArr(2,14,2,14));
    objs.push(new WallArr(4,14,4,16));
    objs.push(new WallArr(3,16,3,16));
    objs.push(new WallArr(6,12,6,12));
    objs.push(new WallArr(6,16,6,16));
    objs.push(new WallArr(12,8,12,8));
    objs.push(new WallArr(13,11,13,11));
    objs.push(new WallArr(9,16,10,16));
    objs.push(new WallArr(13,16,16,16));
    objs.push(new BonusArr(11,5));
    objs.push(new BonusArr(13,8));
    objs.push(new BonusArr(11,16));
    objs.push(new GoalArr(2,16,2,16));
    var jm = new Maze();
	  jm.setSize(17,17);
	  jm.setStart( 2,8);
		jm.addObjs(objs);
		jm.initPoints();

    //Level 1
    objs = [];
    objs.push(new WallArr(6,6,6,10));
    objs.push(new WallArr(7,10,12,10));
    objs.push(new GoalArr(7,20,9,20));
    //var l1 = new Maze(20,20, 2, 2, 0, 0, objs);
    var l1 = new Maze();
	  l1.setSize(20,20);
	  l1.setStart(2,2);
		l1.addObjs(objs);
		l1.initPoints();

    //First walls
    objs = [];
    objs.push(new WallArr(2,6,9,6));
    objs.push(new WallArr(12,6,14,6));
    objs.push(new WallArr(12,7,12,11));
    objs.push(new WallArr(11,11,5,11));
    objs.push(new GoalArr(15,7,15,8));
    var fw = new Maze();
	  fw.setSize(15,15);
	  fw.setStart( 2,2);
		fw.addObjs(objs);
		fw.initPoints();



    //Impossible start
    objs = [];
    objs.push(new WallArr(2,2,2,4));
    objs.push(new WallArr(2,3,2,14));
    objs.push(new WallArr(3,14,3,14));
    objs.push(new WallArr(4,4,11,4));
    objs.push(new WallArr(4,12,11,12));
    objs.push(new WallArr(6,3,6,3));
    objs.push(new WallArr(11,5,11,11));
    objs.push(new WallArr(9,6,9,9));
    objs.push(new WallArr(6,7,6,9));
    objs.push(new WallArr(7,7,7,7));
    objs.push(new WallArr(7,9,7,9));
    objs.push(new GoalArr(15,8,15,8));
    objs.push(new BonusArr(9,5));        
    objs.push(new BonusArr(9,10));       
    objs.push(new BonusArr(7,3)); 
    //var is = new Maze(15,15, 7, 8, 0, 0, objs);
    var is = new Maze();
	  is.setSize(15,15);
	  is.setStart( 7,8);
		is.addObjs(objs);
		is.initPoints();

    //Spiral
    objs = [];
    objs.push(new WallArr(3,3,3,10));
    objs.push(new WallArr(4,3,10,3));
    objs.push(new WallArr(10,4,10,9));
    objs.push(new WallArr(9,9,5,9));
    objs.push(new WallArr(5,8,5,5));
    objs.push(new WallArr(6,5,8,5));
    objs.push(new WallArr(8,6,8,7));
    objs.push(new WallArr(7,7,7,7));
    objs.push(new GoalArr(7,6,7,6));
    //var sm = new Maze(12,11, 2, 10, 0, 0, objs);
    var sm = new Maze(12,11, 2, 10, 0, 0, objs);
	  sm.setSize(12,11);
	  sm.setStart( 2,10);
		sm.addObjs(objs);
		sm.initPoints();

    //X
    objs = []
    objs.push(new WallArr(2,2,2,2));
    objs.push(new WallArr(3,3,3,3));
    objs.push(new WallArr(4,4,4,4));
    objs.push(new WallArr(5,5,5,5));
    objs.push(new WallArr(7,7,7,7));
    objs.push(new WallArr(8,8,8,8));
    objs.push(new WallArr(10,10,10,10));
    objs.push(new WallArr(11,11,11,11));
    objs.push(new WallArr(10,3,10,3));
    objs.push(new WallArr(9,4,9,4));
    objs.push(new WallArr(8,5,8,5));
    objs.push(new WallArr(7,6,7,6));
    objs.push(new WallArr(6,7,6,7));
    objs.push(new WallArr(5,8,5,8));
    objs.push(new WallArr(4,9,4,9));
    objs.push(new WallArr(3,10,3,10));
    objs.push(new WallArr(2,11,2,11));
    objs.push(new GoalArr(3,11,3,11));
    //var xm = new Maze(12,12, 2, 10, 0, 0, objs);
    var xm = new Maze();
	  xm.setSize(12,12);
	  xm.setStart(2,10);
		xm.addObjs(objs);
		xm.initPoints();

    //Falldown
    objs = []
    objs.push(new WallArr(3,5,3,7));
    objs.push(new WallArr(5,2,5,4));
    objs.push(new WallArr(5,2,5,4));
    objs.push(new WallArr(7,5,7,7));
    objs.push(new WallArr(8,5,8,7));
    objs.push(new GoalArr(8,6,8,6));
    //var fd = new Maze(10,8,2,7, 0, 0, objs);
    var fd = new Maze();
	  fd.setSize(10,8);
	  fd.setStart(2,7);
		fd.addObjs(objs);
		fd.initPoints();

    //corridors
    objs = []
    objs.push(new WallArr(3,5,13,5));
    objs.push(new WallArr(2,7,12,7));
    objs.push(new WallArr(3,9,13,9));
    objs.push(new GoalArr(6,11,6,11));          
    //var cm = new Maze(14,11,13,3, 0, 0, objs);       
    var cm = new Maze();       
	  cm.setSize(14,11);
	  cm.setStart(13,3);
		cm.addObjs(objs);
		cm.initPoints();
         
    //Maginot        
    objs = []        
    objs.push(new WallArr(3,3,3,3));        
    objs.push(new WallArr(5,3,5,3));        
    objs.push(new WallArr(7,3,7,3));        
    objs.push(new WallArr(9,3,9,3));        
    objs.push(new WallArr(2,5,2,5));        
    objs.push(new WallArr(4,5,4,5));        
    objs.push(new WallArr(6,5,6,5));        
    objs.push(new WallArr(8,5,8,5));        
    objs.push(new WallArr(3,7,3,7));        
    objs.push(new WallArr(5,7,5,7));        
    objs.push(new WallArr(7,7,7,7));        
    objs.push(new WallArr(9,7,9,7));        
    objs.push(new BonusArr(2,4));        
    objs.push(new BonusArr(2,6));        
    objs.push(new BonusArr(9,8));        
    objs.push(new GoalArr(10,9,10,9));          
    //var mg = new Maze(10,10,9,2, 0, 0, objs);        
    var mg = new Maze();        
	  mg.setSize(10,10);
	  mg.setStart(9,2);
		mg.addObjs(objs);
		mg.initPoints();
         
    //Carpal Tunnel          
    objs = []        
    objs.push(new WallArr(2,3,5,3));        
    objs.push(new WallArr(7,2,8,2));        
    objs.push(new WallArr(5,4,10,4));       
    objs.push(new WallArr(10,3,10,3));          
    objs.push(new WallArr(3,5,3,8));        
    objs.push(new WallArr(5,4,5,6));        
    objs.push(new WallArr(7,5,7,8));        
    objs.push(new WallArr(9,6,9,6));        
    objs.push(new WallArr(9,6,9,6));        
    objs.push(new WallArr(6,8,10,8));       
    objs.push(new WallArr(10,9,10,9));          
    objs.push(new WallArr(7,10,8,10));          
    objs.push(new WallArr(4,9,5,9));        
    objs.push(new WallArr(2,10,2,10));          
    objs.push(new BonusArr(8,6));        
    objs.push(new BonusArr(10,6));       
    objs.push(new BonusArr(5,8));        
    objs.push(new GoalArr(6,5,6,5));        
    //var ct = new Maze(12,11,2,2, 0, 0, objs); 
    var ct = new Maze(); 
	  ct.setSize(12,11);
	  ct.setStart(2,2);
		ct.addObjs(objs);
		ct.initPoints();
    
    LEVELS.push(l1);
    LEVELS.push(fw);
    LEVELS.push(xm);
    LEVELS.push(fd);
    LEVELS.push(cm);
    LEVELS.push(sm);
    LEVELS.push(mg);         
    LEVELS.push(is);         
    LEVELS.push(ct);         
    //LEVELS.push(wm);       
    //LEVELS.push(jm); 

}

/*************************************/
/* I/O functions                     */
/*************************************/

function onKeyDown($evt){
	$evt.preventDefault();
	if (game_state==GAME_STATES.READY) {
		gameStage.clearRect(0,0,gameCanvas.width,gameCanvas.height);
		//bgStage.clearRect(0,0,bgCanvas.width,bgCanvas.height);
		//maze.render(bgStage);
		renderObject(dragon, gameStage);
		game_state=GAME_STATES.PLAYING;
	}
	if(game_state==GAME_STATES.PLAYING){
         //Save the last direction
		 if($evt.keyCode==LEFT_ARROW){
			 nextDir = "left";
		 }
		 if ($evt.keyCode==RIGHT_ARROW){
			 nextDir = "right";
		 }
		 if ($evt.keyCode==DOWN_ARROW){
			 nextDir = "down";
		 }
		 if ($evt.keyCode==UP_ARROW){
			 nextDir = "up";
	  	 }
	} else {
		gameStage.clearRect(0,0,gameCanvas.width,gameCanvas.height);
		bgStage.clearRect(0,0,bgCanvas.width,bgCanvas.height);
		maze_init();
	}
}

/*************************************/
/* Game loop control functions       */
/*************************************/

// Thanks Paul Irish. shim layer with setTimeout fallback
//Note this seems to break in Firefox and Safari, so I'm not using it.
//window.requestAnimFrame = (function(){
//  return  window.requestAnimationFrame       || 
//          window.webkitRequestAnimationFrame || 
//          window.mozRequestAnimationFrame    || 
//          window.oRequestAnimationFrame      || 
//          window.msRequestAnimationFrame     || 
//          function(/* function */ callback, /* DOMElement */ element){
//            window.setTimeout(callback, 1000 / 60);
//          };
//})();

//window.cancelRequestAnimFrame = ( function() {
//    return window.cancelAnimationFrame          ||
//        window.webkitCancelRequestAnimationFrame    ||
//        window.mozCancelRequestAnimationFrame       ||
//        window.oCancelRequestAnimationFrame     ||
//        window.msCancelRequestAnimationFrame        ||
//        window.clearTimeout;
//} )();


function startGameLoop() {
	window.onkeydown=onKeyDown;
	gameLoop();
}

function gameLoop() {
	//request=window.requestAnimFrame(gameLoop,gameCanvas);
    request = window.setTimeout(gameLoop, 1000 / 60);
	update();
}

function stopGameLoop() {
	//window.cancelRequestAnimFrame(request);
    window.clearTimeout(request);
}

//Prints the game state string in the center of the maze
function printState () {
	gameStage.drawTextCenter("sans", 16, maze.getCenterX(), 
                    maze.getCenterY(), game_state); 
}

function update() {
    //gameStage.clearRect(0,0,gameCanvas.width,gameCanvas.height);
    //maze.render(bgStage);

    //Set the right head image depending on the direction
    switch(dir) {
        case "left":
            dragon.img=HEAD_LEFT_IMG;
            dragon.yOffset = -15*SPRITE_SCALE;
            break;
        case "right":
            dragon.img=HEAD_RIGHT_IMG;
            dragon.yOffset = -15*SPRITE_SCALE;
            break;
        case "up":
            dragon.img=HEAD_UP_IMG;
            dragon.yOffset = 0;
            break;
        case "down":
            dragon.img=HEAD_DOWN_IMG;
            dragon.yOffset = -15*SPRITE_SCALE;
            break;
        default:
            dragon.img=HEAD_DOWN_IMG;
            dragon.yOffset = -15*SPRITE_SCALE;
            break;
    }
    renderObject(dragon, gameStage);
    if (game_state == GAME_STATES.PLAYING) {
    	counter += 1;
    	if (counter>MOVE_DELAY) {
    		var oldR = dragon.r;
    		var oldC = dragon.c;
            lastDir = dir;
            dir = nextDir;
    	
    		if (dir=="left") {
    			dragon.c = dragon.c - 1;
    			counter =0;
    		}
    		if (dir=="right") {
    			dragon.c = dragon.c + 1;
    			counter =0;
    		}
    		if (dir=="up") {
    			dragon.r = dragon.r - 1;
    			counter =0;
    		}
    		if (dir=="down") {
    			dragon.r = dragon.r + 1;
    			counter =0;
    		}	
    	
    		maze.isOn(dragon.r, dragon.c)
		    if (game_state != GAME_STATES.PLAYING) { return; }
    
              if (dir!="start") {
                LEVEL_SCORE += EARNED_POINTS[MOVE_DELAY];
                renderScore();
    		}

	        var xy = maze.grid2canvas(oldR,oldC);
	        gameStage.clearRect(xy[0]+dragon.xOffset,xy[1]+dragon.yOffset,
		  xy[0]+dragon.img.width*SPRITE_SCALE,
		  xy[1]+dragon.img.height*SPRITE_SCALE);
                switch(lastDir) {
                    case "start":
                        switch(dir) {
                            case "left":
                                renderObject(maze.addPoint(new Point(TAIL_LEFT_IMG, oldR, oldC, mazeCollision)), bgStage);
                                break;
                            case "right":
                                renderObject(maze.addPoint(new Point(TAIL_RIGHT_IMG, oldR, oldC, mazeCollision)), bgStage);
                                break;
                            case "up":
                                renderObject(maze.addPoint(new Point(TAIL_UP_IMG, oldR, oldC, mazeCollision)), bgStage);
                                break;
                            case "down":
                                renderObject(maze.addPoint(new Point(TAIL_DOWN_IMG, oldR, oldC, mazeCollision)), bgStage);
                                break;
                        }
                        break;

                    case "left":
                        switch(dir) {
                            case "left":
                                renderObject(maze.addPoint(new Point(LEFT_TO_RIGHT_IMG, oldR, oldC, mazeCollision)), bgStage);
                                break;
                            case "up":
                                renderObject(maze.addPoint(new Point(LEFT_TO_UP_IMG, oldR, oldC, mazeCollision)), bgStage);
                                break;
                            case "down":
                                renderObject(maze.addPoint(new Point(LEFT_TO_DOWN_IMG, oldR, oldC, mazeCollision)), bgStage);
                                break;
                        }
                        break;

                    case "right":
                        switch(dir) {
                            case "right":
                                renderObject(maze.addPoint(new Point(RIGHT_TO_LEFT_IMG, oldR, oldC, mazeCollision)), bgStage);
                                break;
                            case "up":
                                renderObject(maze.addPoint(new Point(RIGHT_TO_UP_IMG, oldR, oldC, mazeCollision)), bgStage);
                                break;
                            case "down":
                                renderObject(maze.addPoint(new Point(RIGHT_TO_DOWN_IMG, oldR, oldC, mazeCollision)), bgStage);
                                break;
                        }
                        break;

                    case "up":
                        switch(dir) {
                            case "right":
                                renderObject(maze.addPoint(new Point(UP_TO_RIGHT_IMG, oldR, oldC, mazeCollision)), bgStage);
                                break;
                            case "left":
                                renderObject(maze.addPoint(new Point(UP_TO_LEFT_IMG, oldR, oldC, mazeCollision)), bgStage);
                                break;
                            case "up":
                                renderObject(maze.addPoint(new Point(DOWN_TO_UP_IMG, oldR, oldC, mazeCollision)), bgStage);
                                break;
                        }
                        break;
                     
                    case "down":
                        switch(dir) {
                            case "right":
                                renderObject(maze.addPoint(new Point(DOWN_TO_RIGHT_IMG, oldR, oldC, mazeCollision)), bgStage);
                                break;
                            case "left":
                                renderObject(maze.addPoint(new Point(DOWN_TO_LEFT_IMG, oldR, oldC, mazeCollision)), bgStage);
                                break;
                            case "down":
                                renderObject(maze.addPoint(new Point(UP_TO_DOWN_IMG, oldR, oldC, mazeCollision)), bgStage);
                                break;
                        }
                        break;
                    default:
                         case "right":
                             renderObject(maze.addPoint(new Point(LEFT_TO_RIGHT_IMG, oldR, oldC, mazeCollision)), bgStage);
                             break;
                         case "left":
                             renderObject(maze.addPoint(new Point(RIGHT_TO_LEFT_IMG, oldR, oldC, mazeCollision)), bgStage);
                             break;
                         case "up":
                             renderObject(maze.addPoint(new Point(DOWN_TO_UP_IMG, oldR, oldC, mazeCollision)), bgStage);
                             break;
                         case "down":
                             renderObject(maze.addPoint(new Point(UP_TO_DOWN_IMG, oldR, oldC, mazeCollision)), bgStage);
                             break;
                        
                        break;

                    }
                
                lastDir = dir;
                }

        }
	}

/*
 * updates the current score by adding p points to it
 */
function updateScore(p) {
       SCORE += p;
}

/*
 * prints the new score
 */
function renderScore() {
        $('#total_score').text(TOTAL_SCORE);
        $('#level_score').text(LEVEL_SCORE);
        $('#current_level').text(CURRENT_LEVEL+1);
}

/*************************************/
/* Rendering functions               */
/*************************************/

function renderObject($obj, stage) {
	var xy=maze.grid2canvas($obj.r, $obj.c);
    var x = xy[0]+$obj.xOffset;
    var y = xy[1]+$obj.yOffset;
//    if (ISOMETRIC) {
//	    x=getScreenX(x,y)+$obj.xOffset;
//	    y=getScreenY(x,y)+$obj.yOffset;
//    }
	try {
		stage.drawImage($obj.img,x,y, $obj.img.width*SPRITE_SCALE, $obj.img.height*SPRITE_SCALE);
	} catch($error) {}
}

/* Only used in Isometric mode */
function getScreenX($x,$y) {
	var x=(($x-$y)*COS)+X_ORIGIN;
	//var x=(($x-$y)*COS);
	return x;
}

function getScreenY($x,$y) {
	var y=Y_ORIGIN-(($x+$y)*SIN);
	//var y=(($x+$y)*SIN);
	return y;
}

//Main functions held in respective pages.
