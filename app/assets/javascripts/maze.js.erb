/* Copyright 2013 Mark Thomas (mr.thomas gmail)
*/

/*************************************/
/* Global variables                  */
/*************************************/

var pdm = {};
pdm.state = {};

/* Graphics */
var SPRITE_SCALE = 2;
var BASE_W = 32;
var BASE_H= 16;
var GRID_W = BASE_W*SPRITE_SCALE;
var GRID_H = BASE_H*SPRITE_SCALE;
var OPTIONS_BAR_HEIGHT = 128;
var WALL_PAD=10*SPRITE_SCALE;
var MAX_COLS = Math.floor(900/GRID_W);
var MAX_ROWS = Math.floor(500/GRID_H);
var DEFAULT_WALL_YOFFSET = -10*SPRITE_SCALE;	//Need to get rid of this hack eventually
var DEFAULT_STARTPT_YOFFSET = -13*SPRITE_SCALE;
var DEFAULT_GOAL_YOFFSET = -GRID_H;
var DEBUG = false;
var BORDER_IMG; 
var SNAKE_IMG; 
var GOAL_IMG; 
var STAR_IMG; 
var PANDA_IMG;
var PORTAL_IMG;
var HEAD_UP_IMG;
var HEAD_DOWN_IMG;
var HEAD_LEFT_IMG;
var HEAD_RIGHT_IMG;
var TAIL_UP_IMG;
var TAIL_DOWN_IMG;
var TAIL_LEFT_IMG;
var TAIL_RIGHT_IMG;
var DOWN_TO_LEFT_IMG;
var DOWN_TO_RIGHT_IMG;
var DOWN_TO_UP_IMG;
var LEFT_TO_DOWN_IMG;
var LEFT_TO_RIGHT_IMG;
var LEFT_TO_UP_IMG;
var RIGHT_TO_DOWN_IMG;
var RIGHT_TO_LEFT_IMG;
var RIGHT_TO_UP_IMG; 
var TILES_IMG_ARRAY;
var WALL_BLOCK_IMG;
var PILLAR_IMG;
var VERTICAL_WALL_IMG;
var HORIZONTAL_WALL_IMG;
var DELETE_IMG;
var PIX_IMG;
var WALL_9S_TL_IMG;
var WALL_9S_TC_IMG;
var WALL_9S_TR_IMG;
var WALL_9S_ML_IMG;
var WALL_9S_MC_IMG;
var WALL_9S_MCTR_IMG;
var WALL_9S_MCTL_IMG;
var WALL_9S_MCBR_IMG;
var WALL_9S_MCBL_IMG;
var WALL_9S_MR_IMG;
var WALL_9S_BL_IMG;
var WALL_9S_BC_IMG;
var WALL_9S_BR_IMG;
var MAP_IMG;
var COMPLETE_IMG;
var CROWN_IMG;
var MAP_DRAGON_IMG;

//Hacky way to get images to JSON.stringify. See removeCyclicalStructures
var IMG_PREFIX = "img";
var IMG_CACHE = {};

var POST_ASSET_load_FN; //hacky way to get images to load in lb

var IMGDIR ="assets"
var AUDIODIR ="assets"
var LOAD_ASSETS = true;
var INIT_GAME = true;


/* Maze encoding variables */
var ENC_W = 2; //num of digits per point in a string
var DEFAULT_BASE = 16; //Default digit base for string output (currently hexadecimal)
var WI = 0;
var SIZEI = 1;

/* Isometric rendering */
var COS=Math.cos(0.46365);
var SIN=Math.sin(0.46365);
//var X_ORIGIN=540;
//var Y_ORIGIN=420;
var X_ORIGIN=240;
var Y_ORIGIN=400;
var ISOMETRIC = false;

/* I/O */
var LEFT_ARROW=37;
var UP_ARROW=38;
var RIGHT_ARROW=39;
var DOWN_ARROW=40;
var ESC=27;
var MOVE_DELAY=10;

/* Game */
pdm.state.map = undefined; // holds the current world.
var LEVELS_INITED = false;
//var pdm.state.currentLevel; //Will be set during init
//var pdm.state.totalScore; //Will be set during init
var LEVEL_SCORE= 0;
var EARNED_POINTS = { "5": 40, "10": 20, "15": 40, "bonus" : 1000};

var GAME_STATES = {
  UNINIT : "uninit",
  READY : "ready?",
  FAILED: "Maze failed!",
  PLAYING: "playing",
  COMPLETE: "Maze complete!",
  PAUSED: "Paused",
  GAME_COMPLETE: "Game complete!"
}

/* Game elements */
var loadFlags = [];
var gameCanvas; // canvas for moving elements
var gameStage;  
var wallCanvas;  // canvas for static background
var wallStage;	// stage for rendering walls
var mapCanvas;  // canvas for dragon body
//var mapStage;	// stage for rendering dragon body
var tileCanvas;  // canvas for static background
var tileStage;  // canvas for static background
var game_state = GAME_STATES.UNINIT;
var PREPAUSE_GAME_STATE;
var request;
var dragon;
var maze; //the current maze
var dir;
var lastDir;
var nextDir;
var counter;
var TYPES = {
	BLANK : 0,
	WALL : 1,
	PANDA : 2,
	GOAL: 3,
	START: 4, 
}

var POINTS = {};
POINTS[TYPES.WALL] =  WallPoint;
POINTS[TYPES.PANDA] = PandaPoint;
POINTS[TYPES.GOAL] = GoalPoint;
POINTS[TYPES.START] = StartPoint;

var BLANK = undefined; //Value for ablank space.

/* Audio */
var CHANNEL_MAX = 10;   // number of simultaneous audio channels to allow
var AUDIOCHANNELS = new Array(); // Array of audio elements (initialized below)
var PLAY_FX = true; // whether or not to play sound effects
var PLAY_THEME = true; // whether or not to play sound effects
var AUDIO_SRC= {};  //Caches the playable source strings from the audio elements
var OGG_STR = "audio/ogg";
var THEME;

/*************************************/
/* Game objects                      */
/*************************************/

/*A maze object is a collection of points
 @arg img a an image object to render for this point
 @arg r the row of this object in the maze grid
 @arg c the column of this objection in the maze grid
 @arg isOnFn the function which will be called if the dragon lands on this point
 @arg pointType the type ID for this point
 @arg yoff optional yoffset in pixels
 @arg xoff optiona xoffset in pixels
*/
function Point(img,r, c, isOnFn, pointType, yoff, xoff) {
	this.img=img;
	this.r=r;
	this.c=c;
    this.isOn = isOnFn;
	this.yOffset= (yoff) ? yoff : 0;
	this.xOffset= (xoff) ? xoff : 0;
    this.obj_type=pointType;
}

/*
 * Returns an object with two components
 *   - obj.pt the first point object encoded in the given string or undefined if blank
 *   - obj.n (num_chars_read_from_s)/pad_w
 * Arguments:
 * s a string with the first pad_w digits specifying a point type
 * r the row for this point
 * c the column for this point 
 * base the base in which elements in this string have been encoded
 * pad_w the encoding width in number of digits in base for each point 
 */
function PointFactory (s, r, c, base, pad_w) {
	var base = (base) ? base : DEFAULT_BASE;
	var pad_w = (pad_w) ? pad_w : ENC_W;
	var n = 1;
	var t = parseInt(s.substring(0, pad_w), base);
	var pt = undefined;
	
	switch (t) {
		case TYPES.GOAL:
			// Next encoded digit specifies destination
			var d = parseInt(s.substring(pad_w, 2*pad_w), base);
			n += 1;
			pt = new POINTS[t](r,c,d);
			break;
		case TYPES.BLANK:
			//Blank points should keep the point undefined, so do nothing here.
			break;
		default:
			//Simple version for most points
			pt = new POINTS[t](r,c);
	}
	return {"pt" : pt, "n" : n };
}

/* Encodes the point as a string. See Maze.prototype.toString for more information. */
Point.prototype.toString = function(base, pad_w){
	//Set default vars
	var base = (base) ? base : DEFAULT_BASE;
	var pad_w = (pad_w) ? pad_w : ENC_W;
	switch(this.obj_type) {
		case TYPES.GOAL:
			if (this.destination!=0 && !this.destination) {
				throw "Error: goal point at " + this.r + ", " + this.c + " has no destination!"
				return undefined;
			} else {
				return pad(Number(this.obj_type).toString(base), pad_w) + pad(Number(this.destination).toString(base), pad_w);
			}
			break;
		case undefined:
			console.log("Warning: point at " + this.r + "," + this.c + " has no type! Assuming it is blank.");
			return pad(Number(TYPES.BLANK).toString(base), pad_w);
			break;
		default:
			return pad(Number(this.obj_type).toString(base), pad_w);
	}
}

/* A Wall in the maze */
function WallPoint(r,c)  {
	return new Point(WALL_BLOCK_IMG, r, c, mazeCollision, TYPES.WALL, DEFAULT_WALL_YOFFSET);
}

/* A goal. 
 * dest: an int ID for another maze where this goal will take you.
 */ 
function GoalPoint(r, c, dest)  {
	var pt = new Point(PORTAL_IMG, r, c, mazeComplete(dest), TYPES.GOAL, DEFAULT_GOAL_YOFFSET);
	pt.destination = dest;
	return pt;
}

//A Panda
function PandaPoint(r,c) {
	return new Point(PANDA_IMG, r, c, collectBonus, TYPES.PANDA, -20, 10);
}

//Dragon starting point
function StartPoint(r,c) {
	return new Point(HEAD_DOWN_IMG, r, c, function () {}, TYPES.START, DEFAULT_STARTPT_YOFFSET);
}

//Special point for background tiles. These are used initially to render
//background images only, so there's no need for an isOn function
function TilePoint(r, c) {
   var img = TILES_IMG_ARRAY[Math.floor(Math.random()*TILES_IMG_ARRAY.length)];
   return new Point(img, r, c, null); 
}

/* A maze */
function Maze (s) {
	if (!s) { throw "Maze must be initialized with a valid string"; }
    this.doneBonuses = 0;
    this.gotBonuses = 0;
	this.s = s;
	this.maxPandas = 0;
	this.load(s);
	this.xOffset = 0;
	this.yOffset = -DEFAULT_WALL_YOFFSET;
}

Maze.prototype.reset = function() {
	this.load(this.s);
	//enter the maze from where you exited the last one.
	if (pdm.state.exitr && pdm.state.exitc && pdm.state.exitdir) {
		maze.setEntry(pdm.state.exitr, pdm.state.exitc, pdm.state.exitdir);
	}
}

// Sets the Maze's size in rows (height) and columns (width)
Maze.prototype.setSize = function (r,c) {
	this.rows = r;
	this.cols = c;
}

//Sets the entry row/column for this maze
Maze.prototype.setEntry = function(r,c, dir) {
	var tr, tc;
	switch (r) {
		case MAX_ROWS:
			this.er = 2;
			tr = 1;
			break;
		case 1:
			this.er = MAX_ROWS-1;
			tr = MAX_ROWS;
			break;
		default:
			this.er = tr = r;
			break;
	}
	switch (c) {
		case MAX_COLS:
			this.ec = 2;
			tc = 1;
			break;
		case 1:
			this.ec = MAX_COLS-1;
			tc = MAX_COLS;
			break;
		default:
			this.ec = tc = c;
	}
	//Make sure the tail image for the exit row is correct.
	this.getPoint(tr,tc).img = getTailImg(dir);
}

// Sets the Dragon's starting/drop point
// Note this will be overridden by the entry point unless being dropped.
Maze.prototype.setStart = function(r,c) {
	this.sr = r;
	this.sc = c;
}

Maze.prototype.unsetStart = function() {
	this.sr = undefined;
	this.sc = undefined;	
}

//Given a row and a column, returns an array with x and y pixel coordinates
Maze.prototype.grid2canvas= function (r, c) {
	return {"x" : ((c-1) * GRID_W + this.xOffset),
            "y" : ((r-1) * GRID_H + this.yOffset)
			};
}

Maze.prototype.getCenterX = function () {
	return Math.round(((this.cols)*GRID_W+this.xOffset)/2);
}

Maze.prototype.getCenterY = function () {
	return Math.round(((this.rows)*GRID_H+this.yOffset)/2);
}

Maze.prototype.getEntry = function () {
	return (this.er && this.ec) ? {"r" : this.er, "c" : this.ec} : undefined;
 	//return [this.er, this.ec];
}

Maze.prototype.getStart = function () {
	return (this.sr && this.sc) ? {"r" : this.sr, "c" : this.sc} : undefined;
 	//return (this.sr && this.sc) ? [this.sr, this.sc] : undefined;
}

Maze.prototype.collectBonus = function(){
    this.gotBonuses +=1;
    LEVEL_SCORE += EARNED_POINTS['bonus'];
}

Maze.prototype.complete = function () {
   this.doneBonuses = this.gotBonuses;
   if (this.doneBonuses==this.maxPandas) {
		pdm.state.map.levels[pdm.state.currentLevel].completed = true;
	}
	setHeadImg(maze.getPoint(dragon.r, dragon.c), dir);
	pdm.state.exitr = dragon.r;
	pdm.state.exitc = dragon.c;
	pdm.state.exitdir = dir;
	pdm.state.map.levels[pdm.state.currentLevel].currentMazeStr = this.toString();
}

Maze.prototype.addBorders = function () {
	for (var i =1; i<=this.rows; i++) {
		if (!this.hasPoint(i,1)) {
			this.addPoint(new WallPoint(i,1));
		}
		if (!this.hasPoint(i,this.cols)) {
			this.addPoint(new WallPoint(i,this.cols));
		}
		for (var j=1; j<=this.cols; j++){
			if (!this.hasPoint(1, j)) {
				this.addPoint(new WallPoint(1,j));				
			}
			if (!this.hasPoint(this.rows,j)){
				this.addPoint(new WallPoint(this.rows,j));
			}
		}
	}
	
	this.fixWallImages();
}

/* Deletes all objects on the borders of the maze */
Maze.prototype.removeBorders = function () {
	for (var i =1; i<=this.rows; i++) {
			this.removePoint(i,1);
			this.removePoint(i,this.cols);
		for (var j=1; j<=this.cols; j++){
				this.removePoint(1,j);				
				this.removePoint(this.rows,j);
		}
	}
}

//Fn for extending the length of a hex string to <width> chars
function pad(hexstr, width) {
	var p = width - hexstr.length;
	if (p >0) { return Array(p+1).join("0")+hexstr; }
	else if (p<0) { throw "Too long to encode into a Maze string "+hexstr;}
	else { return hexstr; }
};

/* Returns a string representation of this maze
*  Maze string representation:
*  1 hex digit for number of hex digits per square (N)
*  N hex digits for num rows (R)
*  N hex digits for num cols (C)
*  N hex digits for each of the RxC squares in the maze
*/
Maze.prototype.toString = function () {
	var s = "" + Number(ENC_W).toString(DEFAULT_BASE) + 
					pad(Number(this.rows).toString(DEFAULT_BASE), ENC_W) +
					pad(Number(this.cols).toString(DEFAULT_BASE),ENC_W);
	try {
		for (var i = 0; i< this.rows; i++) {
			for ( var j = 0; j<this.cols; j++) {

				if (i+1 == this.sr && j+1 == this.sc) {
					s+=new StartPoint(i+1, j+1).toString();
				} else {
						s+= (this.points[i][j]) ? this.points[i][j].toString(DEFAULT_BASE, ENC_W) : pad( Number(TYPES.BLANK).toString(DEFAULT_BASE), ENC_W);
				}
			}
		}
	} catch (err){
		console.log("Error at row " + (i+1) + " and column " + (j+1) + 
			"\n"+ err.message);
		return null;
	}
	return s;
}

/* Constructs a maze given a string rep of a maze (see toString above) */
Maze.prototype.load = function(s) {
	try {
		var base = 16; //TODO: need to read this from the string.
		var w      = parseInt(s.charAt(WI), base);
		var rows   = parseInt(s.substring(SIZEI,SIZEI+w), base);
		var cols   = parseInt(s.substring(SIZEI+w, SIZEI+2*w), base); 
		var head_len  = SIZEI+2*w;
		//FIXME: not as easy to verify length of string when points contain extra info (e.g. goal points)
		// if (s.length != head_len + rows*cols*w) {
		// 	throw "Invalid maze string length. Expected: "+(head_len+rows*cols*w) + " Actual: " + s.length;
		// }
		this.setSize(rows, cols);
		this.initPoints();
		this.maxPandas = 0;
		var r = 1;
		var c = 1;
		for (var i = head_len; i < s.length; i+=w) {
			var pt_n    = PointFactory(s.substring(i, s.length), r, c, base, w);
			i += (pt_n.n - 1) * w;	//If we read more than one encoded char, advance the incr accordingly
			if (pt_n.pt) { 
				this.addPoint(pt_n.pt); 
			}		
			//Keep track of which row/column we're on. Note that maze is loaded in columns-first order.
			c += 1;
			if (c > this.cols) {
				c = 1;
				r += 1;
			}
		}
		if (!(this.getStart())) {
			throw "Maze has no starting point defined!";
		}
	} catch (err) {
		throw "Error loading maze: " + err;
	}
	this.fixWallImages();
}

/* initializes the points array for this Maze */
Maze.prototype.initPoints = function() {
	if (!(this.rows && this.cols)) {
		throw "Rows and columns are undefined. Cannot initialize points.";
	}
	this.points = [];
	this.gotBonuses = 0;
	for (var i=0; i<this.rows; i++){
		this.points[i]=[];
		this.points[i][this.cols-1]=BLANK;
 	}
}

Maze.prototype.fixWallImages = function() {
    for (var i = 0; i<this.rows; i++) {
        for (var j= 0; j<this.cols;j++) {
           //We only care about walls, so skip everything else
//            try {
//           		if (!this.points[i][j] || !this.isType(i,j,TYPES.WALL) ||
//									!this.isType(i,j,TYPES.GOAL)) {
//           		     continue;
//           		 }
//            } catch(err) {
//                console.log("Error fixing wall images! i="+i+" j="+j);
//            }


			if (this.isType(i,j,TYPES.GOAL) && 
						(i == 0 || i == this.rows-1 || j == 0 || j == this.cols-1)) {
						this.points[i][j].img = (DEBUG) ? PIX_IMG : undefined;
	          			this.points[i][j].yOffset=0;
			} else if (this.isType(i,j,TYPES.WALL)) {
					//TODO: fixme! Reset wall offset
					this.points[i][j].yOffset=DEFAULT_WALL_YOFFSET;
					//Build 9-slice
					if (this.isType(i-1,j-1,TYPES.WALL) &&
							this.isType(i-1,j,TYPES.WALL) &&
							this.isType(i-1,j+1,TYPES.WALL) &&
							this.isType(i,j-1,TYPES.WALL) &&
							this.isType(i,j,TYPES.WALL) &&
							this.isType(i,j+1,TYPES.WALL) &&
							this.isType(i+1,j-1,TYPES.WALL) &&
							this.isType(i+1,j,TYPES.WALL) &&
							this.isType(i+1,j+1,TYPES.WALL)) {
								//Middle-center wall
								this.points[i][j].img=WALL_9S_MC_IMG;
				           //   this.points[i][j].yOffset=0;
							} else if (
								this.isType(i-1,j-1,TYPES.WALL) &&
								this.isType(i-1,j,TYPES.WALL) &&
								this.isType(i-1,j+1,TYPES.WALL) &&
								this.isType(i,j-1,TYPES.WALL) &&
								this.isType(i,j,TYPES.WALL) &&
								this.isType(i,j+1,TYPES.WALL) &&
								!(this.isType(i+1,j-1,TYPES.WALL) &&
									this.isType(i+1,j,TYPES.WALL)) &&
								!(this.isType(i+1,j+1,TYPES.WALL) && 
									this.isType(i+1,j,TYPES.WALL))) {
									//Bottom-center wall
									this.points[i][j].img=WALL_9S_BC_IMG;
	            	  				//this.points[i][j].yOffset=0;
							} else if (
								!(this.isType(i-1,j-1,TYPES.WALL) &&
									this.isType(i-1,j,TYPES.WALL)) &&
								!(this.isType(i-1,j+1,TYPES.WALL) &&
									this.isType(i-1,j,TYPES.WALL)) &&
								this.isType(i,j-1,TYPES.WALL) &&
								this.isType(i,j,TYPES.WALL) &&
								this.isType(i,j+1,TYPES.WALL) &&
								this.isType(i+1,j-1,TYPES.WALL) &&
								this.isType(i+1,j,TYPES.WALL) &&
								this.isType(i+1,j+1,TYPES.WALL)) {
									//top-center wall
									this.points[i][j].img=WALL_9S_TC_IMG;
	            	  				//this.points[i][j].yOffset=0;
							} else if (
								!(this.isType(i-1,j-1,TYPES.WALL) &&
									this.isType(i,j-1,TYPES.WALL)) &&
								this.isType(i-1,j,TYPES.WALL) &&
								this.isType(i-1,j+1,TYPES.WALL) &&
								this.isType(i,j,TYPES.WALL) &&
								this.isType(i,j+1,TYPES.WALL) &&
								!(this.isType(i+1,j-1,TYPES.WALL) &&
									this.isType(i,j-1,TYPES.WALL)) &&
								this.isType(i+1,j,TYPES.WALL) &&
								this.isType(i+1,j+1,TYPES.WALL)) {
									//middle-left wall
									this.points[i][j].img=WALL_9S_ML_IMG;
	            	  				//this.points[i][j].yOffset=0;
							} else if (
								this.isType(i-1,j,TYPES.WALL) &&
								this.isType(i-1,j+1,TYPES.WALL) &&
								!(this.isType(i-1,j-1,TYPES.WALL) &&
								  this.isType(i,j-1,TYPES.WALL)) &&
								this.isType(i,j,TYPES.WALL) &&
								this.isType(i,j+1,TYPES.WALL) &&
								!(this.isType(i+1,j,TYPES.WALL) &&
								  this.isType(i+1,j+1,TYPES.WALL))) {
									//bottom-left wall
									this.points[i][j].img=WALL_9S_BL_IMG;
	            	  				//this.points[i][j].yOffset=0;
							} else if (
								!(this.isType(i-1,j,TYPES.WALL) &&
									this.isType(i-1,j+1,TYPES.WALL)) &&
								!(this.isType(i,j-1,TYPES.WALL) &&
									this.isType(i+1,j-1,TYPES.WALL)) &&
								this.isType(i,j,TYPES.WALL) &&
								this.isType(i,j+1,TYPES.WALL) &&
								this.isType(i+1,j,TYPES.WALL) &&
								this.isType(i+1,j+1,TYPES.WALL)) {
									//top-left wall
									this.points[i][j].img=WALL_9S_TL_IMG;
	            	  				//this.points[i][j].yOffset=0;
							} else if (
								this.isType(i-1,j-1,TYPES.WALL) &&
								this.isType(i-1,j,TYPES.WALL) &&
								!(this.isType(i-1,j+1,TYPES.WALL) &&
									this.isType(i,j+1,TYPES.WALL)) &&
								this.isType(i,j-1,TYPES.WALL) &&
								this.isType(i,j,TYPES.WALL) &&
								this.isType(i+1,j-1,TYPES.WALL) &&
								this.isType(i+1,j,TYPES.WALL) &&
								!(this.isType(i,j+1,TYPES.WALL) &&
								this.isType(i+1,j+1,TYPES.WALL))) {
									//middle-right wall
									this.points[i][j].img=WALL_9S_MR_IMG;
	            	  				//this.points[i][j].yOffset=0;
							} else if (
								this.isType(i-1,j-1,TYPES.WALL) &&
								this.isType(i-1,j,TYPES.WALL) &&
								!(this.isType(i-1,j+1,TYPES.WALL) &&
									this.isType(i,j+1,TYPES.WALL)) &&
								this.isType(i,j-1,TYPES.WALL) &&
								this.isType(i,j,TYPES.WALL) &&
								!(this.isType(i+1,j-1,TYPES.WALL) &&
									this.isType(i+1,j,TYPES.WALL))) {
									//bottom-right wall
									this.points[i][j].img=WALL_9S_BR_IMG;
	            	  				//this.points[i][j].yOffset=0;
							} else if (
								!(this.isType(i-1,j-1,TYPES.WALL) &&
									this.isType(i-1,j,TYPES.WALL)) &&
								this.isType(i,j-1,TYPES.WALL) &&
								this.isType(i,j,TYPES.WALL) &&
								!(this.isType(i,j+1,TYPES.WALL) &&
									this.isType(i+1,j+1,TYPES.WALL)) &&
								this.isType(i+1,j-1,TYPES.WALL) &&
								this.isType(i+1,j,TYPES.WALL)) {
									//top-right wall
									this.points[i][j].img=WALL_9S_TR_IMG;
	            	  				//this.points[i][j].yOffset=0;
							} else if (this.isType(i-1,j-1,TYPES.WALL) &&
                this.isType(i-1,j,TYPES.WALL) &&
                this.isType(i-1,j+1,TYPES.WALL) &&
                this.isType(i,j-1,TYPES.WALL) &&
                this.isType(i,j,TYPES.WALL) &&
                this.isType(i,j+1,TYPES.WALL) &&
                this.isType(i+1,j-1,TYPES.WALL) &&
                this.isType(i+1,j,TYPES.WALL) &&
                !this.isType(i+1,j+1,TYPES.WALL)) {
                    //9-slice with bottom-right missing
                    this.points[i][j].img = WALL_9S_MCBR_IMG;
                    //this.points[i][j].yOffset=0;
              } else if (this.isType(i-1,j-1,TYPES.WALL) &&
                this.isType(i-1,j,TYPES.WALL) &&
                this.isType(i-1,j+1,TYPES.WALL) &&
                this.isType(i,j-1,TYPES.WALL) &&
                this.isType(i,j,TYPES.WALL) &&
                this.isType(i,j+1,TYPES.WALL) &&
                !this.isType(i+1,j-1,TYPES.WALL) &&
                this.isType(i+1,j,TYPES.WALL) &&
                this.isType(i+1,j+1,TYPES.WALL)) {
                    //9-slice with bottom-left missing
                    this.points[i][j].img = WALL_9S_MCBL_IMG;
                    //this.points[i][j].yOffset=0;
              } else if (this.isType(i-1,j-1,TYPES.WALL) &&
                this.isType(i-1,j,TYPES.WALL) &&
                !this.isType(i-1,j+1,TYPES.WALL) &&
                this.isType(i,j-1,TYPES.WALL) &&
                this.isType(i,j,TYPES.WALL) &&
                this.isType(i,j+1,TYPES.WALL) &&
                this.isType(i+1,j-1,TYPES.WALL) &&
                this.isType(i+1,j,TYPES.WALL) &&
                this.isType(i+1,j+1,TYPES.WALL)) {
                    //9-slice with top-right missing
                    this.points[i][j].img = WALL_9S_MCTR_IMG;
                    //this.points[i][j].yOffset=0;
              } else if (
                !this.isType(i-1,j-1,TYPES.WALL) &&
                this.isType(i-1,j,TYPES.WALL) &&
                this.isType(i-1,j+1,TYPES.WALL) &&
                this.isType(i,j-1,TYPES.WALL) &&
                this.isType(i,j,TYPES.WALL) &&
                this.isType(i,j+1,TYPES.WALL) &&
                this.isType(i+1,j-1,TYPES.WALL) &&
                this.isType(i+1,j,TYPES.WALL) &&
                this.isType(i+1,j+1,TYPES.WALL)) {
                    //9-slice with top-left missing
                    this.points[i][j].img = WALL_9S_MCTL_IMG;
                    //this.points[i][j].yOffset=0;
              } else if (this.isType(i,j-1,TYPES.WALL) &&
								this.isType(i, j+1, TYPES.WALL) &&
								(this.isType(i+1, j, TYPES.WALL) ||
									this.isType(i-1, j, TYPES.WALL))) {
											//Fix T-shaped and inverse T-shaped walls
											this.points[i][j].img=WALL_BLOCK_IMG;
	                						//this.points[i][j].yOffset=0;
							 } else if (this.isType(i-1,j,TYPES.WALL) && 
											this.isType(i+1,j,TYPES.WALL) &&
											(this.isType(i,j-1,TYPES.WALL) ||
													this.isType(i,j+1,TYPES.WALL))) {
													//Fix -| and |- walls
													this.points[i][j].img = WALL_BLOCK_IMG;
                      								//this.points[i][j].yOffset=0;
							} else if (this.isType(i-1,j,TYPES.WALL) &&
							  this.isType(i+1,j,TYPES.WALL) &&
							  !this.isType(i, j-1, TYPES.WALL) &&
								!this.isType(i,j+1, TYPES.WALL)) {
                    				//Fix vertical wall image
				                    this.points[i][j].img=VERTICAL_WALL_IMG;
           	  } else if (this.isType(i,j-1,TYPES.WALL) &&
								this.isType(i, j+1, TYPES.WALL) &&
								!this.isType(i-1,j, TYPES.WALL) &&
								!this.isType(i+1,j, TYPES.WALL)) {
                    //Fix horizontal wall image
                    this.points[i][j].img=HORIZONTAL_WALL_IMG;
                    this.points[i][j].yOffset=-10;
              } else {
						//default to the pillar wall
						this.points[i][j].img = WALL_BLOCK_IMG; 
						//this.points[i][j].yOffset=-20;
        		}
		}
    }
  } 
}

/**
* Given a row, column and and object type, returns true if the point at
* at this.points[i][j] has obj_type==type
* Note that maze rows and columns are not 0-indexed (first row/col is 1,1).
*/
Maze.prototype.isType = function (i,j,type) {
	return (i>=0 && i<this.rows && j>=0 && j<this.cols &&
					this.points[i][j]!=undefined &&
					this.points[i][j].obj_type==type);
}

// Adds a point object to this Maze
Maze.prototype.addPoint = function(pt) {
	// Ensure you can only add points within the maze
	if (pt.r >0 && pt.r <= this.rows && pt.c > 0 && pt.c <= this.cols) {
		switch(pt.obj_type) {
			case TYPES.START:
				//We don't add start points to the maze
				this.setStart(pt.r, pt.c);
				break;
			case TYPES.PANDA:
				this.maxPandas += 1;
			default:
				this.points[pt.r-1][pt.c-1] = pt;			
		}
    	return pt;
	}
}

/* Removes a point object from this Maze */
Maze.prototype.removePoint = function(r, c) {
	if (r >0 && r <= this.rows && c > 0 && c <= this.cols) {
		var pt = this.points[r-1][c-1];
		switch(pt.obj_type) {
			case TYPES.START:
				//If you're removing a start, unset the start position
				this.unsetStart();
				break;
			default:
				this.points[r-1][c-1]=BLANK;			
		}
		return pt;
	}
}

/*
* Returns a point at r, c in the maze or undefined if none exists
*/
Maze.prototype.hasPoint = function(r, c) {
	return this.points[r-1][c-1];
}

Maze.prototype.getPoint = function(r,c) {
	if (r<=this.rows && r > 0 && c <= this.cols && c > 0) {
		return this.points[r-1][c-1];
	}
}

Maze.prototype.isOn = function (r, c) {
        var pt = this.getPoint(r,c);
        if (pt && pt.isOn) {
                pt.isOn();
        }
}

Maze.prototype.renderTiles = function (stage) {
	for (var i =0; i<this.rows; i++) {
		for (var j =0; j<this.cols; j++) {
            renderObject(new TilePoint(i+1, j+1), stage);
		}
	}
}

Maze.prototype.render = function (stage) {
	for (var i =0; i<this.rows; i++) {
		for (var j =0; j<this.cols; j++) {
            //render the background tiles the first time we render the maze.
            // if (game_state != GAME_STATES.FAILED) {
            //      renderObject(new TilePoint(i+1, j+1),tileStage);
            //  }
 			if (this.points[i][j]) {
				renderObject(this.points[i][j], stage);
			}
		}
	}
}


Maze.prototype.addDragonBody = function(dir, lastDir, oldR, oldC) {
            switch(lastDir) {
                    case "start":
                        maze.addPoint(new Point(getTailImg(dir),
                            oldR, oldC, mazeCollision));
                        break;
                    case "left":
                        switch(dir) {
                            case "left":
                                maze.addPoint(new Point(LEFT_TO_RIGHT_IMG, oldR, oldC, mazeCollision));
                                break;
                            case "up":
                                maze.addPoint(new Point(LEFT_TO_UP_IMG, oldR, oldC, mazeCollision));
                                break;
                            case "down":
                                maze.addPoint(new Point(LEFT_TO_DOWN_IMG, oldR, oldC, mazeCollision));
                                break;
                        }
                        break;

                    case "right":
                        switch(dir) {
                            case "right":
                                maze.addPoint(new Point(RIGHT_TO_LEFT_IMG, oldR, oldC, mazeCollision));
                                break;
                            case "up":
                                maze.addPoint(new Point(RIGHT_TO_UP_IMG, oldR, oldC, mazeCollision));
                                break;
                            case "down":
                                maze.addPoint(new Point(RIGHT_TO_DOWN_IMG, oldR, oldC, mazeCollision));
                                break;
                        }
                        break;

                    case "up":
                        switch(dir) {
                            case "right":
                                maze.addPoint(new Point(UP_TO_RIGHT_IMG, oldR, oldC, mazeCollision));
                                break;
                            case "left":
                                maze.addPoint(new Point(UP_TO_LEFT_IMG, oldR, oldC, mazeCollision));
                                break;
                            case "up":
                                maze.addPoint(new Point(DOWN_TO_UP_IMG, oldR, oldC, mazeCollision));
                                break;
                        }
                        break;

                    case "down":
                        switch(dir) {
                            case "right":
                                maze.addPoint(new Point(DOWN_TO_RIGHT_IMG, oldR, oldC, mazeCollision));
                                break;
                            case "left":
                                maze.addPoint(new Point(DOWN_TO_LEFT_IMG, oldR, oldC, mazeCollision));
                                break;
                            case "down":
                                maze.addPoint(new Point(UP_TO_DOWN_IMG, oldR, oldC, mazeCollision));
                                break;
                        }
                        break;
                    default:
                        switch(dir) {
                            case "right":
                                 maze.addPoint(new Point(LEFT_TO_RIGHT_IMG, oldR, oldC, mazeCollision));
                                 break;
                             case "left":
                                 maze.addPoint(new Point(RIGHT_TO_LEFT_IMG, oldR, oldC, mazeCollision));
                                 break;
                             case "up":
                                 maze.addPoint(new Point(DOWN_TO_UP_IMG, oldR, oldC, mazeCollision));
                                 break;
                             case "down":
                                 maze.addPoint(new Point(UP_TO_DOWN_IMG, oldR, oldC, mazeCollision));
                                 break;
                        }
                }
}

/*************************************/
/* Maze events                       */
/*************************************/

function cleanUp() {
    printState();
    stopGameLoop();
}

function mazeCollision() {
    game_state = GAME_STATES.FAILED;
    stopMusic();
    playMultiSound('defeat');
    LEVEL_SCORE = 0;
    cleanUp();
}

function mazeComplete(dest) {
	return function () {
 	    game_state = GAME_STATES.COMPLETE;
	    stopMusic();
	    playMultiSound('victory');
	    maze.complete();
	    pdm.state.totalScore += LEVEL_SCORE;
	    LEVEL_SCORE = 0;
	    pdm.state.currentLevel = dest;
	    saveGameState();
	    renderScore();
		renderScreen();
	    cleanUp();
	}
}

function collectBonus() {
    maze.collectBonus();
    playMultiSound('pick_up');
}

function gameComplete() {
    game_state = GAME_STATES.GAME_COMPLETE;
    pdm.state.currentLevel=0;
    // for (var i=0; i<pdm.state.map.levels.length;i++) {
    //     pdm.state.map.levels[i].initPoints();
    // }
    cleanUp();
}


// Sets the Dragon's head image based on direction
function setHeadImg(dragon, dir) {
 switch(dir) {
        case "left":
            dragon.img=HEAD_LEFT_IMG;
            dragon.yOffset = -15*SPRITE_SCALE;
            break;
        case "right":
            dragon.img=HEAD_RIGHT_IMG;
            dragon.yOffset = -15*SPRITE_SCALE;
            break;
        case "up":
            dragon.img=HEAD_UP_IMG;
            dragon.yOffset = -5*SPRITE_SCALE;
            break;
        case "down":
            dragon.img=HEAD_DOWN_IMG;
            dragon.yOffset = -15*SPRITE_SCALE;
            break;
		case "start":
			//leave it be
			break;
        default:
            dragon.img=HEAD_DOWN_IMG;
            dragon.yOffset = -15*SPRITE_SCALE;
            break;
    }
}


/*************************************/
/* Map 						         */
/*************************************/

//Creates levels given serialized JSON object. Used in revivePdm to recreate psuedoObjects
function MapFactory(o) {
	return new Map(o.img, o.rows, o.cols, o.gridH, o.gridW, o.levels, o.completeImg);
}


/* Defines a world map.
* All maps at present must be uniform size (900x500px). 
* They must also reserve the top 128 px for the options toolbar.
*/
function Map (img, rows, cols, gridH, gridW, levels, completeImg) {
	this.img = img;
	this.rows = rows;
	this.cols = cols;
	this.levels = levels;
	this.completeImg = completeImg;
	this.gridH = gridH;
	this.gridW = gridW;
	this.factory="MapFactory";
}

/*************************************/
/* Level   					         */
/*************************************/

//Creates levels given serialized JSON object. Used in revivePdm to recreate psuedoObjects
function LevelFactory(o) {
	return new Level(o.originalMazeStr, o.specialMapImg, o.currentMazeStr, o.completed, o.visited);	
}


/* 
* A Level. Levels are part of a particular map. They hold some state
* factory is the string name of a function which can create this object from JSON data.
*
*/
function Level (originalMazeStr, specialMapImg, currentMazeStr, completed, visited) {
	this.specialImg = (specialMapImg) ? specialMapImg : undefined;
	this.originalMazeStr = originalMazeStr;
	this.currentMazeStr = (currentMazeStr) ? currentMazeStr : originalMazeStr;
	this.completed = completed;
	this.visited = visited;
	this.factory ="LevelFactory";
}


/*************************************/
/* Utility functions                 */
/*************************************/


function replaceCyclicStructures(key, val) {
	//Modified version from http://hagsdev.blogspot.com/2012/06/cyclic-objects-and-jsonstringify.html
	if(typeof val=="object"){
	    var ot=Object.prototype.toString.call(val);
	    if(ot.search("object Object")>-1){
	      return val;
	    }else if(ot.search("HTMLImageElement")>-1){
	      return val.pdmId;
	    }
		//else if(ot.search("HTMLAudioElement")>-1){
	    //  return getAudioPath(val.src);
	    //}else{
	    //  //if(key!==""){
	    //  //  console.log(ot);
	    //  //  console.log(typeof(val)+" : "+key+" : "+val);
	    //  //}
	    //}
	  }
	  return val;
}


function revivePdm(key, val) {
	var factory;
	if (typeof val === "string" && val.substr(0,3) === "img") {
			return IMG_CACHE[val];
	} else if (val && typeof val === 'object') {
        factory = val.factory;
        if (typeof factory === 'string' && typeof window[factory] === 'function') {
            return (window[factory])(val);
        }
    }
	return val;
}

/*************************************/
/* Initialization functions          */
/*************************************/

function init(fn) { 
    POST_ASSET_LOAD_FN = fn;

    //Short-circuit if we don't want to load assets.
    if (!LOAD_ASSETS) { return;}
    loadAssets(); 


}

// Returns true if you can save games
pdm.canSave = function() {
	return typeof Storage !==undefined;
}

// Saves game
function saveGameState() {
	if (pdm.canSave()) {
		deleteSavedGame();
		localStorage.state = JSON.stringify(pdm.state, replaceCyclicStructures);
	} else {
		console.log("Whoops! Web storage not available. That means we can't save your game, so you'll have to beat it in one go like a boss. Go get 'em tiger.");
	}
//	try {
//		var s = JSON.stringify(pdm.state, replaceCyclicStructures);
//		$.cookie("state", s);
//	} catch (e) {
//			console.log(e.message);
//	}
}

pdm.hasSavedGame = function (){
	return pdm.canSave() && localStorage.state !== undefined;
	//return $.cookie("state");
}

//Initializes the game state and returns true if using saved game
function initGameState() {
	if (pdm.hasSavedGame()) {
			//pdm.state = JSON.parse($.cookie("state"), revivePdm);
			pdm.state = JSON.parse(localStorage.state, revivePdm);
			return true;
	} else {
		pdm.state.currentLevel = 0;
		pdm.state.totalScore =0;
		return false;
	}
}

function loadAssets() {
    if (ISOMETRIC) {
        GRID_W = 28;
        GRID_H = 28;
	    BORDER_IMG = createImgAsset("border", 
            "<%= asset_path('border_iso.png') %>");
	    SNAKE_IMG = createImgAsset("snake", 
            "<%= asset_path('snake_iso.png') %>");
	    GOAL_IMG = createImgAsset("goal",
            "<%= asset_path('goal_iso.png') %>");
    } else {
//	    BORDER_IMG = createImgAsset("border",
//            "<%= asset_path('border_19x19.png') %>");
//	    SNAKE_IMG = createImgAsset("dragon",
//            "<%= asset_path('mover_19x19.png') %>");
//	    GOAL_IMG = createImgAsset("goal",
//            "<%= asset_path('goal_19x19.png') %>");
//	    STAR_IMG = createImgAsset("star",
//            "<%= asset_path('star_19x19.png') %>");
	    PANDA_IMG = createImgAsset("panda",
            "<%= asset_path('Panda.png') %>");
	    PORTAL_IMG = createImgAsset("portal",
            "<%= asset_path('Goal_1.png') %>");
	    HEAD_UP_IMG = createImgAsset("head_up",
            "<%= asset_path('Head_Up.png') %>");
	    HEAD_DOWN_IMG = createImgAsset("head_down",
            "<%= asset_path('Head_Down.png') %>");
	    HEAD_LEFT_IMG = createImgAsset("head_left",
            "<%= asset_path('Head_Left.png') %>");
	    HEAD_RIGHT_IMG = createImgAsset("head_right",
            "<%= asset_path('Head_Right.png') %>");

	    TAIL_UP_IMG = createImgAsset("tail_up",
            "<%= asset_path('Tail_Up.png') %>");
	    TAIL_DOWN_IMG = createImgAsset("tail_down",
            "<%= asset_path('Tail_Down.png') %>");
	    TAIL_LEFT_IMG = createImgAsset("tail_left",
            "<%= asset_path('Tail_Right.png') %>");
	    TAIL_RIGHT_IMG = createImgAsset("tail_right",
            "<%= asset_path('Tail_Left.png') %>");
        DOWN_TO_LEFT_IMG = createImgAsset("dtl",
            "<%= asset_path('Body_UpToLeft.png') %>");
        DOWN_TO_RIGHT_IMG = createImgAsset("dtr",
            "<%= asset_path('Body_UpToRight.png') %>");
        DOWN_TO_UP_IMG = createImgAsset("dtu",
            "<%= asset_path('Body_DownToUp.png') %>");
        LEFT_TO_DOWN_IMG= createImgAsset("ltd",
            "<%= asset_path('Body_RightToDown.png') %>");
        LEFT_TO_RIGHT_IMG= createImgAsset("ltr",
            "<%= asset_path('Body_RightToLeft.png') %>");
        LEFT_TO_UP_IMG= createImgAsset("ltu",
            "<%= asset_path('Body_RightToUp.png') %>");
        RIGHT_TO_DOWN_IMG= createImgAsset("rtd",
            "<%= asset_path('Body_LeftToDown.png') %>");
        RIGHT_TO_LEFT_IMG= createImgAsset("rtl",
            "<%= asset_path('Body_LeftToRight.png') %>");
        RIGHT_TO_UP_IMG= createImgAsset("rtu",
            "<%= asset_path('Body_UpToLeft.png') %>");
        UP_TO_DOWN_IMG= createImgAsset("utd",
            "<%= asset_path('Body_UpToDown.png') %>");
        UP_TO_LEFT_IMG= createImgAsset("utl",
            "<%= asset_path('Body_DownToLeft.png') %>");
        UP_TO_RIGHT_IMG= createImgAsset("utr",
            "<%= asset_path('Body_DownToRight.png') %>");

        TILES_IMG_ARRAY= [];
        TILES_IMG_ARRAY.push(createImgAsset("tile_1",
              "<%= asset_path('tiles.png') %>"));
        TILES_IMG_ARRAY.push(createImgAsset("tile_2",
              "<%= asset_path('tiles_2.png') %>"));
        TILES_IMG_ARRAY.push(createImgAsset("tile_3",
              "<%= asset_path('tiles_3.png') %>"));
        TILES_IMG_ARRAY.push(createImgAsset("tile_4",
              "<%= asset_path('tiles_4.png') %>"));

				//load wall images
        VERTICAL_WALL_IMG = createImgAsset("vw",
            "<%= asset_path('wall_stright_horizontal.png') %>");
        HORIZONTAL_WALL_IMG = createImgAsset("hw",
            "<%= asset_path('wall_stright_vertical.png') %>");
	    WALL_BLOCK_IMG = createImgAsset("pillar",
          "<%= asset_path('wall_block.png') %>");

		WALL_9S_TL_IMG = createImgAsset('wall_9s_tl', 
          "<%= asset_path('wall_9slice_tl.png') %>");
		WALL_9S_TC_IMG = createImgAsset('wall_9s_tc', 
		    "<%= asset_path('wall_9slice_tc.png') %>");
		WALL_9S_TR_IMG= createImgAsset('wall_9s_tr', 
		    "<%= asset_path('wall_9slice_tr.png') %>");
		WALL_9S_ML_IMG= createImgAsset('wall_9s_ml', 
		    "<%= asset_path('wall_9slice_ml.png') %>");
		WALL_9S_MC_IMG = createImgAsset('wall_9s_mc', 
		    "<%= asset_path('wall_9slice_mc.png') %>");
		WALL_9S_MR_IMG= createImgAsset('wall_9s_mr', 
		    "<%= asset_path('wall_9slice_mr.png') %>");
		WALL_9S_BL_IMG= createImgAsset('wall_9s_bl', 
		    "<%= asset_path('wall_9slice_bl.png') %>");
		WALL_9S_BC_IMG= createImgAsset('wall_9s_bc', 
		    "<%= asset_path('wall_9slice_bc.png') %>");
		WALL_9S_BR_IMG= createImgAsset('wall_9s_br', 
          "<%= asset_path('wall_9slice_br.png') %>");

		//All the corner walls within a 9 slice are the same right now.
		//FIXME: add real images for 9-slice corners
		WALL_9S_MCTR_IMG= 
				WALL_9S_MCTL_IMG= 
				WALL_9S_MCBR_IMG= 
				WALL_9S_MCBL_IMG=
				WALL_9S_MC_IMG;

		//Only used in level builder
      		DELETE_IMG = createImgAsset("delete", 
            "<%= asset_path('delete.png') %>");
		PIX_IMG = createImgAsset('pix_1x1', "<%= asset_path('1x1.gif') %>");
		
		MAP_IMG = createImgAsset('map', "<%= asset_path('map.png') %>");
		COMPLETE_IMG = createImgAsset('complete_img', "<%= asset_path('map_complete_128x128.png') %>");
		CROWN_IMG = createImgAsset('crown_img', "<%= asset_path('map_crown_128x128.png') %>");
		MAP_DRAGON_IMG = createImgAsset('map_dragon_img', "<%= asset_path('map_dragon_128x128.png') %>");

		IMG_CACHE[MAP_IMG.pdmId] = MAP_IMG;
		IMG_CACHE[CROWN_IMG.pdmId] = CROWN_IMG;
		IMG_CACHE[COMPLETE_IMG.pdmId] = COMPLETE_IMG;
		

    }
}



function createImgAsset($id,$src) {
	var img=new Image();
	loadFlags[$id]=0;
	img.onload=function(){onAssetLoaded($id);};
	img.src=$src;
	img.pdmId = IMG_PREFIX + $id;
//    img.height = GRID_H;
//    img.width = GRID_W;
	return img;
}

function onAssetLoaded($asset_id) {
	loadFlags[$asset_id]=1;
    //Don't start the game until everything's been loaded
	for(flag in loadFlags) {
		if(!loadFlags[flag]) {return;}
	}
    //Only continue if we want to continue the game
    if (POST_ASSET_LOAD_FN) {POST_ASSET_LOAD_FN();}
    if (!INIT_GAME) { return;}
	game_init();
}

function game_init() {
    initSound();
	initUi();
	//Load game state if present, otherwise create initial state
    if (!initGameState()) {
		init_map();
	}
    maze_init();
}

function getTailImg(dir) {
	switch(dir) {
	    case "left":
	        return TAIL_LEFT_IMG;
	        break;
	    case "right":
	        return TAIL_RIGHT_IMG;
	        break;
	    case "up":
	        return TAIL_UP_IMG;
	        break;
	    case "down":
	        return TAIL_DOWN_IMG;
	        break;
	}
}

function initUi() {
    //Init configuration panel
    $("input[name=speed]:radio").click(function() {changeSpeed(this.value);});
    $("#ctrl_fx").click(function() {toggleFX(this.checked);});
    $("#ctrl_music").click(function() {toggleMusic(this.checked)});
    $("#options_link").click(function() {toggleOptions()});
    $("#options_done").click(function() {toggleOptions()});
    $("#options_done").click(function() {toggleOptions()});
    $("#home").click(function() {window.location="/"});

    //$("#quit").click(function() {quit()});
    //Set up graphics
	gameCanvas = document.getElementById('maze-canvas');
	wallCanvas = document.getElementById('maze-canvas-background');
	mapCanvas = document.getElementById('map-canvas');
    tileCanvas = document.getElementById('tile-canvas');
	gameStage = gameCanvas.getContext("2d");
	wallStage = wallCanvas.getContext("2d");
	mapStage = mapCanvas.getContext("2d");
	tileStage = tileCanvas.getContext("2d");
	var hpx = MAX_ROWS*GRID_H+WALL_PAD;
    var wpx = MAX_COLS*GRID_W;
    $(gameCanvas).attr("height", hpx);
    $(gameCanvas).attr("width", wpx);
    $(wallCanvas).attr("height", hpx);
    $(wallCanvas).attr("width", wpx);
    $(mapCanvas).attr("height", hpx);
    $(mapCanvas).attr("width", wpx);
    $(tileCanvas).attr("height", hpx);
    $(tileCanvas).attr("width", wpx);
	counter = 0;
	CanvasTextFunctions.enable(gameStage);
}

function maze_init(){
    if(game_state == GAME_STATES.COMPLETE) {
		tileStage.clearRect(0,0,wallCanvas.width,wallCanvas.height);
		pdm.state.exitr = dragon.r;
		pdm.state.exitc = dragon.c;
        if (pdm.state.currentLevel>=pdm.state.map.levels.length){
            gameComplete();
            return;
        }

    } 

    if (game_state != GAME_STATES.FAILED) {
      if (pdm.state.currentLevel >= pdm.state.map.levels.length) { 
        //Ran into messed up cookie values.
        pdm.state.currentLevel = 0; 
        pdm.state.totalScore = 0;
      }
	  	maze = new Maze(pdm.state.map.levels[pdm.state.currentLevel].currentMazeStr);
		pdm.state.map.levels[pdm.state.currentLevel].visited = true;
    }
	maze.reset();
	if (game_state == GAME_STATES.COMPLETE || game_state == GAME_STATES.UNINIT) {
		maze.renderTiles(tileStage);
	}

	game_state = GAME_STATES.READY;
    printState();
    renderScore();
	var rc = (maze.getEntry()) ? maze.getEntry(): maze.getStart();
	dragon = new Point(HEAD_DOWN_IMG, rc.r, rc.c, function () {});
	setHeadImg(dragon, pdm.state.exitdir);
	maze.addPoint(dragon);
	maze.render(wallStage);
    dir= (pdm.state.exitdir) ? pdm.state.exitdir : "start";
    startMusic();
	startGameLoop();
}

/*************************************/
/* Configuation functions            */
/*************************************/

function changeSpeed(s) {
     //console.log("Changing speed from "+MOVE_DELAY+" to "+s);
     MOVE_DELAY=parseInt(s);
}

/* Music and sound effects functions */

//Set up audio channels for seamless, simultaneous play of multiple sounds
//Thanks to http://www.storiesinflight.com/html5/audio.html 
function initSound() {
    //Code courtesy of http://html5doctor.com/native-audio-in-the-browser/
    var myAudio = $('#theme'); 
    if (myAudio.canPlayType) {
       // Currently canPlayType(type) returns: "", "maybe" or "probably" 
       //canPlayMp3 = !!myAudio.canPlayType && 
       //                 "" != myAudio.canPlayType('audio/mpeg');
       var canPlayOgg = !!myAudio.canPlayType && 
                        "" != myAudio.canPlayType('audio/ogg; codecs="vorbis"');
    }
    //Cache the appropriate audio source
    $.each($("audio"), function (i, v) {
                $.each($(v).children(), function (i2, v2) {
                        //Use ogg by default because it's smaller and open =)
                        if (v2.type == OGG_STR && canPlayOgg) {
                            AUDIO_SRC[v.id] = v2.src;
                        } else if (!canPlayOgg) {
                            //Otherwise set to MP3
                            AUDIO_SRC[v.id] = v2.src;
                        }
                    }
                )});
    
    for (a=0;a<CHANNEL_MAX;a++) { // prepare the channels
        AUDIOCHANNELS[a] = new Array();
        AUDIOCHANNELS[a]['channel'] = new Audio();// create a new audio object
        AUDIOCHANNELS[a]['finished'] = -1;// expected end time for this channel
    }
    //Workaround for Firefox and Safari
    THEME = new Audio();
    THEME.load();
    THEME.src=AUDIO_SRC['theme'];
    THEME.volume=.3;
    THEME.loop="loop";
    //Loop the theme track
    $(THEME).bind('ended', function() {this.currentTime=0});
}

function startMusic() {
    if (PLAY_THEME) {
        THEME.play();
        //$('#theme')[0].load();
        //$('#theme').bind('ended', function() {this.currentTime=0});
        //$('#theme')[0].volume=.3;
        //$('#theme')[0].play();
    }
}

function stopMusic() {
    //$('#theme')[0].pause();
    THEME.pause();
}

function toggleFX(on) {
    //PLAY_FX = on;
	PLAY_FX = $("#fx-on").hasClass("no-display");
	if (PLAY_FX) {
		$("#fx-off").addClass("no-display");
		$("#fx-on").removeClass("no-display");
	} else {
		$("#fx-on").addClass("no-display");
		$("#fx-off").removeClass("no-display");
	}
}

function toggleMusic(on) {
    //PLAY_THEME = on;
	PLAY_THEME = $("#music-on").hasClass("no-display");
    if (PLAY_THEME) {
        startMusic();
		$("#music-off").addClass("no-display");
		$("#music-on").removeClass("no-display");
    } else {
        stopMusic();
		$("#music-on").addClass("no-display");
		$("#music-off").removeClass("no-display");
    }
}

function toggleOptions() {
  if (game_state == GAME_STATES.PAUSED) {
		unpause();
	} else {
		pause();
	}
	$("#lightbox").toggle();
	// $("#map-canvas").click(function (e) {
	// 	//See if you clicked an option and, if so, call the option fn.
	// 	var pos = findPos(this);
	//     var x = e.pageX - pos.x - maze.xOffset;
	//     var y = e.pageY - pos.y - maze.yOffset;
	// 	if ()
	// 	curC = Math.ceil(x/map.gridW);
	// 	curR = Math.ceil(y/map.gridH);
	// 		
	// });
	
	mapStage.clearRect(0,0,mapStage.canvas.width, mapStage.canvas.height);
	//draw the background image
	mapStage.drawImage(pdm.state.map.img,0,0);
	mapStage.globalAlpha = 0.5;
	mapStage.fillStyle = "#000000";
	mapStage.fillRect(0, 0, mapStage.canvas.width, pdm.state.map.gridH);
	mapStage.globalAlpha = 1;
	
	
	// var renderOptions = function (stage, map) {
	// 	//Draw the options background
	// 	stage.globalAlpha = 0.5;
	// 	stage.fillStyle = "#000000";
	// 	stage.fillRect(0,0,mapStage.width, map.gridH);
	// 	stage.drawImage(map.optionsBgImg, 0,0);
	// 		
	// 	//draw the options row
	// 	for (var o in OPTIONS) {
	// 		stage.drawImage(OPTIONS[o].getImg(), map.xoff+o*OPTION_GRID_W, map.yoff);
	// 		OPTIONS[o].setPos(map.xoff+o*OPTION_GRID_W, map.yoff);
	// 	}
	// 	
	// }
	// renderOptions(mapStage);
		
	for(var level = 0, numlvls = pdm.state.map.levels.length; level < numlvls; level +=1) {
		var x = pdm.state.map.gridW*(level%pdm.state.map.cols);
		var y = pdm.state.map.gridH*Math.floor(level/pdm.state.map.cols) + OPTIONS_BAR_HEIGHT;
		if (level==pdm.state.currentLevel) {
			mapStage.drawImage(MAP_DRAGON_IMG, x,y);
		} else if (!pdm.state.map.levels[level].visited) {
			mapStage.globalAlpha = 0.5;
			mapStage.fillStyle = "#000000";
			mapStage.fillRect(x, y, pdm.state.map.gridW, pdm.state.map.gridH);
			mapStage.globalAlpha = 1;
		} else if (pdm.state.map.levels[level].specialImg) {
			mapStage.drawImage(pdm.state.map.specialImg, x, y);
		} else if (pdm.state.map.levels[level].completed) {
			mapStage.drawImage(pdm.state.map.completeImg, x, y);
		}
	}
}

function deleteSavedGame() {
	localStorage.clear();
  //$.removeCookie("state");
//  $.removeCookie("CurrentLevel");
//  $.removeCookie("TotalScore");
}

function quit() {
  deleteSavedGame();
  window.location = "/";
}

//Plays multiple sounds simultaneously a bit more smoothly than would happen normally.
//Courtesy of http://www.storiesinflight.com/html5/audio.html. Thanks!
function playMultiSound(s) {
    if (PLAY_FX) {
        for (a=0;a<AUDIOCHANNELS.length;a++) {
            thistime = new Date();
            if (AUDIOCHANNELS[a]['finished'] < thistime.getTime()) {            // is this channel finished?
                AUDIOCHANNELS[a]['finished'] = thistime.getTime() + document.getElementById(s).duration*1000;
                AUDIOCHANNELS[a]['channel'].src = AUDIO_SRC[s];
                AUDIOCHANNELS[a]['channel'].load();
                AUDIOCHANNELS[a]['channel'].play();
                break;
            }
        }
    }
}


/*************************************/
/* Mazes                             */
/*************************************/

function init_map() {
	pdm.state.map = new Map(MAP_IMG, 3, 7, 128, 128, init_levels(), COMPLETE_IMG);
}

function init_levels() {
	lvls = [];
	//0 
	lvls.push(new Level("20f0e010101010101010101010101010101040000000000000000000000010100000000000000000000000001010000000000010000000000000101000000000001000000000000010100000000000100000000000003010100000002000100020000000003010100000000000100000000000003010100000000000100000000000001010000000000010000000000000101000000000001000000000000010100000000000100000000000001010000000000000000000000000101000000000000000000000000010101010101010101010101010101"));
	//1
	lvls.push(new Level("20f0e0101010101010101010101010101010400000000000000000000000101000000000000000000000000010100000101010000010101000001010000000000000000000000000103000001000000000000000001000302030000010000000200000000010003020300000100000000000000000100030201000000000000000000000000010100000000000000000000000001010000010101000001010100000101000000000000000000000000010100000000000000000000000001010000000000000000000000000101010101010103080308010101010101"));
	//2
	lvls.push(new Level("20f0e0101010101010101010101010101010400000000000000000000000101000000000000000000000000010100010101000101000101010001010001000000000000000001000103010001000000000000000001000103010001000002000000020001000103010001000000000000000001000101000100000000000000000100010100010101000101000101010001010000000000000000000000000101000000000000000000000000010100000000000000000000000001010000000000000000000000000101010101010103090309010101010101"));
	//lvls.push(new Level("20f0e010101010101010101010101010101000000000000000000000000010100000000000000000000000001010001000002000001000000000101000000010001000000010000010301000000000000020000000200010301000100000004000100000000010301000000010001000000010000010100000000020000000000000001010001000000000001000000000101000000000000000000000000010100000000000000000000000001010000000000000000000000000101000000000000000000000000010101010101010101010101010101"));
	//3
	lvls.push(new Level("20f0e01010101010101010101010101010104000100000000000100000001010000010001010100010001000101000001000002000001020100010100000100010101000100010001010000010001000100010000000101000201000102010001010101010100000100010001000000000003040100000100010001000101010101010000010001010100010000000101000101000002000001000100010100010000010101000100010201010101000001000100010001000101000000000100010001000000010101030a0101010101010101010101"));
	//4	
	lvls.push(new Level("20f0e01010101010101010101010101010104000000000000000000000001010000000000000000000000000101000000000000000000000000010102020000010100000100000201010200020001000100020202010101020002000100010001000002010303020200000100010002000001010102000000010001000100000201010200000001000100020000010101020000000101000001000002010100000000000000000000000001010000000000000000000000000101000000000000000000000000010101010101030b030b030b010101010101"));
	//5
	lvls.push(new Level("20f0e0101010101010101010101010101010000000000000000000000000101000101010201010102010100010100010000000000000000000001010001020000000000000000000101000100000000000000010101010100010001020101010201000003060100010000000000000001000001010001010101010100000100000101000000000000010000010002010100000101010001000101000101010000000201000100020100020101000000000100010000010000010100000000010401000000000001010101010101030c01010101010101"));

	//6
	lvls.push(new Level("20f0e010101010101010101010101010101000000000000000000000000010100000000010101010100000001010000000100000000000100000101000000010002000200010000010100000001000000000001000001030500000001000000000001000001010000000001000100010000000101000000000000000000000000010100000000000000000000000001010000000001000100010000000101000000000000000000000000010104000000000000000000000001010000000000000000000000000101010101030d0101010101030d010101"));
	//7
	lvls.push(new Level("20f0e01010101010101010101010101010100000000000000000000000001010000000000000000000000000101000100000001000000010000010100020001000200010002000001010000000000000000000000000101000100000001000000010000010100000001000000010000000001010000000200000002000000000101000100000001000000010000010100000001000000010000000001010000000000000000000000000101000000000000040000000000010100000000000000000000000001010101010101030e030e010101010101"));
	//8
	lvls.push(new Level("20f0e0101010101010301030101010101010101040000000000000000000000010100000000000000000000000001010000000101010101010000000101000000010200000201000000010100000001000000000100000001010000000100000000010000000101000000010100000101000000010100000000000000000000000001010001000000000000000001000101000000000000000000000000010100000000000202000000000001010000000000000000000000000101000000000000000000000000010101010101010101010101010101"));
	//9
	lvls.push(new Level("20f0e01010101010103020302010101010101010000000000040000000000000101000000000000000000000000010100000001010101010100000001010000000000000000010000000101000000010201010101000000010100000001000000000100000001010000000101010201010000000101000000010000000001000000010100000001010201010100000001010000000000000000000000000101000000000000000000000000010100000000000000000000000001010000000000000000000000000101010101010103100310010101010101"));
	//10
	lvls.push(new Level("20f0e0101030301010101010101010101010104000000000000000000000001010001000000010000000100000101000000010002000100000000010100000000000000000000000001010101010101010101010101000101000000000000000000000000010100000000000000000000000001010001010101010101010100000101000000000000000000010000010100000000000000000001020001010101010101010101000101010101020000000000000000000000010100000000000000000000000001010101010101010101010103110101"));
	//11
	lvls.push(new Level("20f0e01010101010304030403040101010101010104000000000000000000000001010000000000000000000000000101000100000000000000010000010100010000000000000001000001010001000000020000000100000101020100000101010000010200030c01000100000002000000010000010100010000000000000001000001010001000000000000000100000101000000000000000000000000010100000000000000000000000001010000000000000000000000000101000000000000000000000000010101010101031203120312010101010101"));
	//12
	lvls.push(new Level("20f0e0101010101010305010101010101010100000000000000000000000001010000000000000000000000000101000000000000000000000000030d01000000000000000000010000010100000000000000000002000001030b04000000000000000001000001010000000000000002000200000101000000000000000100010000010100000000000200020002000001010000000000010001000100000101000000000002000200020000030d010001020102010201020100000101000000000000000000000000010101010101010101010101010101"));
	//13
	lvls.push(new Level("20f0e0101010101030601010101030601010101040000010001020201000100010100000201000100000100010001030c000000010000000000000100010100000001010101010101010001010000000000000000000000000101000100010101000100010000010100000000000000000200000001010001000102010001010102000101000000000000000000000000010100010101000102010001000001030c0000000000000000020000000101000102010001010100010000010100000000000000000000000001010101010101010314010101010101"));
	//14
	lvls.push(new Level("20f0e010101010101030703070101010101010100000000000000000000000001010001000000000000000001000101000001020000000002010000010100000001000000000100000001010000000001020001000000000101000000000001010200000004030f01000000000201010000000000030f0100000000010002010000000001010000020100000000010200000101000001000000000000010000010100010000000000000000010001010000000000000000000000000101000000000000000000000000010101010101010101010101010101"));
	//15
	lvls.push(new Level("20f0e010101010101010101010101010101000000000000000000000000010100000000000000000000000001010000010001000001020100000101000002000000000000000000010100000100010000010001000001030e0000000000000400000000000310030e00000000000000000000000003100100000000000000000000000001010000010001000001000100000101000000000000000000020000010100000102010000010001000001010000000000000000000000000101000000000000000000000000010101010101010101010101010101"));
	//16
	lvls.push(new Level("20f0e0101010101010309030901010101010101000000000000000000000000010100000000000000000000000001010000000000000000000000000101000000000000000000000000010100000000000000000000000001030f0000000001000100000000000311030f00000000010201000000000003110100000000010401000000000001010000000001010100000000000101000000000000000000000000010100000000000000000000000001010000000000000000000000000101000000000000000000000000010101010101010101010101010101"));
	//17
	lvls.push(new Level("20f0e0101010101010101010101030a0101010000000000000000010000000101000000000000000001000000010100000000000100000100000001010204000002010200010200000101010101000001000101010100010310000001000001000001020000010310000001000001000001000000010100000100000100000100000001010000010000010002010000000101000001000001000101000000010100000100000100000200000001010000000000010000000000000101000000000001000000000000010101010101010101010101010101"));
	//18
	lvls.push(new Level("20f0e0101010101030b030b030b010101010101010000020100000401020000000101000100010000000100010100010100010001010101010001010001010001000000000000000000000101000101010101010101000000010100000000000000000100000001010101010101010100010001000101020001000003630100010001000313010000010001010100010001000101000001000000000001000100010100000101010101010100010001010000000000000000000000000101000000000000000000000000010101010101010101010101010101"));
	//19
	lvls.push(new Level("20f0e0101010101010101010101010101010000000000000000000000000101000000000101000000000000010100000000010200000101000001010001010000000000010200000101000102000001010000000101010100000000000102000000010003140100000101000000000000010003140312000001020000000000000100031401000000000000010100000101010100000001010001020000000001010000000102000000000000000101000000000000000000000004010100000000000000000000000003140101010101010101010101010101"));
	//20
	lvls.push(new Level("20f0e0101010101010103060101010101010100000000000204000000000001010000000000000000000000000101000100000001000000010000010100020001000200010002000001010000000000000000000000000103130001000000010000000100000103130000000100000001000000000103130000000200000002000000000101000100000001000000010000010100000001000000010000000001010000000000000000000000000101000000000002000000000000010313000000000000000000000000010101010101010101010101010101"));
	
	return lvls;
}

/*************************************/
/* I/O functions                     */
/*************************************/

function onKeyDown(evt){
	evt.preventDefault();
	switch(game_state) {
		case GAME_STATES.PAUSED:
			switch(evt.keyCode) {
				case ESC:
					toggleOptions();
					break;
				default:
					//Do nothing
			}
			break;
		case GAME_STATES.READY:
			switch(evt.keyCode) {
				case LEFT_ARROW:
				case RIGHT_ARROW:
				case DOWN_ARROW:
				case UP_ARROW:
					gameStage.clearRect(0,0,gameCanvas.width,gameCanvas.height);
					//wallStage.clearRect(0,0,wallCanvas.width,wallCanvas.height);
					//maze.render(wallStage);
					//renderObject(dragon,gameStage);
					renderObject(dragon,wallStage);
					game_state=GAME_STATES.PLAYING;
					break;
				default:
					//Do nothing
			}
		case GAME_STATES.PLAYING:
			switch (evt.keyCode) {
	         	//Store in nextDir to save the last direction
				case LEFT_ARROW:
					nextDir = "left";
					break;
				case RIGHT_ARROW:
					nextDir = "right";
					break;
				case DOWN_ARROW:
					nextDir = "down";
					break;
				case UP_ARROW:
					nextDir = "up";
					break;
				case ESC:
					toggleOptions();
					break;
				default:
					//Do nothing
			}
			break;
		default:
			switch(evt.keyCode) {
				case LEFT_ARROW:
				case RIGHT_ARROW:
				case DOWN_ARROW:
				case UP_ARROW:
					//Only start if you've picked a direction to go in
					gameStage.clearRect(0,0,gameCanvas.width,gameCanvas.height);
					//mapStage.clearRect(0,0,mapCanvas.width,mapCanvas.height);
					wallStage.clearRect(0,0,wallCanvas.width,wallCanvas.height);
					maze_init();
					break;
				default:
					//Do nothing
			}
	}
}

/*************************************/
/* Game loop control functions       */
/*************************************/

// Thanks Paul Irish. shim layer with setTimeout fallback
//Note this seems to break in Firefox and Safari, so I'm not using it.
//window.requestAnimFrame = (function(){
//  return  window.requestAnimationFrame       || 
//          window.webkitRequestAnimationFrame || 
//          window.mozRequestAnimationFrame    || 
//          window.oRequestAnimationFrame      || 
//          window.msRequestAnimationFrame     || 
//          function(/* function */ callback, /* DOMElement */ element){
//            window.setTimeout(callback, 1000 / 60);
//          };
//})();

//window.cancelRequestAnimFrame = ( function() {
//    return window.cancelAnimationFrame          ||
//        window.webkitCancelRequestAnimationFrame    ||
//        window.mozCancelRequestAnimationFrame       ||
//        window.oCancelRequestAnimationFrame     ||
//        window.msCancelRequestAnimationFrame        ||
//        window.clearTimeout;
//} )();

function pause() {
	PREPAUSE_GAME_STATE = game_state;
	game_state = GAME_STATES.PAUSED;
	stopGameLoop();
}

function unpause() {
	game_state = PREPAUSE_GAME_STATE;
	PREPAUSE_GAME_STATE = undefined;
	startGameLoop();
}


function startGameLoop() {
	window.onkeydown=onKeyDown;
	gameLoop();
}

function gameLoop() {
	//request=window.requestAnimFrame(gameLoop,gameCanvas);
    request = window.setTimeout(gameLoop, 1000 / 60);
	update();
}

function stopGameLoop() {
	//window.cancelRequestAnimFrame(request);
    window.clearTimeout(request);
}

function renderScreen() {
    wallStage.clearRect(0,0, wallCanvas.width, wallCanvas.height);
    maze.render(wallStage);
}

function update() {
    //Set the right head image depending on the direction
	setHeadImg(dragon, dir);
	renderScreen();

    if (game_state == GAME_STATES.PLAYING) {
    	counter += 1;
    	if (counter>MOVE_DELAY) {
    		var oldR = dragon.r;
    		var oldC = dragon.c;
            lastDir = dir;
            dir = nextDir;
    	
    		if (dir=="left") {
    			dragon.c = dragon.c - 1;
    			counter =0;
    		}
    		if (dir=="right") {
    			dragon.c = dragon.c + 1;
    			counter =0;
    		}
    		if (dir=="up") {
    			dragon.r = dragon.r - 1;
    			counter =0;
    		}
    		if (dir=="down") {	
    			dragon.r = dragon.r + 1;
    			counter =0;
    		}	

			maze.removePoint(oldR, oldC);
			maze.addDragonBody(dir, lastDir, oldR, oldC);

    		maze.isOn(dragon.r, dragon.c);
		    if (game_state != GAME_STATES.PLAYING) { return; }
            if (dir!="start") {
                LEVEL_SCORE += EARNED_POINTS[MOVE_DELAY];
                renderScore();
    		}
			maze.addPoint(dragon);



			//lastDir = dir;
//            switch(lastDir) {
//                    case "start":
//						maze.addPoint(new Point(getTailImg(dir), 
//							oldR, oldC, mazeCollision));
//						break;
//                    case "left":
//                        switch(dir) {
//                            case "left":
//                                maze.addPoint(new Point(LEFT_TO_RIGHT_IMG, oldR, oldC, mazeCollision));
//                                break;
//                            case "up":
//                                maze.addPoint(new Point(LEFT_TO_UP_IMG, oldR, oldC, mazeCollision));
//                                break;
//                            case "down":
//                                maze.addPoint(new Point(LEFT_TO_DOWN_IMG, oldR, oldC, mazeCollision));
//                                break;
//                        }
//                        break;
//
//                    case "right":
//                        switch(dir) {
//                            case "right":
//                                maze.addPoint(new Point(RIGHT_TO_LEFT_IMG, oldR, oldC, mazeCollision));
//                                break;
//                            case "up":
//                                maze.addPoint(new Point(RIGHT_TO_UP_IMG, oldR, oldC, mazeCollision));
//                                break;
//                            case "down":
//                                maze.addPoint(new Point(RIGHT_TO_DOWN_IMG, oldR, oldC, mazeCollision));
//                                break;
//                        }
//                        break;
//
//                    case "up":
//                        switch(dir) {
//                            case "right":
//                                maze.addPoint(new Point(UP_TO_RIGHT_IMG, oldR, oldC, mazeCollision));
//                                break;
//                            case "left":
//                                maze.addPoint(new Point(UP_TO_LEFT_IMG, oldR, oldC, mazeCollision));
//                                break;
//                            case "up":
//                                maze.addPoint(new Point(DOWN_TO_UP_IMG, oldR, oldC, mazeCollision));
//                                break;
//                        }
//                        break;
//                     
//                    case "down":
//                        switch(dir) {
//                            case "right":
//                                maze.addPoint(new Point(DOWN_TO_RIGHT_IMG, oldR, oldC, mazeCollision));
//                                break;
//                            case "left":
//                                maze.addPoint(new Point(DOWN_TO_LEFT_IMG, oldR, oldC, mazeCollision));
//                                break;
//                            case "down":
//                                maze.addPoint(new Point(UP_TO_DOWN_IMG, oldR, oldC, mazeCollision));
//                                break;
//                        }
//                        break;
//                    default:
//						switch(dir) {
//                         	case "right":
//	                             maze.addPoint(new Point(LEFT_TO_RIGHT_IMG, oldR, oldC, mazeCollision));
//	                             break;
//	                         case "left":
//	                             maze.addPoint(new Point(RIGHT_TO_LEFT_IMG, oldR, oldC, mazeCollision));
//	                             break;
//	                         case "up":
//	                             maze.addPoint(new Point(DOWN_TO_UP_IMG, oldR, oldC, mazeCollision));
//	                             break;
//	                         case "down":
//	                             maze.addPoint(new Point(UP_TO_DOWN_IMG, oldR, oldC, mazeCollision));
//	                             break;                        
//						}
//                }                
//			lastDir = dir;
          }
        }
	}


/*************************************/
/* Rendering functions               */
/*************************************/

// updates the current score by adding p points to it
function updateScore(p) {
       SCORE += p;
}

//Prints the game state string in the center of the maze
function printState () {
	gameStage.drawTextCenter("sans", 16, maze.getCenterX(), maze.getCenterY(), game_state); 
}

//Prints text at x and y on the given stage
function stagePrint(text, x, y, stage) {
	stage.fillStyle = '#000';
	stage.font = '12px sans-serif';
	stage.textBaseline = 'top';
	stage.fillText(text, x, y);
}


//renders the screen
function renderScreen() {
    wallStage.clearRect(0,0, wallCanvas.width, wallCanvas.height);
    maze.render(wallStage);
}


// prints the new score
function renderScore() {
        $('#total_score').text(pdm.state.totalScore);
        $('#level_score').text(LEVEL_SCORE);
        $('#current_level').text(pdm.state.currentLevel+1);
}


/*
* Default rendering engine
*/
function renderObject($obj, stage) {
	if ($obj.img == undefined){ return; }
	var xy=maze.grid2canvas($obj.r, $obj.c);
    var x = xy.x+$obj.xOffset;
    var y = xy.y+$obj.yOffset;
//    if (ISOMETRIC) {
//	    x=getScreenX(x,y)+$obj.xOffset;
//	    y=getScreenY(x,y)+$obj.yOffset;
//    }
	try {
		stage.drawImage($obj.img,x,y, $obj.img.width*SPRITE_SCALE, $obj.img.height*SPRITE_SCALE);
		if ($obj.obj_type && $obj.obj_type == TYPES.GOAL && DEBUG) {
			stagePrint($obj.destination, xy.x+Math.floor(GRID_W/2), xy.y, stage);
		}
	} catch($error) {
		console.log("Error drawing image: "+ $error.message)
	}
}

/* Only used in Isometric mode */
// function getScreenX($x,$y) {
// 	var x=(($x-$y)*COS)+X_ORIGIN;
// 	//var x=(($x-$y)*COS);
// 	return x;
// }
// 
// function getScreenY($x,$y) {
// 	var y=Y_ORIGIN-(($x+$y)*SIN);
// 	//var y=(($x+$y)*SIN);
// 	return y;
// }

//Main functions held in respective pages.
