/* Copyright 2013 Mark Thomas (mr.thomas gmail)
*/

/*************************************/
/* Global variables                  */
/*************************************/

var pdm = {};
pdm.state = {};
var VERSION = "1.0"; //used to sanity check loaded state.
pdm.state.version = VERSION; // will only differ in saved games

var DEBUG = false;

/* Graphics */
//Constants
var FRAMERATE = 25;
var SPRITE_SCALE = 2;
var BASE_W = 32;
var BASE_H= 16;
var GAME_PX_W = 900;
var GAME_PX_H = 500;
var OPTIONS_BAR_HEIGHT = 128;

//Derivative constants
var GRID_W = BASE_W*SPRITE_SCALE;
var GRID_H = BASE_H*SPRITE_SCALE;
var WALL_PAD=10*SPRITE_SCALE;
var MAX_COLS = Math.floor(GAME_PX_W/GRID_W);
var MAX_ROWS = Math.floor(GAME_PX_H/GRID_H);
var MAP_ICON_POS = MAX_COLS-2;
var PAUSE_ICON_POS = MAX_COLS;
var DEFAULT_WALL_YOFFSET = -10*SPRITE_SCALE;	//Need to get rid of this hack eventually
var DEFAULT_STARTPT_YOFFSET = -13*SPRITE_SCALE;
var DEFAULT_GOAL_YOFFSET = -GRID_H;
var optionsX = 100*SPRITE_SCALE;
var optionsW = 257*SPRITE_SCALE;
var optionsH = 100*SPRITE_SCALE;
var OPS_TARGET_W = 120*(SPRITE_SCALE/2);
var OPS_TARGET_H = 105*(SPRITE_SCALE/2);
var opsPad = 5*SPRITE_SCALE;

//Img caching
var PDM_SS_IMG;
var BORDER_IMG; 
var SNAKE_IMG; 
var STAR_IMG; 
var GOAL_IMG; 
var PANDA_IMG;
var PORTAL_IMG;
var HEAD_UP_IMG;
var HEAD_DOWN_IMG;
var HEAD_LEFT_IMG;
var HEAD_RIGHT_IMG;
var TAIL_UP_IMG;
var TAIL_DOWN_IMG;
var TAIL_LEFT_IMG;
var TAIL_RIGHT_IMG;
var DOWN_TO_LEFT_IMG;
var DOWN_TO_RIGHT_IMG;
var DOWN_TO_UP_IMG;
var LEFT_TO_DOWN_IMG;
var LEFT_TO_RIGHT_IMG;
var LEFT_TO_UP_IMG;
var RIGHT_TO_DOWN_IMG;
var RIGHT_TO_LEFT_IMG;
var RIGHT_TO_UP_IMG; 
var TILES_IMG_ARRAY;
var WALL_BLOCK_IMG;
var PILLAR_IMG;
var VERTICAL_WALL_IMG;
var HORIZONTAL_WALL_IMG;
var DELETE_IMG;
var PIX_IMG;
var WALL_9S_TL_IMG;
var WALL_9S_TC_IMG;
var WALL_9S_TR_IMG;
var WALL_9S_ML_IMG;
var WALL_9S_MC_IMG;
var WALL_9S_MCTR_IMG;
var WALL_9S_MCTL_IMG;
var WALL_9S_MCBR_IMG;
var WALL_9S_MCBL_IMG;
var WALL_9S_MR_IMG;
var WALL_9S_BL_IMG;
var WALL_9S_BC_IMG;
var WALL_9S_BR_IMG;
var MAP_IMG;
var COMPLETE_IMG;
var CROWN_IMG;
var MAP_DRAGON_IMG;
var MAP_ICON;
var PAUSE_ICON;
var MAP_HEADER_BG;
var BACK_IMG;
var OPS_HOME_IMG;
var OPS_FX_ON_IMG;
var OPS_FX_OFF_IMG;
var OPS_SOUND_ON_IMG;
var OPS_SOUND_OFF_IMG;
var OPS_SOUND_IMG;
var OPS_FX_IMG;
var OPS_SPEED_FAST_IMG;
var OPS_SPEED_SLOW_IMG;
var OPS_SPEED_IMG;

var MAP_VISIBLE = false;

//Hacky way to get images to JSON.stringify. See removeCyclicalStructures
var IMG_PREFIX = "img";
var IMG_CACHE = {};

var POST_ASSET_LOAD_FN; //hacky way to get images to load in lb

var IMGDIR ="assets"
var AUDIODIR ="assets"
var LOAD_ASSETS = true;
var INIT_GAME = true;

var DEFAULT_LIVES = 10;

/* Maze encoding variables */
var ENC_W = 2; //num of digits per point in a string
var DEFAULT_BASE = 16; //Default digit base for string output (currently hexadecimal)
var WI = 0;
var SIZEI = 1;

/* I/O */
var LEFT_ARROW=37;
var UP_ARROW=38;
var RIGHT_ARROW=39;
var DOWN_ARROW=40;
var ESC=27;
var ENTER =13;
var MOVE_DELAY=5;
var CONTROLS_HIDDEN = false;
var CONTROL_POS = 10*SPRITE_SCALE; 
var JOYSTICK;

var OPPOSITEDIR = {
	"up" : "down",
	"down" : "up",
	"left" : "right",
	"right" :  "left"
}

/* Game */
pdm.state.map = undefined; // holds the current world.
var LEVELS_INITED = false;
//var pdm.state.currentLevel; //Will be set during init
//var pdm.state.totalScore; //Will be set during init
var LEVEL_SCORE= 0;
var EARNED_POINTS = { "5": 40, "10": 20, "15": 40, "bonus" : 1000};

var GAME_STATES = {
  UNINIT : "uninit",
  READY : "ready?",
  FAILED: "Maze failed!",
  PLAYING: "playing",
  COMPLETE: "Maze complete!",
  PAUSED: "Paused",
  GAME_COMPLETE: "Game complete!",
  GAME_OVER: "Game over"
}

/* Game elements */
var loadFlags = [];
var gameCanvas; // canvas for moving elements
var gameStage;  
var wallCanvas;  // canvas for static background
var wallStage;	// stage for rendering walls
var mapCanvas;  // canvas for dragon body
//var mapStage;	// stage for rendering dragon body
var tileCanvas;  // canvas for static background
var tileStage;  // canvas for static background
var game_state = GAME_STATES.UNINIT;
var PREPAUSE_GAME_STATE;
var request;
var dragon;
var maze; //the current maze
var dir;
var lastDir;
var nextDir;
var counter;
var TYPES = {
	BLANK : 0,
	WALL : 1,
	PANDA : 2,
	GOAL: 3,
	START: 4, 
	//MWALL: 5, 
}

var DIFFICULTIES= {
	EASY: 0,
	NORMAL: 1,
	HARD : 2,
}

var POINTS = {};
POINTS[TYPES.WALL] =  WallPoint;
POINTS[TYPES.PANDA] = PandaPoint;
POINTS[TYPES.GOAL] = GoalPoint;
POINTS[TYPES.START] = StartPoint;
//POINTS[TYPES.MWALL] =  MagicWallPoint;

var BLANK = undefined; //Value for ablank space.

/* Audio */
var CHANNEL_MAX = 10;   // number of simultaneous audio channels to allow
var AUDIOCHANNELS = new Array(); // Array of audio elements (initialized below)
var PLAY_FX = true; // whether or not to play sound effects
var PLAY_THEME = false; // whether or not to play sound effects
var AUDIO_SRC= {};  //Caches the playable source strings from the audio elements
var OGG_STR = "audio/ogg";
var THEME;

/*************************************/
/* Game objects                      */
/*************************************/

/*
* Sprites wrap images and allow for things like animations
* and efficient use of sprite sheets.
*/

/*A maze object is a collection of points
 @arg img a an image object to render for this point
 @arg r the row of this object in the maze grid
 @arg c the column of this objection in the maze grid
 @arg isOnFn the function which will be called if the dragon lands on this point
 @arg pointType the type ID for this point
 @arg yoff optional yoffset in pixels
 @arg xoff optiona xoffset in pixels
*/
function Point(img,r, c, isOnFn, pointType, yoff, xoff) {
	this.img=img;
	this.r=r;
	this.c=c;
    this.isOn = isOnFn;
	this.yOffset= (yoff) ? yoff : 0;
	this.xOffset= (xoff) ? xoff : 0;
    this.obj_type=pointType;
}

/*
 * Returns an object with two components
 *   - obj.pt the first point object encoded in the given string or undefined if blank
 *   - obj.n (num_chars_read_from_s)/pad_w
 * Arguments:
 * s a string with the first pad_w digits specifying a point type
 * r the row for this point
 * c the column for this point 
 * base the base in which elements in this string have been encoded
 * pad_w the encoding width in number of digits in base for each point 
 */
function PointFactory (s, r, c, base, pad_w) {
	var base = (base) ? base : DEFAULT_BASE;
	var pad_w = (pad_w) ? pad_w : ENC_W;
	var n = 1;
	var t = parseInt(s.substring(0, pad_w), base);
	var pt = undefined;
	
	switch (t) {
		case TYPES.GOAL:
			// Next encoded digit specifies destination
			var d = parseInt(s.substring(pad_w, 2*pad_w), base);
			n += 1;
			pt = new POINTS[t](r,c,d);
			break;
		case TYPES.BLANK:
			//Blank points should keep the point undefined, so do nothing here.
			break;
		default:
			//Simple version for most points
			pt = new POINTS[t](r,c);
	}
	return {"pt" : pt, "n" : n };
}

/* Encodes the point as a string. See Maze.prototype.toString for more information. */
Point.prototype.toString = function(base, pad_w){
	//Set default vars
	var base = (base) ? base : DEFAULT_BASE;
	var pad_w = (pad_w) ? pad_w : ENC_W;
	switch(this.obj_type) {
		case TYPES.GOAL:
			if (this.destination!=0 && !this.destination) {
				throw "Error: goal point at " + this.r + ", " + this.c + " has no destination!"
				return undefined;
			} else {
				return pad(Number(this.obj_type).toString(base), pad_w) + pad(Number(this.destination).toString(base), pad_w);
			}
			break;
		case undefined:
			//console.log("Warning: point at " + this.r + "," + this.c + " has no type! Assuming it is blank.");
			return pad(Number(TYPES.BLANK).toString(base), pad_w);
			break;
		default:
			return pad(Number(this.obj_type).toString(base), pad_w);
	}
}

/* A Wall in the maze */
function WallPoint(r,c)  {
	return new Point(WALL_BLOCK_IMG, r, c, mazeCollision, TYPES.WALL, DEFAULT_WALL_YOFFSET);
}

//function MagicWallPoint(r,c) {
//	var p = new WallPoint(r,c);
//	p.obj_type = TYPES.MWALL;
//	p.isOn = function() {
//			//do nothing
//		};
//}

/* A goal. 
 * dest: an int ID for another maze where this goal will take you.
 */ 
function GoalPoint(r, c, dest)  {
	var pt = new Point(PORTAL_IMG, r, c, mazeComplete(dest), TYPES.GOAL, DEFAULT_GOAL_YOFFSET);
	pt.destination = dest;
	return pt;
}

//A Panda
function PandaPoint(r,c) {
	return new Point(PANDA_IMG, r, c, collectBonus, TYPES.PANDA, -20, 10);
}

//Dragon starting point
function StartPoint(r,c) {
	return new Point(HEAD_DOWN_IMG, r, c, function () {}, TYPES.START, DEFAULT_STARTPT_YOFFSET);
}

//Special point for background tiles. These are used initially to render
//background images only, so there's no need for an isOn function
function TilePoint(r, c) {
   var img = TILES_IMG_ARRAY[Math.floor(Math.random()*TILES_IMG_ARRAY.length)];
   return new Point(img, r, c, null); 
}

/* A maze */
function Maze (s) {
	if (!s) { throw "Maze must be initialized with a valid string"; }
    this.doneBonuses = 0;
    this.gotBonuses = 0;
	this.s = s;
	this.maxPandas = 0;
	this.load(s);
	this.xOffset = 0;
	this.yOffset = -DEFAULT_WALL_YOFFSET;
}

Maze.prototype.reset = function() {
	this.load(this.s);
	//enter the maze from where you exited the last one.
	if (pdm.state.exitr && pdm.state.exitc && pdm.state.exitdir) {
		maze.setEntry(pdm.state.exitr, pdm.state.exitc, pdm.state.exitdir);
	}
}

// Sets the Maze's size in rows (height) and columns (width)
Maze.prototype.setSize = function (r,c) {
	this.rows = r;
	this.cols = c;
}

//Sets the entry row/column for this maze
Maze.prototype.setEntry = function(r,c, dir) {
	var tr, tc;
	switch (r) {
		case MAX_ROWS:
			this.er = 2;
			tr = 1;
			break;
		case 1:
			this.er = MAX_ROWS-1;
			tr = MAX_ROWS;
			break;
		default:
			this.er = tr = r;
			break;
	}
	switch (c) {
		case MAX_COLS:
			this.ec = 2;
			tc = 1;
			break;
		case 1:
			this.ec = MAX_COLS-1;
			tc = MAX_COLS;
			break;
		default:
			this.ec = tc = c;
	}
	//Make sure the tail image for the exit row is correct.
	this.getPoint(tr,tc).img = getTailImg(dir);
}

// Sets the Dragon's starting/drop point
// Note this will be overridden by the entry point unless being dropped.
Maze.prototype.setStart = function(r,c) {
	this.sr = r;
	this.sc = c;
}

Maze.prototype.unsetStart = function() {
	this.sr = undefined;
	this.sc = undefined;	
}

//Given a row and a column, returns an array with x and y pixel coordinates
Maze.prototype.grid2canvas= function (r, c) {
	return {"x" : ((c-1) * GRID_W + this.xOffset),
            "y" : ((r-1) * GRID_H + this.yOffset)
			};
}

Maze.prototype.getCenterX = function () {
	return Math.round(((this.cols)*GRID_W+this.xOffset)/2);
}

Maze.prototype.getCenterY = function () {
	return Math.round(((this.rows)*GRID_H+this.yOffset)/2);
}

Maze.prototype.getEntry = function () {
	return (this.er && this.ec) ? {"r" : this.er, "c" : this.ec} : undefined;
 	//return [this.er, this.ec];
}

Maze.prototype.getStart = function () {
	return (this.sr && this.sc) ? {"r" : this.sr, "c" : this.sc} : undefined;
 	//return (this.sr && this.sc) ? [this.sr, this.sc] : undefined;
}

Maze.prototype.collectBonus = function(){
	if (mixpanel) { mixpanel.track("Bonus collected: level "+pdm.state.currentLevel);}
    this.gotBonuses +=1;
	LEVEL_SCORE += 1;
    //LEVEL_SCORE += EARNED_POINTS['bonus'];
}

Maze.prototype.complete = function () {
	var curlvl = pdm.state.map.levels[pdm.state.currentLevel];
   if (this.gotBonuses==this.maxPandas) {
		curlvl.currentMazeStr = this.toString();
	    pdm.state.totalScore += LEVEL_SCORE;
		if (curlvl.completeMsg &&
			!curlvl.completed == true) {
			toggleAlert(curlvl.completeMsg);
		}
		curlvl.completed = true;
	} else if (pdm.state.difficulty == DIFFICULTIES.EASY) {
		//Allow saving of partial states if not on hard.
		pdm.state.map.levels[pdm.state.currentLevel].currentMazeStr = this.toString();
		//Count additional pandas in this case.
	    pdm.state.totalScore += LEVEL_SCORE;
	}
	setHeadImg(maze.getPoint(dragon.r, dragon.c), dir);
	pdm.state.exitr = dragon.r;
	pdm.state.exitc = dragon.c;
	pdm.state.exitdir = dir;
}

Maze.prototype.addBorders = function () {
	for (var i =1; i<=this.rows; i++) {
		if (!this.hasPoint(i,1)) {
			this.addPoint(new WallPoint(i,1));
		}
		if (!this.hasPoint(i,this.cols)) {
			this.addPoint(new WallPoint(i,this.cols));
		}
		for (var j=1; j<=this.cols; j++){
			if (!this.hasPoint(1, j)) {
				this.addPoint(new WallPoint(1,j));				
			}
			if (!this.hasPoint(this.rows,j)){
				this.addPoint(new WallPoint(this.rows,j));
			}
		}
	}
	
	this.fixWallImages();
}

/* Deletes all objects on the borders of the maze */
Maze.prototype.removeBorders = function () {
	for (var i =1; i<=this.rows; i++) {
			this.removePoint(i,1);
			this.removePoint(i,this.cols);
		for (var j=1; j<=this.cols; j++){
				this.removePoint(1,j);				
				this.removePoint(this.rows,j);
		}
	}
}

//Fn for extending the length of a hex string to <width> chars
function pad(hexstr, width) {
	var p = width - hexstr.length;
	if (p >0) { return Array(p+1).join("0")+hexstr; }
	else if (p<0) { throw "Too long to encode into a Maze string "+hexstr;}
	else { return hexstr; }
};

/* Returns a string representation of this maze
*  Maze string representation:
*  1 hex digit for number of hex digits per square (N)
*  N hex digits for num rows (R)
*  N hex digits for num cols (C)
*  N hex digits for each of the RxC squares in the maze
*/
Maze.prototype.toString = function () {
	var s = "" + Number(ENC_W).toString(DEFAULT_BASE) + 
					pad(Number(this.rows).toString(DEFAULT_BASE), ENC_W) +
					pad(Number(this.cols).toString(DEFAULT_BASE),ENC_W);
	try {
		for (var i = 0; i< this.rows; i++) {
			for ( var j = 0; j<this.cols; j++) {

				if (i+1 == this.sr && j+1 == this.sc) {
					s+=new StartPoint(i+1, j+1).toString();
				} else {
						s+= (this.points[i][j]) ? this.points[i][j].toString(DEFAULT_BASE, ENC_W) : pad( Number(TYPES.BLANK).toString(DEFAULT_BASE), ENC_W);
				}
			}
		}
	} catch (err){
		//console.log("Error at row " + (i+1) + " and column " + (j+1) + "\n"+ err.message);
		return null;
	}
	return s;
}

/* Constructs a maze given a string rep of a maze (see toString above) */
Maze.prototype.load = function(s) {
	try {
		var base = 16; //TODO: need to read this from the string.
		var w      = parseInt(s.charAt(WI), base);
		var rows   = parseInt(s.substring(SIZEI,SIZEI+w), base);
		var cols   = parseInt(s.substring(SIZEI+w, SIZEI+2*w), base); 
		var head_len  = SIZEI+2*w;
		//FIXME: not as easy to verify length of string when points contain extra info (e.g. goal points)
		// if (s.length != head_len + rows*cols*w) {
		// 	throw "Invalid maze string length. Expected: "+(head_len+rows*cols*w) + " Actual: " + s.length;
		// }
		this.setSize(rows, cols);
		this.initPoints();
		this.maxPandas = 0;
		var r = 1;
		var c = 1;
		for (var i = head_len; i < s.length; i+=w) {
			var pt_n    = PointFactory(s.substring(i, s.length), r, c, base, w);
			i += (pt_n.n - 1) * w;	//If we read more than one encoded char, advance the incr accordingly
			if (pt_n.pt) { 
				this.addPoint(pt_n.pt); 
			}		
			//Keep track of which row/column we're on. Note that maze is loaded in columns-first order.
			c += 1;
			if (c > this.cols) {
				c = 1;
				r += 1;
			}
		}
		if (!(this.getStart())) {
			throw "Maze has no starting point defined!";
		}
	} catch (err) {
		throw "Error loading maze: " + err;
	}
	this.fixWallImages();
}

/* initializes the points array for this Maze */
Maze.prototype.initPoints = function() {
	if (!(this.rows && this.cols)) {
		throw "Rows and columns are undefined. Cannot initialize points.";
	}
	this.points = [];
	this.gotBonuses = 0;
	for (var i=0; i<this.rows; i++){
		this.points[i]=[];
		this.points[i][this.cols-1]=BLANK;
 	}
}

Maze.prototype.fixWallImages = function() {
    for (var i = 0; i<this.rows; i++) {
        for (var j= 0; j<this.cols;j++) {
           //We only care about walls, so skip everything else
//            try {
//           		if (!this.points[i][j] || !this.isType(i,j,TYPES.WALL) ||
//									!this.isType(i,j,TYPES.GOAL)) {
//           		     continue;
//           		 }
//            } catch(err) {
//                console.log("Error fixing wall images! i="+i+" j="+j);
//            }


			if (this.isType(i,j,TYPES.GOAL) && 
						(i == 0 || i == this.rows-1 || j == 0 || j == this.cols-1)) {
						this.points[i][j].img = (DEBUG) ? PIX_IMG : undefined;
	          			this.points[i][j].yOffset=0;
			} else if (this.isType(i,j,TYPES.WALL)) {
					//TODO: fixme! Reset wall offset
					this.points[i][j].yOffset=DEFAULT_WALL_YOFFSET;
					//Build 9-slice
					if (this.isType(i-1,j-1,TYPES.WALL) &&
							this.isType(i-1,j,TYPES.WALL) &&
							this.isType(i-1,j+1,TYPES.WALL) &&
							this.isType(i,j-1,TYPES.WALL) &&
							this.isType(i,j,TYPES.WALL) &&
							this.isType(i,j+1,TYPES.WALL) &&
							this.isType(i+1,j-1,TYPES.WALL) &&
							this.isType(i+1,j,TYPES.WALL) &&
							this.isType(i+1,j+1,TYPES.WALL)) {
								//Middle-center wall
								this.points[i][j].img=WALL_9S_MC_IMG;
				           //   this.points[i][j].yOffset=0;
							} else if (
								this.isType(i-1,j-1,TYPES.WALL) &&
								this.isType(i-1,j,TYPES.WALL) &&
								this.isType(i-1,j+1,TYPES.WALL) &&
								this.isType(i,j-1,TYPES.WALL) &&
								this.isType(i,j,TYPES.WALL) &&
								this.isType(i,j+1,TYPES.WALL) &&
								!(this.isType(i+1,j-1,TYPES.WALL) &&
									this.isType(i+1,j,TYPES.WALL)) &&
								!(this.isType(i+1,j+1,TYPES.WALL) && 
									this.isType(i+1,j,TYPES.WALL))) {
									//Bottom-center wall
									this.points[i][j].img=WALL_9S_BC_IMG;
	            	  				//this.points[i][j].yOffset=0;
							} else if (
								!(this.isType(i-1,j-1,TYPES.WALL) &&
									this.isType(i-1,j,TYPES.WALL)) &&
								!(this.isType(i-1,j+1,TYPES.WALL) &&
									this.isType(i-1,j,TYPES.WALL)) &&
								this.isType(i,j-1,TYPES.WALL) &&
								this.isType(i,j,TYPES.WALL) &&
								this.isType(i,j+1,TYPES.WALL) &&
								this.isType(i+1,j-1,TYPES.WALL) &&
								this.isType(i+1,j,TYPES.WALL) &&
								this.isType(i+1,j+1,TYPES.WALL)) {
									//top-center wall
									this.points[i][j].img=WALL_9S_TC_IMG;
	            	  				//this.points[i][j].yOffset=0;
							} else if (
								!(this.isType(i-1,j-1,TYPES.WALL) &&
									this.isType(i,j-1,TYPES.WALL)) &&
								this.isType(i-1,j,TYPES.WALL) &&
								this.isType(i-1,j+1,TYPES.WALL) &&
								this.isType(i,j,TYPES.WALL) &&
								this.isType(i,j+1,TYPES.WALL) &&
								!(this.isType(i+1,j-1,TYPES.WALL) &&
									this.isType(i,j-1,TYPES.WALL)) &&
								this.isType(i+1,j,TYPES.WALL) &&
								this.isType(i+1,j+1,TYPES.WALL)) {
									//middle-left wall
									this.points[i][j].img=WALL_9S_ML_IMG;
	            	  				//this.points[i][j].yOffset=0;
							} else if (
								this.isType(i-1,j,TYPES.WALL) &&
								this.isType(i-1,j+1,TYPES.WALL) &&
								!(this.isType(i-1,j-1,TYPES.WALL) &&
								  this.isType(i,j-1,TYPES.WALL)) &&
								this.isType(i,j,TYPES.WALL) &&
								this.isType(i,j+1,TYPES.WALL) &&
								!(this.isType(i+1,j,TYPES.WALL) &&
								  this.isType(i+1,j+1,TYPES.WALL))) {
									//bottom-left wall
									this.points[i][j].img=WALL_9S_BL_IMG;
	            	  				//this.points[i][j].yOffset=0;
							} else if (
								!(this.isType(i-1,j,TYPES.WALL) &&
									this.isType(i-1,j+1,TYPES.WALL)) &&
								!(this.isType(i,j-1,TYPES.WALL) &&
									this.isType(i+1,j-1,TYPES.WALL)) &&
								this.isType(i,j,TYPES.WALL) &&
								this.isType(i,j+1,TYPES.WALL) &&
								this.isType(i+1,j,TYPES.WALL) &&
								this.isType(i+1,j+1,TYPES.WALL)) {
									//top-left wall
									this.points[i][j].img=WALL_9S_TL_IMG;
	            	  				//this.points[i][j].yOffset=0;
							} else if (
								this.isType(i-1,j-1,TYPES.WALL) &&
								this.isType(i-1,j,TYPES.WALL) &&
								!(this.isType(i-1,j+1,TYPES.WALL) &&
									this.isType(i,j+1,TYPES.WALL)) &&
								this.isType(i,j-1,TYPES.WALL) &&
								this.isType(i,j,TYPES.WALL) &&
								this.isType(i+1,j-1,TYPES.WALL) &&
								this.isType(i+1,j,TYPES.WALL) &&
								!(this.isType(i,j+1,TYPES.WALL) &&
								this.isType(i+1,j+1,TYPES.WALL))) {
									//middle-right wall
									this.points[i][j].img=WALL_9S_MR_IMG;
	            	  				//this.points[i][j].yOffset=0;
							} else if (
								this.isType(i-1,j-1,TYPES.WALL) &&
								this.isType(i-1,j,TYPES.WALL) &&
								!(this.isType(i-1,j+1,TYPES.WALL) &&
									this.isType(i,j+1,TYPES.WALL)) &&
								this.isType(i,j-1,TYPES.WALL) &&
								this.isType(i,j,TYPES.WALL) &&
								!(this.isType(i+1,j-1,TYPES.WALL) &&
									this.isType(i+1,j,TYPES.WALL))) {
									//bottom-right wall
									this.points[i][j].img=WALL_9S_BR_IMG;
	            	  				//this.points[i][j].yOffset=0;
							} else if (
								!(this.isType(i-1,j-1,TYPES.WALL) &&
									this.isType(i-1,j,TYPES.WALL)) &&
								this.isType(i,j-1,TYPES.WALL) &&
								this.isType(i,j,TYPES.WALL) &&
								!(this.isType(i,j+1,TYPES.WALL) &&
									this.isType(i+1,j+1,TYPES.WALL)) &&
								this.isType(i+1,j-1,TYPES.WALL) &&
								this.isType(i+1,j,TYPES.WALL)) {
									//top-right wall
									this.points[i][j].img=WALL_9S_TR_IMG;
	            	  				//this.points[i][j].yOffset=0;
							} else if (this.isType(i-1,j-1,TYPES.WALL) &&
                this.isType(i-1,j,TYPES.WALL) &&
                this.isType(i-1,j+1,TYPES.WALL) &&
                this.isType(i,j-1,TYPES.WALL) &&
                this.isType(i,j,TYPES.WALL) &&
                this.isType(i,j+1,TYPES.WALL) &&
                this.isType(i+1,j-1,TYPES.WALL) &&
                this.isType(i+1,j,TYPES.WALL) &&
                !this.isType(i+1,j+1,TYPES.WALL)) {
                    //9-slice with bottom-right missing
                    this.points[i][j].img = WALL_9S_MCBR_IMG;
                    //this.points[i][j].yOffset=0;
              } else if (this.isType(i-1,j-1,TYPES.WALL) &&
                this.isType(i-1,j,TYPES.WALL) &&
                this.isType(i-1,j+1,TYPES.WALL) &&
                this.isType(i,j-1,TYPES.WALL) &&
                this.isType(i,j,TYPES.WALL) &&
                this.isType(i,j+1,TYPES.WALL) &&
                !this.isType(i+1,j-1,TYPES.WALL) &&
                this.isType(i+1,j,TYPES.WALL) &&
                this.isType(i+1,j+1,TYPES.WALL)) {
                    //9-slice with bottom-left missing
                    this.points[i][j].img = WALL_9S_MCBL_IMG;
                    //this.points[i][j].yOffset=0;
              } else if (this.isType(i-1,j-1,TYPES.WALL) &&
                this.isType(i-1,j,TYPES.WALL) &&
                !this.isType(i-1,j+1,TYPES.WALL) &&
                this.isType(i,j-1,TYPES.WALL) &&
                this.isType(i,j,TYPES.WALL) &&
                this.isType(i,j+1,TYPES.WALL) &&
                this.isType(i+1,j-1,TYPES.WALL) &&
                this.isType(i+1,j,TYPES.WALL) &&
                this.isType(i+1,j+1,TYPES.WALL)) {
                    //9-slice with top-right missing
                    this.points[i][j].img = WALL_9S_MCTR_IMG;
                    //this.points[i][j].yOffset=0;
              } else if (
                !this.isType(i-1,j-1,TYPES.WALL) &&
                this.isType(i-1,j,TYPES.WALL) &&
                this.isType(i-1,j+1,TYPES.WALL) &&
                this.isType(i,j-1,TYPES.WALL) &&
                this.isType(i,j,TYPES.WALL) &&
                this.isType(i,j+1,TYPES.WALL) &&
                this.isType(i+1,j-1,TYPES.WALL) &&
                this.isType(i+1,j,TYPES.WALL) &&
                this.isType(i+1,j+1,TYPES.WALL)) {
                    //9-slice with top-left missing
                    this.points[i][j].img = WALL_9S_MCTL_IMG;
                    //this.points[i][j].yOffset=0;
              } else if (this.isType(i,j-1,TYPES.WALL) &&
								this.isType(i, j+1, TYPES.WALL) &&
								(this.isType(i+1, j, TYPES.WALL) ||
									this.isType(i-1, j, TYPES.WALL))) {
											//Fix T-shaped and inverse T-shaped walls
											this.points[i][j].img=WALL_BLOCK_IMG;
	                						//this.points[i][j].yOffset=0;
							 } else if (this.isType(i-1,j,TYPES.WALL) && 
											this.isType(i+1,j,TYPES.WALL) &&
											(this.isType(i,j-1,TYPES.WALL) ||
													this.isType(i,j+1,TYPES.WALL))) {
													//Fix -| and |- walls
													this.points[i][j].img = WALL_BLOCK_IMG;
                      								//this.points[i][j].yOffset=0;
							} else if (this.isType(i-1,j,TYPES.WALL) &&
							  this.isType(i+1,j,TYPES.WALL) &&
							  !this.isType(i, j-1, TYPES.WALL) &&
								!this.isType(i,j+1, TYPES.WALL)) {
                    				//Fix vertical wall image
				                    this.points[i][j].img=VERTICAL_WALL_IMG;
                      				//this.points[i][j].xOffset=16;
           	  } else if (this.isType(i,j-1,TYPES.WALL) &&
								this.isType(i, j+1, TYPES.WALL) &&
								!this.isType(i-1,j, TYPES.WALL) &&
								!this.isType(i+1,j, TYPES.WALL)) {
                    //Fix horizontal wall image
                    this.points[i][j].img=HORIZONTAL_WALL_IMG;
                    this.points[i][j].yOffset=-10;
              } else {
						//default to the pillar wall
						this.points[i][j].img = WALL_BLOCK_IMG; 
						//this.points[i][j].yOffset=-20;
        		}
		}
    }
  } 
}

/**
* Given a row, column and and object type, returns true if the point at
* at this.points[i][j] has obj_type==type
* Note that maze rows and columns are not 0-indexed (first row/col is 1,1).
*/
Maze.prototype.isType = function (i,j,type) {
	return (i>=0 && i<this.rows && j>=0 && j<this.cols &&
					this.points[i][j]!=undefined &&
					this.points[i][j].obj_type==type);
}

// Adds a point object to this Maze
Maze.prototype.addPoint = function(pt) {
	// Ensure you can only add points within the maze
	if (pt.r >0 && pt.r <= this.rows && pt.c > 0 && pt.c <= this.cols) {
		switch(pt.obj_type) {
			case TYPES.START:
				//We don't add start points to the maze
				this.setStart(pt.r, pt.c);
				break;
			case TYPES.PANDA:
				this.maxPandas += 1;
			default:
				this.points[pt.r-1][pt.c-1] = pt;			
		}
    	return pt;
	}
}

/* Removes a point object from this Maze */
Maze.prototype.removePoint = function(r, c) {
	if (r >0 && r <= this.rows && c > 0 && c <= this.cols) {
		var pt = this.points[r-1][c-1];
		switch(pt.obj_type) {
			case TYPES.START:
				//If you're removing a start, unset the start position
				this.unsetStart();
				break;
			default:
				this.points[r-1][c-1]=BLANK;			
		}
		return pt;
	}
}

/*
* Returns a point at r, c in the maze or undefined if none exists
*/
Maze.prototype.hasPoint = function(r, c) {
	return this.points[r-1][c-1];
}

Maze.prototype.getPoint = function(r,c) {
	if (r<=this.rows && r > 0 && c <= this.cols && c > 0) {
		return this.points[r-1][c-1];
	}
}

Maze.prototype.isOn = function (r, c) {
        var pt = this.getPoint(r,c);
        if (pt && pt.isOn) {
                pt.isOn();
        }
}

Maze.prototype.renderTiles = function (stage) {
	for (var i =0; i<this.rows; i++) {
		for (var j =0; j<this.cols; j++) {
            renderMazeObject(new TilePoint(i+1, j+1), stage);
		}
	}
}

Maze.prototype.render = function (stage) {
	for (var i =0; i<this.rows; i++) {
		for (var j =0; j<this.cols; j++) {
            //render the background tiles the first time we render the maze.
            // if (game_state != GAME_STATES.FAILED) {
            //      renderMazeObject(new TilePoint(i+1, j+1),tileStage);
            //  }
 			if (this.points[i][j]) {
				renderMazeObject(this.points[i][j], stage);
			}
		}
	}
}


Maze.prototype.addDragonBody = function(dir, lastDir, oldR, oldC) {
            switch(lastDir) {
                    case "start":
                        maze.addPoint(new Point(getTailImg(dir),
                            oldR, oldC, mazeCollision));
                        break;
                    case "left":
                        switch(dir) {
                            case "left":
                                maze.addPoint(new Point(LEFT_TO_RIGHT_IMG, oldR, oldC, mazeCollision));
                                break;
                            case "up":
                                maze.addPoint(new Point(LEFT_TO_UP_IMG, oldR, oldC, mazeCollision));
                                break;
                            case "down":
                                maze.addPoint(new Point(LEFT_TO_DOWN_IMG, oldR, oldC, mazeCollision));
                                break;
                        }
                        break;

                    case "right":
                        switch(dir) {
                            case "right":
                                maze.addPoint(new Point(RIGHT_TO_LEFT_IMG, oldR, oldC, mazeCollision));
                                break;
                            case "up":
                                maze.addPoint(new Point(RIGHT_TO_UP_IMG, oldR, oldC, mazeCollision));
                                break;
                            case "down":
                                maze.addPoint(new Point(RIGHT_TO_DOWN_IMG, oldR, oldC, mazeCollision));
                                break;
                        }
                        break;

                    case "up":
                        switch(dir) {
                            case "right":
                                maze.addPoint(new Point(UP_TO_RIGHT_IMG, oldR, oldC, mazeCollision));
                                break;
                            case "left":
                                maze.addPoint(new Point(UP_TO_LEFT_IMG, oldR, oldC, mazeCollision));
                                break;
                            case "up":
                                maze.addPoint(new Point(DOWN_TO_UP_IMG, oldR, oldC, mazeCollision));
                                break;
                        }
                        break;

                    case "down":
                        switch(dir) {
                            case "right":
                                maze.addPoint(new Point(DOWN_TO_RIGHT_IMG, oldR, oldC, mazeCollision));
                                break;
                            case "left":
                                maze.addPoint(new Point(DOWN_TO_LEFT_IMG, oldR, oldC, mazeCollision));
                                break;
                            case "down":
                                maze.addPoint(new Point(UP_TO_DOWN_IMG, oldR, oldC, mazeCollision));
                                break;
                        }
                        break;
                    default:
                        switch(dir) {
                            case "right":
                                 maze.addPoint(new Point(LEFT_TO_RIGHT_IMG, oldR, oldC, mazeCollision));
                                 break;
                             case "left":
                                 maze.addPoint(new Point(RIGHT_TO_LEFT_IMG, oldR, oldC, mazeCollision));
                                 break;
                             case "up":
                                 maze.addPoint(new Point(DOWN_TO_UP_IMG, oldR, oldC, mazeCollision));
                                 break;
                             case "down":
                                 maze.addPoint(new Point(UP_TO_DOWN_IMG, oldR, oldC, mazeCollision));
                                 break;
                        }
                }
}

/*************************************/
/* Maze events                       */
/*************************************/

function cleanUp() {
    stopGameLoop();
}

function mazeCollision() {
	if (mixpanel) { mixpanel.track("Collision: Level "+pdm.state.currentLevel);}
    game_state = GAME_STATES.FAILED;
    stopMusic();
    playMultiSound('defeat');
    LEVEL_SCORE = 0;
	pdm.state.lives -=1;
	pdm.state.deaths+=1;
	saveGameState();
    cleanUp();
	if (pdm.state.lives <= 0) {
		game_over();
	}
}

//TODO: remove in favor of server-side score calculation
function calcCoverage() {
	var cL = vL = tL = 0;
	for(var level = 0, numlvls = pdm.state.map.levels.length; level < numlvls; level +=1) {
		tL +=1;
		if (pdm.state.map.levels[level].visited) { vL +=1; }
		if (pdm.state.map.levels[level].completed) { cL +=1; }
	}

	var c =((cL/tL) * 100).toFixed(2); 
	//console.log("coverage: " + c);
	return c;
}

function getCurrentRank(callBack) {
	$.getJSON("myRank", {c: calcCoverage()}, callBack).fail(
   function () {
      alert('Problem communicating with high score server--scores not recorded.');
      deleteSavedGame();
      window.location="/";
    });

  //Stub it out
//  callBack({today:"9th", overall:"Embarrassment", coverage:0.8});
}

function game_over() {
	if (mixpanel) { mixpanel.track("Game over: level "+pdm.state.currentLevel);}
	game_state = GAME_STATES.GAME_OVER;
	cleanUp(); //stop the game loop
	getCurrentRank(renderGo);
	//renderWrapUp(wallStage, 200,125);
}

function blink() {
	var txt = ($('#go-name').attr("placeholder") == "___" ) ? " __" : "___";
	$('#go-name').attr("placeholder", txt);
	request = window.setTimeout(blink, 800);
};

function renderGo(rankData) {
	deleteSavedGame();
	var today = overall = coverage = "Unknown"
	var ranked = null;
	if (rankData) {
      	coverage = rankData['coverage'];
		today = rankData['today'];
		overall = rankData['overall'];
		ranked = today != "Embarrassment";
	}

	if (game_state == GAME_STATES.COMPLETE) {
		$('#go-title').val("Game complete!");
	}
	$('#coverage').text(coverage+"%");
	$('#rank-today').text(today);
	$('#rank-overall').text(overall);
	

	$('#go').removeClass('no-display');
	$('#go').animate({top: "+=475"}, 1000, "easeOutBounce");
	$('#go-ok').click(function(){
    	recordScore(coverage);
  	});
	if (ranked) {
		$('#go-name').focus();
	} else {
		$('#input').addClass('no-display');
		$('#fail').removeClass('no-display');
	}
  blink();
}

//function renderWrapUp(stage, xOff, yOff) {
//	var cL = vL = tL = 0;
//	for(var level = 0, numlvls = pdm.state.map.levels.length; level < numlvls; level +=1) {
//		tL +=1;
//		if (pdm.state.map.levels[level].visited) { vL +=1; }
//		if (pdm.state.map.levels[level].completed) { cL +=1; }
//	}
//
//	$('#go').removeClass('no-display');
//	$('#go').animate({top: "+=465"}, 1000, "easeOutBounce");
//	$('#go-ok').click(function(){recordScore($('#go-name').text(), ((cL/tL)*100).toFixed(2))});
//
//	/*
//  	mapStage.clearRect(0,0,mapStage.canvas.width, mapStage.canvas.height);
//  	wallStage.clearRect(0,0,wallStage.canvas.width, wallStage.canvas.height);
//  	tileStage.clearRect(0,0,tileStage.canvas.width, tileStage.canvas.height);
//	*/
//
//	var cL = vL = tL = 0;
//	for(var level = 0, numlvls = pdm.state.map.levels.length; level < numlvls; level +=1) {
//		tL +=1;
//		if (pdm.state.map.levels[level].visited) { vL +=1; }
//		if (pdm.state.map.levels[level].completed) { cL +=1; }
//	}
//	var lh = 13*SPRITE_SCALE;  //line height
//	var tab = 25*SPRITE_SCALE; //tab width
//	var p = 10*SPRITE_SCALE; // padding width
//
//	//Lines
//	var hl = yOff +lh;
//	var l1 = hl+2*lh;
//	var l2 = l1 +lh;
//	var l3 = l2+lh;
//	var l4 = l3+lh;
//	var ft = l4+2*lh;
//
//	//columns
//	var col1 = xOff + p;
//	var col2 = xOff + p + 6*tab;
//
//	roundRect(stage, xOff, yOff,
//        optionsW, optionsH+50, 10*SPRITE_SCALE,
//        "rgba(0,0,0, 0.8)", false);
//
//	stagePrint("Game over!", col1+3*tab, hl, stage, "#ffffff", "24px StarPerv");
//	stagePrint("Pandas: ", col1, l1, stage, "#ffffff");
//	stagePrint(pdm.state.totalScore, col2, l1, stage, "#CC3300");
//	stagePrint("Deaths: ", col1, l2, stage, "#ffffff");
//	stagePrint(pdm.state.deaths, col2, l2, stage, "#CC3300");
//	stagePrint("Completed levels: ", col1, l3, stage, "#ffffff");
//	stagePrint(cL +"/"+tL, col2, l3, stage, "#CC3300");
//	stagePrint("Your rank: ", col1,l4,stage, "#ffffff");
//	stagePrint(getRank(pdm.state.totalScore, pdm.state.totalDeaths, cL, vL), col2, l4, stage, "#CC3300");
//	stagePrint("Press enter to retrun to main screen", col1+tab ,ft,stage,"#ffffff" , "12px StarPerv");
//	
//}

function getRank(score, deaths, completed, visited) {
	return "Demure lizard";
}

function mazeComplete(dest) {
	return function () {
 	    game_state = GAME_STATES.COMPLETE;
	    //stopMusic();
	    //playMultiSound('victory');
	    maze.complete();
	    LEVEL_SCORE = 0;
	    pdm.state.currentLevel = dest;
	    saveGameState();
		renderScreen();
	    cleanUp();
        if (dest>=pdm.state.map.levels.length){
            gameComplete();
            return;
        }
	}
}

function collectBonus() {
    maze.collectBonus();
    playMultiSound('pick_up');
}


function gameComplete() {
    game_state = GAME_STATES.GAME_COMPLETE;
	fadeIn(function (alpha) {
  				mapStage.clearRect(0,0,mapStage.canvas.width, mapStage.canvas.height);
				mapStage.fillStyle = "rgba(255, 255, 255,"+alpha+")";
				mapStage.fillRect(0,0,MAX_COLS*GRID_W,(MAX_ROWS+1)*GRID_H);
			},
			closingSequence);
    pdm.state.currentLevel=0;
	deleteSavedGame();
    // for (var i=0; i<pdm.state.map.levels.length;i++) {
    //     pdm.state.map.levels[i].initPoints();
    // }
    //cleanUp();
}

function closingSequence() {
	game_over();
	//renderWrapUp(mapStage, 200,125);
}


// Sets the Dragon's head image based on direction
function setHeadImg(dragon, dir) {
 switch(dir) {
        case "left":
            dragon.img=HEAD_LEFT_IMG;
            dragon.yOffset = -15*SPRITE_SCALE;
            break;
        case "right":
            dragon.img=HEAD_RIGHT_IMG;
            dragon.yOffset = -15*SPRITE_SCALE;
            break;
        case "up":
            dragon.img=HEAD_UP_IMG;
            dragon.yOffset = -5*SPRITE_SCALE;
            break;
        case "down":
            dragon.img=HEAD_DOWN_IMG;
            dragon.yOffset = -15*SPRITE_SCALE;
            break;
		case "start":
			//leave it be
			break;
        default:
            dragon.img=HEAD_DOWN_IMG;
            dragon.yOffset = -15*SPRITE_SCALE;
            break;
    }
}


/*************************************/
/* Map 						         */
/*************************************/

//Creates levels given serialized JSON object. Used in revivePdm to recreate psuedoObjects
function MapFactory(o) {
	return new Map(o.img, o.rows, o.cols, o.gridH, o.gridW, o.levels, o.completeImg);
}


/* Defines a world map.
* All maps at present must be uniform size (900x500px). 
* They must also reserve the top 128 px for the items toolbar.
*/
function Map (img, rows, cols, gridH, gridW, levels, completeImg) {
	this.img = img;
	this.rows = rows;
	this.cols = cols;
	this.levels = levels;
	this.completeImg = completeImg;
	this.gridH = gridH;
	this.gridW = gridW;
	this.factory="MapFactory";
}

/*************************************/
/* Level   					         */
/*************************************/

//Creates levels given serialized JSON object. Used in revivePdm to recreate psuedoObjects
function LevelFactory(o) {
	//return new Level(o.originalMazeStr, o.specialMapImg, o.currentMazeStr, o.completed, o.visited);	
	return new Level(o.originalMazeStr, o.visitMsg, o.completeMsg, o.specialMapImg, o.currentMazeStr, o.completed, o.visited);	
}


/* 
* A Level. Levels are part of a particular map. They hold some state
* factory is the string name of a function which can create this object from JSON data.
*
*/
function Level (originalMazeStr, visitMsg, completeMsg, specialMapImg, currentMazeStr, completed, visited) {
	this.specialImg = (specialMapImg) ? specialMapImg : undefined;
	this.originalMazeStr = originalMazeStr;
	this.currentMazeStr = (currentMazeStr) ? currentMazeStr : originalMazeStr;
	this.completed = completed;
	this.visited = visited;
	this.factory ="LevelFactory";
	this.visitMsg = visitMsg;
	this.completeMsg = completeMsg;;
}


/*************************************/
/* Utility functions                 */
/*************************************/
function recordScore(s) {
	var n = "???";
	if (!$('#input').hasClass('no-display')){
     	n = $('#go-name').val();
	 	if (n.length != 3) {
	 	   alert("Invalid initials! Initials must be 3 characters long and may not be all underscores.");
	 	   return;
	 	} 
	 }
	 $.post("scores", { "score" : { name: n, score: s}}, 
		function (d) {
			//console.log("Score successfully logged");
			window.location="/?ci=1";
		})
      .fail(function () {
			//console.log("Problem communicating with high score server--score not recorded. Sorry!");
			window.location="/?ci=1";
		});
}


//Detects whether or not this is a touch screen
// from http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript
function is_touch_device() {
    return !!('ontouchstart' in window) // works on most browsers 
        || !!('onmsgesturechange' in window); // works on ie10
};

function replaceCyclicStructures(key, val) {
	//Modified version from 
	//http://hagsdev.blogspot.com/2012/06/cyclic-objects-and-jsonstringify.html
	if(typeof val=="object"){
	    var ot=Object.prototype.toString.call(val);
	    if(ot.search("object Object")>-1){
	      return val;
	    }else if(ot.search("HTMLImageElement")>-1){
	      return val.pdmId;
	    }
		//else if(ot.search("HTMLAudioElement")>-1){
	    //  return getAudioPath(val.src);
	    //}else{
	    //  //if(key!==""){
	    //  //  console.log(ot);
	    //  //  console.log(typeof(val)+" : "+key+" : "+val);
	    //  //}
	    //}
	  }
	  return val;
}


//Loads pdm state from local storage
function revivePdm(key, val) {
	var factory;
	if (typeof val === "string" && val.substr(0,3) === "img") {
			return IMG_CACHE[val];
	} else if (val && typeof val === 'object') {
		//used to recreate objects from strings
		//e.g. MapFactory and LevelFactory
        factory = val.factory;
        if (typeof factory === 'string' && 
			typeof window[factory] === 'function') {
            	return (window[factory])(val);
        }
    }
	return val;
}


function findPos(obj) {
    var curleft = 0, curtop = 0;
    if (obj.offsetParent) {
        do {
            curleft += obj.offsetLeft;
            curtop += obj.offsetTop;
        } while (obj = obj.offsetParent);
        return { x: curleft, y: curtop };
    }
    return undefined;
}

pdm.setViewportScale = function() {
	var w = Math.max(Response.viewportH(), Response.viewportW());
	var h = Math.min(Response.viewportH(), Response.viewportW());
	var scale = Math.min(w/GAME_PX_W, h/GAME_PX_H);
	document.getElementById("viewport").setAttribute('content', "minimum-scale="+scale+", maximum-scale="+scale+", initial-scale="+scale+", user-scalable=no");
}

/*************************************/
/* Initialization functions          */
/*************************************/

function init(fn) { 
    POST_ASSET_LOAD_FN = (fn) ? fn : undefined;

    //Short-circuit if we don't want to load assets.
    if (!LOAD_ASSETS) { return;}
    loadAssets(); 
}

// Returns true if you can save games
pdm.canSave = function() {
	return typeof Storage !==undefined;
}

// Saves game
function saveGameState() {
	if (pdm.canSave()) {
		deleteSavedGame();
		localStorage.state = JSON.stringify(pdm.state, replaceCyclicStructures);
	} else {
		console.log("Whoops! Web storage not available. That means we can't save your game, so you'll have to beat it in one go like a boss. Go get 'em tiger.");
	}
//	try {
//		var s = JSON.stringify(pdm.state, replaceCyclicStructures);
//		$.cookie("state", s);
//	} catch (e) {
//			console.log(e.message);
//	}
}

pdm.hasSavedGame = function (){
	return pdm.canSave() && localStorage.state !== undefined;
	//return $.cookie("state");
}

function isCompatible(v1, v2) {
	return v1 == v2;
}

//Initializes the game state and returns true if using saved game
function initGameState() {
	if (pdm.hasSavedGame()) {
			//pdm.state = JSON.parse($.cookie("state"), revivePdm);
			pdm.state = JSON.parse(localStorage.state, revivePdm);
			if (isCompatible(pdm.state.version, VERSION)) {
				// saved state is from same version of game
				return true;
			} else {
				alert("Uh oh. Sadly, I can't load your game. You'll have to start fresh like a boss. Sorry about that.");
				deleteSavedGame();
				location.reload();
			}
	}
	pdm.state.currentLevel = 0;
	pdm.state.totalScore =0;
	pdm.state.lives= DEFAULT_LIVES;
	pdm.state.deaths= 0;
	pdm.state.difficulty = DIFFICULTIES.NORMAL;
	return false;
}

function loadAssets() {
//	    PANDA_IMG = createImgAsset("panda",
//            "<%= asset_path('Panda.png') %>");
//	    PORTAL_IMG = createImgAsset("portal",
//            "<%= asset_path('Goal_1.png') %>");
//	    HEAD_UP_IMG = createImgAsset("head_up",
//            "<%= asset_path('Head_Up.png') %>");
//	    HEAD_DOWN_IMG = createImgAsset("head_down",
//            "<%= asset_path('Head_Down.png') %>");
//	    HEAD_LEFT_IMG = createImgAsset("head_left",
//            "<%= asset_path('Head_Left.png') %>");
//	    HEAD_RIGHT_IMG = createImgAsset("head_right",
//            "<%= asset_path('Head_Right.png') %>");
//	    TAIL_UP_IMG = createImgAsset("tail_up",
//            "<%= asset_path('Tail_Up.png') %>");
//	    TAIL_DOWN_IMG = createImgAsset("tail_down",
//            "<%= asset_path('Tail_Down.png') %>");
//	    TAIL_LEFT_IMG = createImgAsset("tail_left",
//            "<%= asset_path('Tail_Right.png') %>");
//	    TAIL_RIGHT_IMG = createImgAsset("tail_right",
//            "<%= asset_path('Tail_Left.png') %>");
//        DOWN_TO_LEFT_IMG = createImgAsset("dtl",
//            "<%= asset_path('Body_UpToLeft.png') %>");
//        DOWN_TO_RIGHT_IMG = createImgAsset("dtr",
//            "<%= asset_path('Body_UpToRight.png') %>");
//        DOWN_TO_UP_IMG = createImgAsset("dtu",
//            "<%= asset_path('Body_DownToUp.png') %>");
//        LEFT_TO_DOWN_IMG= createImgAsset("ltd",
//            "<%= asset_path('Body_RightToDown.png') %>");
//        LEFT_TO_RIGHT_IMG= createImgAsset("ltr",
//            "<%= asset_path('Body_RightToLeft.png') %>");
//        LEFT_TO_UP_IMG= createImgAsset("ltu",
//            "<%= asset_path('Body_RightToUp.png') %>");
//        RIGHT_TO_DOWN_IMG= createImgAsset("rtd",
//            "<%= asset_path('Body_LeftToDown.png') %>");
//        RIGHT_TO_LEFT_IMG= createImgAsset("rtl",
//            "<%= asset_path('Body_LeftToRight.png') %>");
//        RIGHT_TO_UP_IMG= createImgAsset("rtu",
//            "<%= asset_path('Body_UpToLeft.png') %>");
//        UP_TO_DOWN_IMG= createImgAsset("utd",
//            "<%= asset_path('Body_UpToDown.png') %>");
//        UP_TO_LEFT_IMG= createImgAsset("utl",
//            "<%= asset_path('Body_DownToLeft.png') %>");
//        UP_TO_RIGHT_IMG= createImgAsset("utr",
//            "<%= asset_path('Body_DownToRight.png') %>");
//
//        TILES_IMG_ARRAY= [];
//        TILES_IMG_ARRAY.push(createImgAsset("tile_1",
//              "<%= asset_path('tiles.png') %>"));
//        TILES_IMG_ARRAY.push(createImgAsset("tile_2",
//              "<%= asset_path('tiles_2.png') %>"));
//        TILES_IMG_ARRAY.push(createImgAsset("tile_3",
//              "<%= asset_path('tiles_3.png') %>"));
//        TILES_IMG_ARRAY.push(createImgAsset("tile_4",
//              "<%= asset_path('tiles_4.png') %>"));
//
//				//load wall images
//        VERTICAL_WALL_IMG = createImgAsset("vw",
//            "<%= asset_path('wall_stright_horizontal.png') %>");
//        HORIZONTAL_WALL_IMG = createImgAsset("hw",
//            "<%= asset_path('wall_stright_vertical.png') %>");
//	    WALL_BLOCK_IMG = createImgAsset("pillar",
//          "<%= asset_path('wall_block.png') %>");
//
//		WALL_9S_TL_IMG = createImgAsset('wall_9s_tl', 
//          "<%= asset_path('wall_9slice_tl.png') %>");
//		WALL_9S_TC_IMG = createImgAsset('wall_9s_tc', 
//		    "<%= asset_path('wall_9slice_tc.png') %>");
//		WALL_9S_TR_IMG= createImgAsset('wall_9s_tr', 
//		    "<%= asset_path('wall_9slice_tr.png') %>");
//		WALL_9S_ML_IMG= createImgAsset('wall_9s_ml', 
//		    "<%= asset_path('wall_9slice_ml.png') %>");
//		WALL_9S_MC_IMG = createImgAsset('wall_9s_mc', 
//		    "<%= asset_path('wall_9slice_mc.png') %>");
//		WALL_9S_MR_IMG= createImgAsset('wall_9s_mr', 
//		    "<%= asset_path('wall_9slice_mr.png') %>");
//		WALL_9S_BL_IMG= createImgAsset('wall_9s_bl', 
//		    "<%= asset_path('wall_9slice_bl.png') %>");
//		WALL_9S_BC_IMG= createImgAsset('wall_9s_bc', 
//		    "<%= asset_path('wall_9slice_bc.png') %>");
//		WALL_9S_BR_IMG= createImgAsset('wall_9s_br', 
//          "<%= asset_path('wall_9slice_br.png') %>");
//		COMPLETE_IMG = createImgAsset('complete_img', "<%= asset_path('map_complete_128x128.png') %>");
//		CROWN_IMG = createImgAsset('crown_img', "<%= asset_path('map_crown_128x128.png') %>");
//		MAP_DRAGON_IMG = createImgAsset('map_dragon_img', "<%= asset_path('map_dragon_128x128.png') %>");
//		MAP_ICON = createImgAsset('map_icon_img', "<%= asset_path('mapIcon.png') %>");
//		PAUSE_ICON = createImgAsset('pause_icon_img', "<%= asset_path('pauseIcon.png') %>");
//		BACK_IMG = createImgAsset('back_img', "<%= asset_path('backIcon.png') %>");
//		// Options panel images
//		OPS_HOME_IMG = createImgAsset('ops_home', "<%= asset_path('options_home_white.png') %>");
//		OPS_FX_ON_IMG = createImgAsset('ops_fx_on', "<%= asset_path('options_fx_on_white.png') %>");
//		OPS_FX_OFF_IMG = createImgAsset('ops_fx_off', "<%= asset_path('options_fx_off_white.png') %>")
//		OPS_SOUND_ON_IMG = createImgAsset('ops_sound_on', "<%= asset_path('options_sound_on_white.png') %>")
//		OPS_SOUND_OFF_IMG = createImgAsset('ops_sound_off', "<%= asset_path('options_sound_off_white.png') %>")
//		OPS_SPEED_FAST_IMG = createImgAsset('ops_speed_fast', "<%= asset_path('options_speed_fast_white.png') %>")
//		OPS_SPEED_SLOW_IMG = createImgAsset('ops_speed_slow', "<%= asset_path('options_speed_slow_white.png') %>")

		//Sprite sheets
		PDM_SS_IMG = createImgAsset('pdm_static_ss', "<%= asset_path('pdm_dragon_panda.png') %>");
		WALL_TILES_SS_IMG = createImgAsset('wall_tiles_ss', "<%= asset_path('pdm_walls_tiles.png') %>");
		OPTIONS_SS_IMG = createImgAsset('options_map_ss', "<%= asset_path('pdm_options_map.png') %>");
		GOAL_SS_IMG = createImgAsset('Goal_all', "<%= asset_path('Goal_all.png') %>");
		LB_SS_IMG = createImgAsset('lb_ss', "<%= asset_path('lb_ss.png') %>"); // only used in level builder

		/* one-off images (not in sprite sheet) */
		MAP_IMG = createImgAsset('map', "<%= asset_path('map.png') %>");
		MAP_HEADER_BG = createImgAsset('map_header_bg', "<%= asset_path('optionsHeaderBg.png') %>");

		//Only used in level builder
//      	DELETE_IMG = createImgAsset("delete", 
//            "<%= asset_path('delete.png') %>");
//		PIX_IMG = createImgAsset('pix_1x1', "<%= asset_path('1x1.gif') %>");
}

function postAssetLoad() {
	PANDA_IMG = SPRITES['Panda.png'];
	//PORTAL_IMG = SPRITES['Goal_1.png'];
	PORTAL_IMG = SPRITES['Goal_all'];
	HEAD_UP_IMG = SPRITES['Head_Up.png'];
	HEAD_DOWN_IMG = SPRITES['Head_Down.png'];
	HEAD_LEFT_IMG = SPRITES['Head_Left.png'];
	HEAD_RIGHT_IMG = SPRITES['Head_Right.png'];
	TAIL_UP_IMG = SPRITES['Tail_Up.png'];
	TAIL_DOWN_IMG = SPRITES['Tail_Down.png'];
	TAIL_LEFT_IMG = SPRITES['Tail_Right.png'];
	TAIL_RIGHT_IMG = SPRITES['Tail_Left.png'];
	DOWN_TO_LEFT_IMG = SPRITES['Body_UpToLeft.png'];
	DOWN_TO_RIGHT_IMG = SPRITES['Body_UpToRight.png'];
	DOWN_TO_UP_IMG = SPRITES['Body_DownToUp.png'];
	LEFT_TO_DOWN_IMG= SPRITES['Body_RightToDown.png'];
	LEFT_TO_RIGHT_IMG= SPRITES['Body_RightToLeft.png'];
	LEFT_TO_UP_IMG= SPRITES['Body_RightToUp.png'];
	RIGHT_TO_DOWN_IMG= SPRITES['Body_LeftToDown.png'];
	RIGHT_TO_LEFT_IMG= SPRITES['Body_LeftToRight.png'];
	RIGHT_TO_UP_IMG= SPRITES['Body_UpToLeft.png'];
	UP_TO_DOWN_IMG= SPRITES['Body_UpToDown.png'];
	UP_TO_LEFT_IMG= SPRITES['Body_DownToLeft.png'];
	UP_TO_RIGHT_IMG= SPRITES['Body_DownToRight.png'];

	//load wall images
	VERTICAL_WALL_IMG = SPRITES['wall_stright_horizontal.png'];
	HORIZONTAL_WALL_IMG = SPRITES['wall_stright_vertical.png'];
	WALL_BLOCK_IMG = SPRITES['wall_block.png'];
	WALL_9S_TL_IMG = SPRITES['wall_9slice_tl.png'];
	WALL_9S_TC_IMG = SPRITES['wall_9slice_tc.png'];
	WALL_9S_TR_IMG= SPRITES['wall_9slice_tr.png'];
	WALL_9S_ML_IMG= SPRITES['wall_9slice_ml.png'];
	WALL_9S_MC_IMG = SPRITES['wall_9slice_mc.png'];
	WALL_9S_MR_IMG= SPRITES['wall_9slice_mr.png'];
	WALL_9S_BL_IMG= SPRITES['wall_9slice_bl.png'];
	WALL_9S_BC_IMG= SPRITES['wall_9slice_bc.png'];
	WALL_9S_BR_IMG= SPRITES['wall_9slice_br.png'];
	COMPLETE_IMG = SPRITES['map_complete_128x128.png'];
	CROWN_IMG = SPRITES['map_crown_128x128.png'];
	MAP_DRAGON_IMG = SPRITES['map_dragon_128x128.png'];
	MAP_ICON = SPRITES['mapIcon.png'];
	PAUSE_ICON = SPRITES['pauseIcon.png'];
	BACK_IMG = SPRITES['backIcon.png'];

	//level builder sprites
	DELETE_IMG = SPRITES['delete.png'];
	PIX_IMG = SPRITES['1x1.gif'];

	// Options panel images
	OPS_HOME_IMG = SPRITES['options_home_white.png'];
	OPS_FX_ON_IMG = SPRITES['options_fx_on_white.png'];

	OPS_FX_OFF_IMG = SPRITES['options_fx_off_white.png']
	OPS_SOUND_ON_IMG = SPRITES['options_sound_on_white.png'];
	OPS_SOUND_OFF_IMG = SPRITES['options_sound_off_white.png'];
	OPS_SPEED_FAST_IMG = SPRITES['options_speed_fast_white.png'];
	OPS_SPEED_SLOW_IMG = SPRITES['options_speed_slow_white.png'];
	
    /* Post-processing for assets */
    TILES_IMG_ARRAY= [
		SPRITES['tiles.png'],
		SPRITES['tiles_2.png'],
		SPRITES['tiles_3.png'],
		SPRITES['tiles_4.png']]

    //TODO: add all tile images to this array
    IMG_CACHE[MAP_IMG.pdmId] = MAP_IMG;
    IMG_CACHE[CROWN_IMG.pdmId] = CROWN_IMG;
    IMG_CACHE[COMPLETE_IMG.pdmId] = COMPLETE_IMG;

    OPS_SOUND_IMG = (PLAY_THEME) ? OPS_SOUND_ON_IMG : OPS_SOUND_OFF_IMG;
	OPS_FX_IMG = (PLAY_FX) ? OPS_FX_ON_IMG : OPS_FX_OFF_IMG;
    OPS_SPEED_IMG = OPS_SPEED_FAST_IMG;

    //All the corner walls within a 9 slice are the same right now.
    //FIXME: add real images for 9-slice corners
    WALL_9S_MCTR_IMG=
            WALL_9S_MCTL_IMG=
            WALL_9S_MCBR_IMG=
            WALL_9S_MCBL_IMG=
            WALL_9S_MC_IMG;
}



function createImgAsset($id,$src) {
	var img=new Image();
	loadFlags[$id]=0;
	img.onload=function(){onAssetLoaded($id, img);};
	img.src=$src;
	img.pdmId = IMG_PREFIX + $id;
//    img.height = GRID_H;
//    img.width = GRID_W;
	return img;
}

//Load all images
//for i in sprites, new sprite(ss_img, name)
//have a map of name : sprite properties (including animation)
//renderObject will recognize sprites: reuse img, set offset, animate, etc.

//type : {static, animation}
//Animation-only
//total_frames: 3
//width : 32
//height: 64

function Sprite (img, sx, sy, w, h, scale, total_frames) {
	this.img = img;
	this.src = img.src;
	this.pdmId = img.pdmId;
	this.sx = sx;
	this.sy = sy;
	this.sprite = true;
	this.w = w;
	this.h = h;

	this.scale = (scale) ? scale : SPRITE_SCALE;
	this.scaled_w = this.width = w*this.scale;
	this.scaled_h = this.height = h*this.scale;

	//Animation specifics
	this.current = 0;
	this.total_frames = (total_frames) ? total_frames : 1;
}

var SPRITES = {};
var SS_TYPES = {STATIC : 0, ANIMATION: 1}; //enum of sprite sheet types.

function initSprites(id, img) {
	var mySprites = SPRITE_MAP[id];
	if (mySprites == undefined) {return;}
	switch (mySprites.type) {
		case SS_TYPES.STATIC:
			//Need to create sprites for everything in the sheet.
			for (var i in mySprites.sprites) {
				var s = mySprites.sprites[i];
			    SPRITES[i] = new Sprite(img,
					s.frame.x,s.frame.y,
					s.frame.w, s.frame.h,
				 	s.scale);
			}
			break;
		case SS_TYPES.ANIMATION:
			//Create animation sprite.
			var s = mySprites;
			SPRITES[id] = new Sprite(img,
									0,0, s.w,s.h,
									s.scale, s.total_frames);
			break;
		default:
			console.log("Unknown spritesheet type found.");
			break;
		}
}

function onAssetLoaded(asset_id, img) {
	loadFlags[asset_id]=1;
	initSprites(asset_id, img);
    //Don't start the game until everything's been loaded
	for(flag in loadFlags) {
		if(!loadFlags[flag]) {return;}
	}
	postAssetLoad();
    if (POST_ASSET_LOAD_FN) {POST_ASSET_LOAD_FN();}
    //Only continue if we want to continue the game
    if (!INIT_GAME) { return;}
	game_init();
}

function game_init() {
    initSound();
	initUi();
	//Load game state if present, otherwise create initial state
    if (!initGameState()) {
		init_map();
	}
    maze_init();
}

function getTailImg(dir) {
	switch(dir) {
	    case "left":
	        return TAIL_LEFT_IMG;
	        break;
	    case "right":
	        return TAIL_RIGHT_IMG;
	        break;
	    case "up":
	        return TAIL_UP_IMG;
	        break;
	    case "down":
	        return TAIL_DOWN_IMG;
	        break;
	}
}

function pauseClick(e, evt) {
		var e = (evt) ? evt : e; 
        var pos = findPos(this);
        var x = e.pageX - pos.x - maze.xOffset - optionsX - opsPad;
        var y = e.pageY - pos.y - maze.yOffset;
		if (y>= GRID_H*5+opsPad && y <= GRID_H*5+opsPad+optionsH && x>=0) {
			if (x< OPS_TARGET_W) {
				changeSpeed();
			} else if (x <=OPS_TARGET_W*2+opsPad) {
				toggleFX();
			} else if (x <= OPS_TARGET_W*3+2*opsPad) {
				toggleMusic();
			} else if (x <= OPS_TARGET_W*4+3*opsPad) {
				window.location = "/";
			}
			renderScreen(ANIM_OFFSET); 
			renderPauseScreen();
		} else if (y>=GRID_H*4-(BACK_IMG.scaled_h/2) && y <= GRID_H*4+(BACK_IMG.scaled_h/2) &&
					x >= optionsW-(BACK_IMG.scaled_w/2) &&
					x <= optionsW+(BACK_IMG.scaled_w/2) ) {
				togglePauseScreen();
		}
}

function gameClick(e, evt) {
		var e = (evt) ? evt : e; 
		if (game_state == GAME_STATES.GAME_OVER) { return; }
        //See if you clicked an option and, if so, call the option fn.
        var pos = findPos(this);
        var x = e.pageX - pos.x - maze.xOffset;
        var y = e.pageY - pos.y - maze.yOffset;
        var c = Math.ceil(x/GRID_W);
        var r = Math.ceil(y/GRID_H);
        if (r==1 && c==PAUSE_ICON_POS) {
            togglePauseScreen();
        }  else if (r==1 && c==MAP_ICON_POS) {
            toggleOptions();
        }
}

function mapClick(e) {
	  if (!MAP_VISIBLE) { 
			// ignore clicks if not visible.
			$("#maze-canvas-background").trigger("click",[e]);
			return; 
		} 
      //See if you clicked an option and, if so, call the option fn.
      var pos = findPos(this);
      var x = e.pageX - pos.x - maze.xOffset;
      var y = e.pageY - pos.y - maze.yOffset;
      if ((x>= 391*SPRITE_SCALE) && (y >= 21*SPRITE_SCALE) && x <= (391*SPRITE_SCALE + BACK_IMG.scaled_w*(SPRITE_SCALE/2)) && y <= (21*SPRITE_SCALE + BACK_IMG.scaled_h*(SPRITE_SCALE/2))) {
          toggleOptions();
      }
}

function initUi() {
    //Init configuration panel
    //$("input[name=speed]:radio").click(function() {changeSpeed(this.value);});
    //$("#ctrl_fx").click(function() {toggleFX(this.checked);});
    //$("#ctrl_music").click(function() {toggleMusic(this.checked)});
    //$("#options_link").click(toggleOptions);
    //$("#mapItem").click(toggleOptions);
    //$("#options_done").click(toggleOptions);
    $("#home").click(function() {window.location="/"});
    $("#alert-close").click(function () {toggleAlert(false);});

    //$("#quit").click(function() {quit()});
    //Set up graphics
	gameCanvas = document.getElementById('maze-canvas');
	wallCanvas = document.getElementById('maze-canvas-background');
	mapCanvas = document.getElementById('map-canvas');
    tileCanvas = document.getElementById('tile-canvas');
    //scoreCanvas = document.getElementById('score-canvas');
	gameStage = gameCanvas.getContext("2d");
	wallStage = wallCanvas.getContext("2d");
	mapStage = mapCanvas.getContext("2d");
	tileStage = tileCanvas.getContext("2d");
	//scoreStage = scoreCanvas.getContext("2d");
	var hpx = MAX_ROWS*GRID_H+WALL_PAD;
    var wpx = MAX_COLS*GRID_W;
    $(gameCanvas).attr("height", hpx);
    $(gameCanvas).attr("width", wpx);
    $(wallCanvas).attr("height", hpx);
    $(wallCanvas).attr("width", wpx);
    $(mapCanvas).attr("height", hpx);
    $(mapCanvas).attr("width", wpx);
    $(tileCanvas).attr("height", hpx);
    $(tileCanvas).attr("width", wpx);
	counter = 0;
	CanvasTextFunctions.enable(gameStage);

    $("#maze-canvas-background").click(gameClick);
	$("#map-canvas").click(mapClick);
    
    //if (is_touch_device()) {
        JOYSTICK = new VirtualJoystick({
           //container   : document.getElementById('map-canvas'),
		   strokeStyle : "black",
           mouseSupport  : true
           });
    //}
    
}


function maze_init(){
    if(game_state == GAME_STATES.COMPLETE) {
        if (pdm.state.currentLevel>=pdm.state.map.levels.length){
			if (mixpanel) { mixpanel.track("Game completed");}
            gameComplete();
            return;
        }
		pdm.state.exitr = dragon.r;
		pdm.state.exitc = dragon.c;
		tileStage.clearRect(0,0,wallCanvas.width,wallCanvas.height);
    } 

    if (game_state != GAME_STATES.FAILED) {
      if (pdm.state.currentLevel >= pdm.state.map.levels.length) { 
		if (mixpanel) { mixpanel.track("Messed up cookies: given level "+pdm.state.currentLevel);}
        //Ran into messed up cookie values.
        pdm.state.currntLevel = 0; 
        pdm.state.totalScore = 0;
      }
		if (mixpanel) { mixpanel.track("Loading level "+pdm.state.currentLevel);}
	  	maze = new Maze(pdm.state.map.levels[pdm.state.currentLevel].currentMazeStr);
    }
	maze.reset();
	if (game_state == GAME_STATES.COMPLETE || game_state == GAME_STATES.UNINIT) {
		maze.renderTiles(tileStage);
	}

	game_state = GAME_STATES.READY;
	var rc = (maze.getEntry()) ? maze.getEntry(): maze.getStart();
	dragon = new Point(HEAD_DOWN_IMG, rc.r, rc.c, function () {});
	setHeadImg(dragon, pdm.state.exitdir);
	maze.addPoint(dragon);
	maze.render(wallStage);
	renderControls(wallStage);
	if (pdm.state.currentLevel==16 && maze.getPoint(9,6)) {maze.getPoint(9,6).isOn = function () {}};
	if (pdm.state.currentLevel==12 && maze.getPoint(13,9)) {maze.getPoint(13,9).isOn = function () {}};
    dir= (pdm.state.exitdir) ? pdm.state.exitdir : "start";
	var tmplvl= pdm.state.map.levels[pdm.state.currentLevel];
	if (!tmplvl.visited && tmplvl.visitMsg) { 
			toggleAlert(tmplvl.visitMsg);
	}
	//Only show visited message automatically once
	tmplvl.visited= true;
    startMusic();
	startGameLoop();
}

/*************************************/
/* Configuation functions            */
/*************************************/

function changeSpeed() {
     //console.log("Changing speed from "+MOVE_DELAY+" to "+s);
	 switch (OPS_SPEED_IMG) {
		case OPS_SPEED_FAST_IMG:
			OPS_SPEED_IMG = OPS_SPEED_SLOW_IMG;
			MOVE_DELAY= 10;
			break;
		default:
			OPS_SPEED_IMG = OPS_SPEED_FAST_IMG;
			MOVE_DELAY=5;
			break;
	}
}

/* Music and sound effects functions */

//Set up audio channels for seamless, simultaneous play of multiple sounds
//Thanks to http://www.storiesinflight.com/html5/audio.html 
function initSound() {
    //Code courtesy of http://html5doctor.com/native-audio-in-the-browser/
    var myAudio = $('#theme'); 
    if (myAudio.canPlayType) {
       // Currently canPlayType(type) returns: "", "maybe" or "probably" 
       //canPlayMp3 = !!myAudio.canPlayType && 
       //                 "" != myAudio.canPlayType('audio/mpeg');
       var canPlayOgg = !!myAudio.canPlayType && 
                        "" != myAudio.canPlayType('audio/ogg; codecs="vorbis"');
    }
    //Cache the appropriate audio source
    $.each($("audio"), function (i, v) {
                $.each($(v).children(), function (i2, v2) {
                        //Use ogg by default because it's smaller and open =)
                        if (v2.type == OGG_STR && canPlayOgg) {
                            AUDIO_SRC[v.id] = v2.src;
                        } else if (!canPlayOgg) {
                            //Otherwise set to MP3
                            AUDIO_SRC[v.id] = v2.src;
                        }
                    }
                )});
    
    for (a=0;a<CHANNEL_MAX;a++) { // prepare the channels
        AUDIOCHANNELS[a] = new Array();
        AUDIOCHANNELS[a]['channel'] = new Audio();// create a new audio object
        AUDIOCHANNELS[a]['finished'] = -1;// expected end time for this channel
    }
    //Workaround for Firefox and Safari
    THEME = new Audio();
    THEME.load();
    THEME.src=AUDIO_SRC['theme'];
    THEME.volume=.3;
    THEME.loop="loop";
    //Loop the theme track
    $(THEME).bind('ended', function() {this.currentTime=0});
}

function startMusic() {
    if (PLAY_THEME) {
        THEME.play();
        //$('#theme')[0].load();
        //$('#theme').bind('ended', function() {this.currentTime=0});
        //$('#theme')[0].volume=.3;
        //$('#theme')[0].play();
    }
}

function stopMusic() {
    //$('#theme')[0].pause();
    THEME.pause();
}

function toggleFX() {
    //PLAY_FX = on;
	PLAY_FX = !PLAY_FX;
	OPS_FX_IMG = (PLAY_FX) ? OPS_FX_ON_IMG : OPS_FX_OFF_IMG;
	//$("#fx-on").hasClass("no-display");
//	if (PLAY_FX) {
//		$("#fx-off").addClass("no-display");
//		$("#fx-on").removeClass("no-display");
//	} else {
//		$("#fx-on").addClass("no-display");
//		$("#fx-off").removeClass("no-display");
//	}
}

function toggleMusic() {
    //PLAY_THEME = on;
	PLAY_THEME = !PLAY_THEME;
	//PLAY_THEME = $("#music-on").hasClass("no-display");
    if (PLAY_THEME) {
        startMusic();
		OPS_SOUND_IMG = OPS_SOUND_ON_IMG;
		//$("#music-off").addClass("no-display");
		//$("#music-on").removeClass("no-display");
    } else {
        stopMusic();
		OPS_SOUND_IMG = OPS_SOUND_OFF_IMG;
		//$("#music-on").addClass("no-display");
		//$("#music-off").removeClass("no-display");
    }
}


//Shows an alert or message on the game canvas.
function toggleAlert(msg) {
	if (!$('#alert').hasClass("no-display")) {
		// Alert is visible
		var h = $('#alert').height();
		var t = -h -275;
		$("#alert").animate({top: t }, 1000, "easeInOutBack", 
			function () {
				$('#alert').addClass("no-display");
			});
		unpause();
	} else {
		// Alert isn't visible yet
		pause();
		$("#alert-text").text(msg);
		var h = $('#alert').height();
		var t = -h -275;
		var stop = GAME_PX_H/2 - h/2;
		$("#alert").css({top: t}).removeClass("no-display").animate({top: stop}, 1000, "easeInOutBack");
	}
}

function toggleOptions() {
  mapStage.clearRect(0,0,mapStage.canvas.width, mapStage.canvas.height);
  if (game_state == GAME_STATES.PAUSED) {
		MAP_VISIBLE = false;
		unpause();
		return;
	} else {
		MAP_VISIBLE = true;
		pause();
	
		//$("#lightbox").toggle();
		
		//draw the background image
		mapStage.drawImage(pdm.state.map.img,0,0);
		mapStage.globalAlpha = 0.9;
		mapStage.fillStyle = "#000000";
		mapStage.fillRect(0, 0, mapStage.canvas.width, pdm.state.map.gridH);
		mapStage.globalAlpha = 1;
	
		mapStage.drawImage(MAP_HEADER_BG,0,0);
		renderObject(mapStage, BACK_IMG,  391*SPRITE_SCALE, 21*SPRITE_SCALE);
		stagePrint("Collect all Pandas to complete a level.", 50, 40, mapStage); 
		stagePrint("Complete all levels to be AWESOME.", 50, 80, mapStage); 
		//mapStage.drawImage(BACK_IMG.img, 391*SPRITE_SCALE, 21*SPRITE_SCALE);
		
		
		// var renderOptions = function (stage, map) {
		// 	//Draw the options background
		// 	stage.globalAlpha = 0.5;
		// 	stage.fillStyle = "#000000";
		// 	stage.fillRect(0,0,mapStage.width, map.gridH);
		// 	stage.drawImage(map.optionsBgImg, 0,0);
		// 		
		// 	//draw the options row
		// 	for (var o in OPTIONS) {
		// 		stage.drawImage(OPTIONS[o].getImg(), map.xoff+o*OPTION_GRID_W, map.yoff);
		// 		OPTIONS[o].setPos(map.xoff+o*OPTION_GRID_W, map.yoff);
		// 	}
		// 	
		// }
		// renderOptions(mapStage);
			
		//Render levels
		for(var level = 0, numlvls = pdm.state.map.levels.length; level < numlvls; level +=1) {
			var x = pdm.state.map.gridW*(level%pdm.state.map.cols);
			var y = pdm.state.map.gridH*Math.floor(level/pdm.state.map.cols) + OPTIONS_BAR_HEIGHT;
			if (level==pdm.state.currentLevel) {
				//mapStage.drawImage(MAP_DRAGON_IMG, x,y);
				renderObject(mapStage, MAP_DRAGON_IMG,  x, y);
			} else if (!pdm.state.map.levels[level].visited) {
				mapStage.globalAlpha = 0.9;
				mapStage.fillStyle = "#000000";
				mapStage.fillRect(x, y, pdm.state.map.gridW, pdm.state.map.gridH);
				mapStage.globalAlpha = 1;
			} else if (pdm.state.map.levels[level].specialImg) {
				//mapStage.drawImage(pdm.state.map.specialImg, x, y);
				//renderObject(mapStage, pdm.state.map.specialImg,  x, y);
				renderObject(mapStage, pdm.state.map.specialImg,  x, y);
			} else if (pdm.state.map.levels[level].completed) {
				//mapStage.drawImage(pdm.state.map.completeImg, x, y);
				renderObject(mapStage, COMPLETE_IMG,  x, y);
			}
		}

	}
}

function deleteSavedGame() {
	localStorage.clear();
  //$.removeCookie("state");
//  $.removeCookie("CurrentLevel");
//  $.removeCookie("TotalScore");
}

function quit() {
  deleteSavedGame();
  window.location = "/";
}

//Plays multiple sounds simultaneously a bit more smoothly than would happen normally.
//Courtesy of http://www.storiesinflight.com/html5/audio.html. Thanks!
function playMultiSound(s) {
    if (PLAY_FX) {
        for (a=0;a<AUDIOCHANNELS.length;a++) {
            thistime = new Date();
            if (AUDIOCHANNELS[a]['finished'] < thistime.getTime()) {            // is this channel finished?
                AUDIOCHANNELS[a]['finished'] = thistime.getTime() + document.getElementById(s).duration*1000;
                AUDIOCHANNELS[a]['channel'].src = AUDIO_SRC[s];
                AUDIOCHANNELS[a]['channel'].load();
                AUDIOCHANNELS[a]['channel'].play();
                break;
            }
        }
    }
}


/*************************************/
/* Mazes                             */
/*************************************/

function init_map() {
	pdm.state.map = new Map(MAP_IMG, 3, 7, 128, 128, init_levels(), COMPLETE_IMG);
}

function init_levels() {
	lvls = [];
	//0 
	lvls.push(new Level("20f0e010101010101010101010101010101040000000000000000000000010100000000000000000000000001010000000000010000000000000101000000000001000000000000010100000000000100000000000003010100000002000100020000000003010100000000000100000000000003010100000000000100000000000001010000000000010000000000000101000000000001000000000000010100000000000100000000000001010000000000000000000000000101000000000000000000000000010101010101010101010101010101", "\Incessantly Growing Dragon awaits your command. \"Save all the pandas,\" IGD implores \"or none will be saved\"", "\"This commander is capable,\" IGD muses, \"but the path before us is seems long and filled with painful walls. Will this commander be up to the task?\"" ));
	//1
	lvls.push(new Level("20f0e0101010101010101010101010101010400000000000000000000000101000000000000000000000000010100000101010000010101000001010000000000000000000000000103000001000000000000000001000302030000010000000200000000010003020300000100000000000000000100030201000000000000000000000000010100000000000000000000000001010000010101000001010100000101000000000000000000000000010100000000000000000000000001010000000000000000000000000101010101010103080308010101010101"));
	//2
	lvls.push(new Level("20f0e0101010101010101010101010101010400000000000000000000000101000000000000000000000000010100010101000101000101010001010001000000000000000001000103010001000000000000000001000103010001000002000000020001000103010001000000000000000001000101000100000000000000000100010100010101000101000101010001010000000000000000000000000101000000000000000000000000010100000000000000000000000001010000000000000000000000000101010101010103090309010101010101"));
	//lvls.push(new Level("20f0e010101010101010101010101010101000000000000000000000000010100000000000000000000000001010001000002000001000000000101000000010001000000010000010301000000000000020000000200010301000100000004000100000000010301000000010001000000010000010100000000020000000000000001010001000000000001000000000101000000000000000000000000010100000000000000000000000001010000000000000000000000000101000000000000000000000000010101010101010101010101010101"));
	//3
	lvls.push(new Level("20f0e01010101010101010101010101010104000100000000000100000001010000010001010100010001000101000000000002000000020100010100000100010101000000010001010000010001000000010000000101000201000102000001010101010100000100000001000000000003040100000100000001000101010001010000010001010100000000000101000101000002000001000100010100000000010101000100010201010101000001000100010001000101000000000100010000000000010101030a0101010101010101010101", undefined, "\"Swift fingers, commander!\""));
	//4	
	//lvls.push(new Level("20f0e01010101010101010101010101010104000000000000000000000001010000000000000000000000000101000000000000000000000000010102020000010100000100000201010200020001000100020202010101020002000100010001000002010303020200000100010002000001010102000000010001000100000201010200000001000100020000010101020000000101000001000002010100000000000000000000000001010000000000000000000000000101000000000000000000000000010101010101030b030b030b010101010101"));
	lvls.push(new Level("20f0e01010101010101010101010101010104000000000000000000000001010000000000000000000000000101000000000000000000000000010100000100020102000100000001010000020000000100020000000101000001000100010001000000010303000002000102010002000000010100000100010001000100000001010000020001000000020000000101000001000201020001000000010100000000000000000000000001010000000000000000000000000101000000000000000000000000010101010101030b030b030b010101010101"));

	//5
	lvls.push(new Level("20f0e0101010101010101010101010101010000000000000000000000000101000101010201010102010100010100010000000000000000000001010001020000000000000000000101000100000000000000010101010100010001020101010201000003060100010000000000000001000001010001010101010100000100000101000000000000010000010002010100000101010001000101000101010000000201000100020100020101000000000100010000010000010100000000010401000000000001010101010101030c01010101010101"));

	//6
	lvls.push(new Level("20f0e01010101010101010101010101010100000000000000000000000001010000000201010101010200000101000000010000000000010000010100000001000200020001000001010000000100000000000100000103050000000100000000000100000101000000000100010001000000010100000000020002000200000001010000000102000200020100000101000000000100010001000000010100000000000000000000000001010400000000000000000000000101000000000000000000000000010101010101030d01010101030d010101", "\"I hear a whisper in the wind...no, I must concentrate on the Pandas first!\"", "\"The wind, it tells me that in a column of 3, the 1st will be false...how strange.\""));
	//7
	lvls.push(new Level("20f0e01010101010101010101010101010100000000000000000000000001010000000000000000000000000101000100000001000000010000010100020001000200010002000001010000000000000000000000000101000100000001000000010000010100000001000000010000000001010000000200000002000000000101000100000001000000010000010100000001000000010000000001010000000000000000000000000101000000000000040000000000010100000000000000000000000001010101010101030e030e010101010101"));
	//8
	lvls.push(new Level("20f0e0101010101010301030101010101010101040000000000000000000000010100000000000000000000000001010000000101010101010000000101000000010200000201000000010100000001000000000100000001010000000100000000010000000101000000010100000101000000010100000000000000000000000001010001000000000000000001000101000000000000000000000000010100000000000202000000000001010000000000000000000000000101000000000000000000000000010101010101010101010101010101"));
	//9
	lvls.push(new Level("20f0e01010101010103020302010101010101010000000000040000000000000101000000000000000000000000010100000001010101010100000001010000000000000000010000000101000000010201010101000000010100000001000000000100000001010000000101010201010000000101000000010000000001000000010100000001010201010100000001010000000000000000000000000101000000000000000000000000010100000000000000000000000001010000000000000000000000000101010101010103100310010101010101", "\"I doubt my commander is so nimble. Perhaps we should leave these Pandas to starve?\"", "\"Impressive! The soil will have far fewer Panda carcasas to feed it than I thought!\""));
	//10
	lvls.push(new Level("20f0e0101030301010101010101010101010104000000000000000000000001010001000000010000000100000101000000010002000100000000010100000000000000000000000001010101010101010101010101000101000000000000000000000000010100000000000000000000000001010001010101010101010100000101000000000000000000010000010100000000000000000001020001010101010101010101000101010101020000000000000000000000010100000000000000000000000001010101010101010101010103110101"));
	//11
	lvls.push(new Level("20f0e01010101010304030403040101010101010104000000000000000000000001010000000000000000000000000101000100000000000000010000010100010000000000000001000001010001000000020000000100000101020100000101010000010200030c01000100000002000000010000010100010000000000000001000001010001000000000000000100000101000000000000000000000000010100000000000000000000000001010000000000000000000000000101000000000000000000000000010101010101031203120312010101010101"));
	//12
	lvls.push(new Level("20f0e0101010101010305010101010101010100000000000000000000000001010000000000000000000000000101000000000000000000000000030d01000000000000000000010000010100000000000000000002000001030b04000000000000000001000001010000000000000002000200000101000000000000000100010000010100000000000200020002000001010000000000010001000100000101000000000002000200020000030d010001020102010201020100000101000000000000000000000000010101010101010101010101010101", "\"Impossible. Only the wind can move in such ways...\"", "\"Masterfully done, commander!\""));
	//13
	lvls.push(new Level("20f0e0101010101030601010101030601010101040000010001020201000100010100000001000100000100010001030c000000010000000000000100010100000001010100010101010001010000020000000000000000000101000100010101000102010000010100020000000000000000000001010001000102010001010102000101000002000000000000000000010100010101000102010001000001030c0000000000000000020000000101000102010001010100010000010100000000000000000000000001010101010101010314010101010101"));
	//14
	lvls.push(new Level("20f0e010101010101030703070101010101010100000000000000000000000001010001000000000000000001000101000001020000000002010000010100000001000000000100000001010000000001020001000000000101000000000001010200000004030f01000000000201010000000000030f0100000000010002010000000001010000020100000000010200000101000001000000000000010000010100010000000000000000010001010000000000000000000000000101000000000000000000000000010101010101010101010101010101", undefined, "\"Most excellent maneuvering!\" IGD gushes, \"Truly, someone should write a poem or something about my commander!\""));
	//15
	lvls.push(new Level("20f0e010101010101010101010101010101000000000000000000000000010100000000000000000000000001010000010001000001020100000101000002000000000000000000010100000100010000010001000001030e0000000000000400000000000310030e00000000000000000000000003100100000000000000000000000001010000010001000001000100000101000000000000000000020000010100000102010000010001000001010000000000000000000000000101000000000000000000000000010101010101010101010101010101"));
	//16
	lvls.push(new Level("20f0e0101010101010309030901010101010101000000000000000000000000010100000000000000000000000001010000000000000000000000000101000000000000000000000000010100000000000000000000000001030f0000000001000100000000000311030f00000000010201000000000003110100000000010401000000000001010000000001010100000000000101000000000000000000000000010100000000000000000000000001010000000000000000000000000101000000000000000000000000010101010101010101010101010101", "\"Only a fearless commander can save all Pandas,\"", "\"This may not be the last time we see such illusions.\""));
	//17
	lvls.push(new Level("20f0e0101010101010101010101030a0101010000000000000000010000000101000000000000000001000000010100000000000100000100000001010204000002010200010200000101010101000001000101010100010310000001000001000001020000010310000001000001000001000000010100000100000100000100000001010000010000010002010000000101000001000001000101000000010100000100000100000200000001010000000000010000000000000101000000000001000000000000010101010101010101010101010101"));
	//18
	lvls.push(new Level("20f0e0101010101030b030b030b010101010101010000020100000401020000000101000100010000000100010100010100010001010101010001010001010001000000000000000000000101000101010101010101000000010100000000000000000100000001010101010101010100010001000101020001000003630100010001000313010000010001010100010001000101000001000000000001000100010100000101010101010100010001010000000000000000000000000101000000000000000000000000010101010101010101010101010101"));
	//19
	lvls.push(new Level("20f0e0101010101010101010101010101010000000000000000000000000101000000000101000000000000010100000000010200000101000001010001010000000000010200000101000102000001010000000101010100000000000102000000010003140100000101000000000000010003140312000001020000000000000100031401000000000000010100000101010100000001010001020000000001010000000102000000000000000101000000000000000000000004010100000000000000000000000003140101010101010101010101010101", "\"The portal out of this dungeon is here, but shall we leave without all Pandas?\""));
	//20
	lvls.push(new Level("20f0e01010101010101030d0101010101010100000000000004000000000001010000000000000000000000000101000102020201020202010000010100020201020102010202000001010002020002010202020200000103130001020202010202020100000103130002020102020201020200000103130002020202020202020200000101000102020201020202010000010100020201020202010202000001010000000000000000000000000101000000000000000000000000010313000000000000000000000000010101010101010101010101010101", "\"Finally, a worthy challenge for my commander!\"", "\"Grandmaster! I am forever your dragon to command!\""));
	
	return lvls;
}

/*************************************/
/* I/O functions                     */
/*************************************/

function onTouchMove(evt) {
	evt.preventDefault();
	var jdir;
	if (JOYSTICK) {
		if (JOYSTICK.down()) { jdir = DOWN_ARROW;}
		else if (JOYSTICK.up()) { jdir = UP_ARROW;}
		else if (JOYSTICK.left()) { jdir = LEFT_ARROW;}
		else if (JOYSTICK.right()) { jdir = RIGHT_ARROW;}
	}
	procInput(jdir);
}

function onTouchEnd(evt) {
	evt.preventDefault();
	if (game_state == GAME_STATES.GAME_OVER) {
		procInput(ENTER);
	}
}

function onKeyDown(evt){
	//evt.preventDefault();
	procInput(evt.keyCode);
}

function procInput(action) {
	switch(game_state) {
		case GAME_STATES.PAUSED:
			switch(action) {
				case ESC:
					togglePauseScreen();
					break;
				default:
					//Do nothing
			}
			break;
		case GAME_STATES.READY:
			switch(action) {
				case LEFT_ARROW:
				case RIGHT_ARROW:
				case DOWN_ARROW:
				case UP_ARROW:
					gameStage.clearRect(0,0,gameCanvas.width,gameCanvas.height);
					//wallStage.clearRect(0,0,wallCanvas.width,wallCanvas.height);
					//maze.render(wallStage);
					//renderMazeObject(dragon,gameStage);
					renderMazeObject(dragon,wallStage);
					game_state=GAME_STATES.PLAYING;
					break;
				default:
					//Do nothing
			}
		case GAME_STATES.PLAYING:
			switch (action) {
	         	//Store in nextDir to save the last direction
				case LEFT_ARROW:
					nextDir = "left";
					break;
				case RIGHT_ARROW:
					nextDir = "right";
					break;
				case DOWN_ARROW:
					nextDir = "down";
					break;
				case UP_ARROW:
					nextDir = "up";
					break;
				case ESC:
					togglePauseScreen();
					break;
				default:
					//Do nothing
			}
			//can't turn back on yourself unless you've just entered a maze
			nextDir = (OPPOSITEDIR[nextDir] == dir && 
						!(dragon.r == maze.er &&
						 dragon.c == maze.ec)) ? dir : nextDir;
			break;
		case GAME_STATES.GAME_COMPLETE:
			//Fall through to GAME_OVER
		case GAME_STATES.GAME_OVER:
			switch(action) {
				case ENTER:
					$('#go-ok').trigger('click');
					//cleanUp();
					//window.location="/";
					break;
				default:
					break;
			}
			break;
		default:
			switch(action) {
				case LEFT_ARROW:
				case RIGHT_ARROW:
				case DOWN_ARROW:
				case UP_ARROW:
					//Only start if you've picked a direction to go in
					gameStage.clearRect(0,0,gameCanvas.width,gameCanvas.height);
					//mapStage.clearRect(0,0,mapCanvas.width,mapCanvas.height);
					wallStage.clearRect(0,0,wallCanvas.width,wallCanvas.height);
					maze_init();
					break;
				default:
					//Do nothing
			}
	}
}

/*************************************/
/* Game loop control functions       */
/*************************************/

// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
// requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel
// MIT license
(function() {
    var lastTime = 0;
    var vendors = ['ms', 'moz', 'webkit', 'o'];
    for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
        window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
        window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] 
                                   || window[vendors[x]+'CancelRequestAnimationFrame'];
    }
 
    if (!window.requestAnimationFrame)
        window.requestAnimationFrame = function(callback, element) {
            var currTime = new Date().getTime();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id = window.setTimeout(function() { callback(currTime + timeToCall); }, 
              timeToCall);
            lastTime = currTime + timeToCall;
            return id;
        };
 
    if (!window.cancelAnimationFrame)
        window.cancelAnimationFrame = function(id) {
            clearTimeout(id);
        };
}());

// Thanks Paul Irish. shim layer with setTimeout fallback
//Note this seems to break in Firefox and Safari, so I'm not using it.
//window.requestAnimFrame = (function(){
//  return  window.requestAnimationFrame       || 
//          window.webkitRequestAnimationFrame || 
//          window.mozRequestAnimationFrame    || 
//          window.oRequestAnimationFrame      || 
//          window.msRequestAnimationFrame     || 
//          function(/* function */ callback, /* DOMElement */ element){
//            window.setTimeout(callback, 1000 / 60);
//          };
//})();

//window.cancelRequestAnimFrame = ( function() {
//    return window.cancelAnimationFrame          ||
//        window.webkitCancelRequestAnimationFrame    ||
//        window.mozCancelRequestAnimationFrame       ||
//        window.oCancelRequestAnimationFrame     ||
//        window.msCancelRequestAnimationFrame        ||
//        window.clearTimeout;
//} )();

function pause() {
	PREPAUSE_GAME_STATE = game_state;
	game_state = GAME_STATES.PAUSED;
	stopGameLoop();
}

function unpause() {
	game_state = PREPAUSE_GAME_STATE;
	PREPAUSE_GAME_STATE = undefined;
	startGameLoop();
}


function startGameLoop() {
	window.onkeydown=onKeyDown;
	document.body.addEventListener('touchmove', onTouchMove);
	document.body.addEventListener('touchend', onTouchEnd);
	gameLoop();
}

function gameLoop() {
	if (request) {
		stopGameLoop();
	}
	//request=window.requestAnimationFrame(gameLoop,gameCanvas);
    request = window.setTimeout(gameLoop, FRAMERATE);
	update();
}

function stopGameLoop() {
	//window.cancelAnimationFrame(request);
    window.clearTimeout(request);
	request = undefined;
}

var PAUSE_Y = -103*SPRITE_SCALE;
var ANIM_OFFSET = 0;
var ctrlHidden= false, pauseInPlace = false;

function resetAnimVals() {
	PAUSE_Y = -103*SPRITE_SCALE;
	ANIM_OFFSET = 0;
	ctrlHidden= false, pauseInPlace = false;
}

function togglePauseScreen() {
		if (game_state == GAME_STATES.PAUSED) {
			window.clearTimeout(request);
			ctrlHidden = false;
			pauseInPlace = false;
			pauseOutLoop();
		} else {
			pause();
    		$("#maze-canvas-background").unbind("click", gameClick);
			pauseInLoop();
		}
}

function pauseOutLoop() {
	if (ctrlHidden && pauseInPlace) {
			window.clearTimeout(request);
    		$("#maze-canvas-background").unbind("click", pauseClick);
    		$("#maze-canvas-background").click(gameClick);
			resetAnimVals();
			unpause();
			return;
	}
	if (pauseInPlace && !ctrlHidden) {
		ANIM_OFFSET -= 10*SPRITE_SCALE;
	}
	if (!pauseInPlace) {
		PAUSE_Y -= 10*SPRITE_SCALE;
	}
	renderScreen(ANIM_OFFSET); 
	renderPauseScreen();
	pauseInPlace = (PAUSE_Y <= -103*SPRITE_SCALE);
	ctrlHidden = ANIM_OFFSET<=0;
    request = window.setTimeout(pauseOutLoop, FRAMERATE);
}

function pauseInLoop() {
	if (ctrlHidden && pauseInPlace) {
			window.clearTimeout(request);
    		$("#maze-canvas-background").click(pauseClick);
			return;
	}
	if (!ctrlHidden) {
		ANIM_OFFSET += 10*SPRITE_SCALE;
	}
	if (ctrlHidden && !pauseInPlace) {
		PAUSE_Y += 10*SPRITE_SCALE;
	}
	renderScreen(ANIM_OFFSET); 
	renderPauseScreen();
	//render options images and circle
	pauseInPlace = (PAUSE_Y >= 4*GRID_H);
	ctrlHidden = ANIM_OFFSET>GRID_W*5;
    request = window.setTimeout(pauseInLoop, FRAMERATE);
}

function update() {
    //Set the right head image depending on the direction
	setHeadImg(dragon, dir);
	renderScreen();

    if (game_state == GAME_STATES.PLAYING) {
    	counter += 1;
    	if (counter>MOVE_DELAY) {
    		var oldR = dragon.r;
    		var oldC = dragon.c;
            lastDir = dir;
            dir = nextDir;
    	
    		if (dir=="left") {
    			dragon.c = dragon.c - 1;
    			counter =0;
    		}
    		if (dir=="right") {
    			dragon.c = dragon.c + 1;
    			counter =0;
    		}
    		if (dir=="up") {
    			dragon.r = dragon.r - 1;
    			counter =0;
    		}
    		if (dir=="down") {	
    			dragon.r = dragon.r + 1;
    			counter =0;
    		}	

			maze.removePoint(oldR, oldC);
			maze.addDragonBody(dir, lastDir, oldR, oldC);

    		maze.isOn(dragon.r, dragon.c);
		    if (game_state != GAME_STATES.PLAYING) { return; }
            //if (dir!="start") {
            //    //LEVEL_SCORE += EARNED_POINTS[MOVE_DELAY];
    		//}
			maze.addPoint(dragon);

          }
        }
	}


/*************************************/
/* Rendering functions               */
/*************************************/


/** roundRect
 * @author Juan Mendes
 * http://js-bits.blogspot.com/2010/07/canvas-rounded-corner-rectangles.html
 * 
 * Draws a rounded rectangle using the current state of the canvas. 
 * If you omit the last three params, it will draw a rectangle 
 * outline with a 5 pixel border radius 
 * @param {CanvasRenderingContext2D} ctx
 * @param {Number} x The top left x coordinate
 * @param {Number} y The top left y coordinate 
 * @param {Number} width The width of the rectangle 
 * @param {Number} height The height of the rectangle
 * @param {Number} radius The corner radius. Defaults to 5;
 * @param {Boolean} fill string reprsenting color for rectanble fill. 
 * @param {Boolean} stroke Whether to stroke the rectangle. Defaults to true.
 */
function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
  if (typeof stroke == "undefined" ) {
    stroke = true;
  }
  if (typeof radius === "undefined") {
    radius = 5;
  }

  if (typeof fill === "undefined") {
	fill = false;
	}
  ctx.beginPath();
  ctx.moveTo(x + radius, y);
  ctx.lineTo(x + width - radius, y);
  ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
  ctx.lineTo(x + width, y + height - radius);
  ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
  ctx.lineTo(x + radius, y + height);
  ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
  ctx.lineTo(x, y + radius);
  ctx.quadraticCurveTo(x, y, x + radius, y);
  ctx.closePath();
  if (stroke) {
    ctx.stroke();
  }
  if (fill) {
	ctx.fillStyle = fill;
    ctx.fill();
  }        
}

// updates the current score by adding p points to it
function updateScore(p) {
       SCORE += p;
}

//Prints the game state string in the center of the maze
//function printState () {
//	//gameStage.drawTextCenter("sans", 16, maze.getCenterX(), maze.getCenterY(), game_state); 
//}

//Prints text at x and y on the given stage
function stagePrint(text, x, y, stage, fill, font) {
	if (typeof fill === "undefined") {
		fill = "#000";
	}
	if (typeof font === "undefined") {
		font = "18px StarPerv";
	}
	stage.fillStyle = fill;
	stage.font = font;
	stage.textBaseline = 'top';
	stage.fillText(text, x, y);
}


//renders the screen
function renderScreen(xOff, yOff) {
	xOff = (xOff) ? xOff : 0;
	yOff = (yOff) ? yOff : 0;
    wallStage.clearRect(0,0, wallCanvas.width, wallCanvas.height);
    maze.render(wallStage);
	if (!CONTROLS_HIDDEN) {
		renderControls(wallStage, xOff, yOff);
	}
}

function renderControls(stage, xOff, yOff) {
	xOff = (xOff) ? xOff : 0;
	yOff = (yOff) ? yOff : 0;

	/* Begin left-side controls */

	var hpb = 10*SPRITE_SCALE; //horizontal padding between ctrl boxes
	var vpb = 6*SPRITE_SCALE+yOff; //vertical padding between ctrl boxes
	var vpt = 8*SPRITE_SCALE+yOff; //vert pad text;
	var lcs = hpb - xOff; //left ctrl start
	var pend = lcs + 80*SPRITE_SCALE; //panda end

	var bh = 12*SPRITE_SCALE;
	var br = 3*SPRITE_SCALE;

	//Panda box
	//draw background box
	roundRect(stage, lcs, vpb, 80*SPRITE_SCALE, bh, br, "rgba(0,0,0, 0.8)", false);
	//render Panda
	renderObject(stage, PANDA_IMG, 7*SPRITE_SCALE-xOff, 3*SPRITE_SCALE+yOff, SPRITE_SCALE/2);
	//render total score
	stagePrint("x" + pdm.state.totalScore+" + "+LEVEL_SCORE,  23*SPRITE_SCALE-xOff, vpt, stage, "#fff");


	//Lives box
	var lives_x= pend+hpb;
	//draw background box
	roundRect(stage, lives_x, vpb, 40*SPRITE_SCALE, bh, br, "rgba(0,0,0, 0.8)", false);
	//render Panda
	renderObject(stage, HEAD_DOWN_IMG, lives_x-5*SPRITE_SCALE, SPRITE_SCALE+yOff, SPRITE_SCALE/2);
	//render total score
	stagePrint("x" + pdm.state.lives,  lives_x+14*SPRITE_SCALE, vpt, stage, "#fff");

	/* render right-side controls */
	//render mapicon
	var xy = maze.grid2canvas(1, MAP_ICON_POS);
	renderObject(stage, MAP_ICON, xy.x+xOff, 0+yOff);

	//render pause 
	xy = maze.grid2canvas(1, PAUSE_ICON_POS);
	renderObject(stage, PAUSE_ICON, xy.x+xOff, 0+yOff);
}

//Renders the pause screen
function renderPauseScreen(xOff, yOff) {
	xOff = (xOff) ? xOff : 0;
	yOff = (yOff) ? yOff : PAUSE_Y;
	var opsArr = [OPS_SPEED_IMG, OPS_FX_IMG, OPS_SOUND_IMG, OPS_HOME_IMG];
	roundRect(wallStage, optionsX, PAUSE_Y, 
		optionsW, optionsH, 10*SPRITE_SCALE, 
		"rgba(0,0,0, 0.8)", false);
	for (var i=0; i < opsArr.length; i++) {
		var tmpX = optionsX+opsPad+OPS_TARGET_W*i+opsPad*i;
		var tmpY = yOff+GRID_H+opsPad;
		renderObject(wallStage, BACK_IMG, optionsX+optionsW-(BACK_IMG.scaled_w/2),
			yOff-(BACK_IMG.scaled_h/2));
		renderObject(wallStage, opsArr[i], tmpX, tmpY);
		switch (i) {
			case 0:
				stagePrint("speed", tmpX+opsPad, tmpY+OPS_TARGET_H, wallStage, "#fff", "24px StarPerv");
				break;
			case 1:
				stagePrint("fx", tmpX+opsPad+opsPad+opsPad+opsPad, tmpY+OPS_TARGET_H, wallStage, "#fff", "24px StarPerv");
				break;
			case 2:
				stagePrint("music", tmpX+opsPad, tmpY+OPS_TARGET_H, wallStage, "#fff", "24px StarPerv");
				break;
			case 3:
				stagePrint("home", tmpX+opsPad+opsPad+opsPad, tmpY+OPS_TARGET_H, wallStage, "#fff", "24px StarPerv");
				break;
			default:
				//no op
				break;
		}
	}
}

//Abstract the details of drawing to support multiple platoforms.
//Today, only rendering on HTML5 cavas is supported, but not for long
function renderObject(stage, sprite, x, y, scale) {
	var sx = sprite.sx + sprite.w*sprite.current;
	var sw = (scale) ? sprite.w * scale : sprite.scaled_w;
	var sh = (scale) ? sprite.h * scale : sprite.scaled_h;
	stage.drawImage(sprite.img, 
			sx, sprite.sy, sprite.w, sprite.h,
			x, y, sw, sh);
	sprite.current = (sprite.current + 1 ) % sprite.total_frames;
}

/*
* Default rendering engine
*/
function renderMazeObject($obj, stage) {
	if ($obj.img == undefined){ return; }
	var xy=maze.grid2canvas($obj.r, $obj.c);
    var x = xy.x+$obj.xOffset;
    var y = xy.y+$obj.yOffset;
	try {
		renderObject(stage, $obj.img,x,y);
		if (DEBUG && $obj.obj_type && $obj.obj_type == TYPES.GOAL) {
			stagePrint($obj.destination, xy.x+Math.floor(GRID_W/2), xy.y, stage, "#000", "12px sans-serif");
		}
	} catch($error) {
		alert($error.message);
		console.log("Error rendering object: "+ $error.message)
	}
}

//Main functions held in respective pages.

/*************************************/
/* Animation  functions	             */
/*************************************/


/*
* animates something
* drawFn a function that takes an alpha val and renders something
* from starting position
* to ending position
* completeFn a function to be called after fade OUT is complete
* easing a function for easing in/out
*/
function animate(drawFn, from, to, completeFn, easing) {
	easing = (easing) ? easing : function (o) {return o;};
	completeFn = (completeFn) ? completeFn : function () {};
	var offset = 0, e = 0, i=20, dist = Math.abs(to-from);
	var m = (from < to) ? -1 : 1;
	var interval = setInterval(function () {
			e = easing(offset);
			drawFn(from+e);
			offset += i;
			if (offset > dist) {
                clearInterval(interval);
				 completeFn();
			}
        }, FRAMERATE); 
}

function toggleControls(completeFn) {
	completeFn = (completeFn) ? completeFn : function () {};
	var chv = !CONTROLS_HIDDEN;//hack so that we can render when showing controls
	var from = (CONTROLS_HIDDEN) ? -(GRID_W*5) : CONTROL_POS;
	var to = (CONTROLS_HIDDEN) ? CONTROL_POS : -(GRID_W*5);
	CONTROLS_HIDDEN = false;
	animate(renderScreen, from, to, 
		function () {
			CONTROLS_HIDDEN=chv;
			completeFn();
		});
}

//function pauseInLoop() {
//	//Hide the controls
//	if (ctrlHidden && pauseInPlace) {
//			window.clearTimeout(request);
//    		$("#maze-canvas-background").click(pauseClick);
//			return;
//	}
//	if (!ctrlHidden) {
//		ANIM_OFFSET += 10*SPRITE_SCALE;
//	}
//	if (ctrlHidden && !pauseInPlace) {
//		PAUSE_Y += 10*SPRITE_SCALE;
//	}
//	renderScreen(ANIM_OFFSET); 
//	renderPauseScreen();
//	//render options images and circle
//	pauseInPlace = (PAUSE_Y >= 4*GRID_H);
//	ctrlHidden = ANIM_OFFSET>GRID_W*5;
//    request = window.setTimeout(pauseInLoop, FRAMERATE);
//}

/*
* fades something IN
* drawFn a function that takes an alpha val and renders something
* completeFn a function to be called after fade OUT is complete
*/
function fadeIn(drawFn, completeFn) {
	var alpha = 0.0;
	var interval = setInterval(function () {
            alpha = alpha + 0.05; // decrease opacity (fade out)
			drawFn(alpha);
            if (alpha > 1.0) {
                clearInterval(interval);
				if (completeFn) {
					completeFn();
				}
            }
        }, 50); 
}

/*
* fades something OUT 
* drawFn a function that takes an alpha val and renders something
* completeFn a function to be called after fade OUT is complete
*/
function fadeOut(drawFn, completeFn) {
	var alpha = 1.0;
	var interval = setInterval(function () {
            alpha = alpha - 0.05; // decrease opacity (fade out)
			drawFn(alpha);
            if (alpha < 0.0) {
                clearInterval(interval);
				if (completeFn) {
					completeFn();
				}
            }
        }, 50); 
}

/*************************************/
/* Sprite Map	                     */
/*************************************/

//maps sprites to the images in which they are held.
var SPRITE_MAP = {
"Goal_all" : {"type": SS_TYPES.ANIMATION,
				"total_frames": 3,
				"w" : 33,
				"h" : 38
				},
"pdm_static_ss": {
		"type" : SS_TYPES.STATIC,
		"sprites": {

"Body_DownToLeft.png":
{
	"frame": {"x":2,"y":2,"w":32,"h":16},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
	"sourceSize": {"w":32,"h":16}
},
"Body_DownToRight.png":
{
	"frame": {"x":36,"y":2,"w":32,"h":16},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
	"sourceSize": {"w":32,"h":16}
},
"Body_DownToUp.png":
{
	"frame": {"x":70,"y":2,"w":32,"h":16},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
	"sourceSize": {"w":32,"h":16}
},
"Body_LeftToDown.png":
{
	"frame": {"x":2,"y":20,"w":32,"h":16},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
	"sourceSize": {"w":32,"h":16}
},
"Body_LeftToRight.png":
{
	"frame": {"x":36,"y":20,"w":32,"h":16},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
	"sourceSize": {"w":32,"h":16}
},
"Body_LeftToUp.png":
{
	"frame": {"x":70,"y":20,"w":32,"h":16},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
	"sourceSize": {"w":32,"h":16}
},
"Body_RightToDown.png":
{
	"frame": {"x":2,"y":38,"w":32,"h":16},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
	"sourceSize": {"w":32,"h":16}
},
"Body_RightToLeft.png":
{
	"frame": {"x":36,"y":38,"w":32,"h":16},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
	"sourceSize": {"w":32,"h":16}
},
"Body_RightToUp.png":
{
	"frame": {"x":70,"y":38,"w":32,"h":16},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
	"sourceSize": {"w":32,"h":16}
},
"Body_UpToDown.png":
{
	"frame": {"x":2,"y":56,"w":32,"h":16},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
	"sourceSize": {"w":32,"h":16}
},
"Body_UpToLeft.png":
{
	"frame": {"x":36,"y":56,"w":32,"h":16},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
	"sourceSize": {"w":32,"h":16}
},
"Body_UpToRight.png":
{
	"frame": {"x":70,"y":56,"w":32,"h":16},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
	"sourceSize": {"w":32,"h":16}
},
"Goal_1.png":
{
	"frame": {"x":2,"y":74,"w":33,"h":38},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":33,"h":38},
	"sourceSize": {"w":33,"h":38}
},
"Head_Down.png":
{
	"frame": {"x":37,"y":74,"w":32,"h":32},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":32,"h":32},
	"sourceSize": {"w":32,"h":32}
},
"Head_Left.png":
{
	"frame": {"x":71,"y":74,"w":32,"h":32},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":32,"h":32},
	"sourceSize": {"w":32,"h":32}
},
"Head_Right.png":
{
	"frame": {"x":2,"y":114,"w":32,"h":32},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":32,"h":32},
	"sourceSize": {"w":32,"h":32}
},
"Head_Up.png":
{
	"frame": {"x":36,"y":114,"w":32,"h":32},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":32,"h":32},
	"sourceSize": {"w":32,"h":32}
},
"Panda.png":
{
	"frame": {"x":70,"y":114,"w":24,"h":25},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":24,"h":25},
	"sourceSize": {"w":24,"h":25}
},
"Tail_Down.png":
{
	"frame": {"x":2,"y":148,"w":32,"h":16},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
	"sourceSize": {"w":32,"h":16}
},
"Tail_Left.png":
{
	"frame": {"x":36,"y":148,"w":32,"h":16},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
	"sourceSize": {"w":32,"h":16}
},
"Tail_Right.png":
{
	"frame": {"x":70,"y":148,"w":32,"h":16},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
	"sourceSize": {"w":32,"h":16}
},
"Tail_Up.png":
{
	"frame": {"x":2,"y":166,"w":32,"h":16},
	"rotated": false,
	"trimmed": false,
	"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
	"sourceSize": {"w":32,"h":16}
}}},

"options_map_ss" : {
	"type" : SS_TYPES.STATIC,
	"sprites" :
		{"backIcon.png":
		 {
			"scale" : 1,
			"frame": {"x":2,"y":2,"w":64,"h":56},
			"rotated": false,
			"trimmed": false,
			"spriteSourceSize": {"x":0,"y":0,"w":64,"h":56},
			"sourceSize": {"w":64,"h":56}
		},
		"mapIcon.png":
		{
			"scale" : 1,
			"frame": {"x":68,"y":2,"w":64,"h":56},
			"rotated": false,
			"trimmed": false,
			"spriteSourceSize": {"x":0,"y":0,"w":64,"h":56},
			"sourceSize": {"w":64,"h":56}
		},
		"map_complete_128x128.png":
		{
			"scale" : 1,
			"frame": {"x":134,"y":2,"w":128,"h":128},
			"rotated": false,
			"trimmed": false,
			"spriteSourceSize": {"x":0,"y":0,"w":128,"h":128},
			"sourceSize": {"w":128,"h":128}
		},
		"map_crown_128x128.png":
		{
			"scale" : 1,
			"frame": {"x":264,"y":2,"w":128,"h":128},
			"rotated": false,
			"trimmed": false,
			"spriteSourceSize": {"x":0,"y":0,"w":128,"h":128},
			"sourceSize": {"w":128,"h":128}
		},
		"map_dragon_128x128.png":
		{
			"scale" : 1,
			"frame": {"x":2,"y":132,"w":128,"h":128},
			"rotated": false,
			"trimmed": false,
			"spriteSourceSize": {"x":0,"y":0,"w":128,"h":128},
			"sourceSize": {"w":128,"h":128}
		},
		"options_fx_off_white.png":
		{
			"scale" : 1,
			"frame": {"x":132,"y":132,"w":120,"h":105},
			"rotated": false,
			"trimmed": false,
			"spriteSourceSize": {"x":0,"y":0,"w":120,"h":105},
			"sourceSize": {"w":120,"h":105}
		},
		"options_fx_on_white.png":
		{
			"scale" : 1,
			"frame": {"x":254,"y":132,"w":120,"h":105},
			"rotated": false,
			"trimmed": false,
			"spriteSourceSize": {"x":0,"y":0,"w":120,"h":105},
			"sourceSize": {"w":120,"h":105}
		},
		"options_home_white.png":
		{
			"scale" : 1,
			"frame": {"x":376,"y":132,"w":120,"h":105},
			"rotated": false,
			"trimmed": false,
			"spriteSourceSize": {"x":0,"y":0,"w":120,"h":105},
			"sourceSize": {"w":120,"h":105}
		},
		"options_sound_off_white.png":
		{
			"scale" : 1,
			"frame": {"x":2,"y":262,"w":120,"h":105},
			"rotated": false,
			"trimmed": false,
			"spriteSourceSize": {"x":0,"y":0,"w":120,"h":105},
			"sourceSize": {"w":120,"h":105}
		},
		"options_sound_on_white.png":
		{
			"scale" : 1,
			"frame": {"x":124,"y":262,"w":120,"h":105},
			"rotated": false,
			"trimmed": false,
			"spriteSourceSize": {"x":0,"y":0,"w":120,"h":105},
			"sourceSize": {"w":120,"h":105}
		},
		"options_speed_fast_white.png":
		{
			"scale" : 1,
			"frame": {"x":246,"y":262,"w":120,"h":105},
			"rotated": false,
			"trimmed": false,
			"spriteSourceSize": {"x":0,"y":0,"w":120,"h":105},
			"sourceSize": {"w":120,"h":105}
		},
		"options_speed_slow_white.png":
		{
			"scale" : 1,
			"frame": {"x":368,"y":262,"w":120,"h":105},
			"rotated": false,
			"trimmed": false,
			"spriteSourceSize": {"x":0,"y":0,"w":120,"h":105},
			"sourceSize": {"w":120,"h":105}
		},
		"pauseIcon.png":
		{
			"scale" : 1,
			"frame": {"x":2,"y":369,"w":64,"h":56},
			"rotated": false,
			"trimmed": false,
			"spriteSourceSize": {"x":0,"y":0,"w":64,"h":56},
			"sourceSize": {"w":64,"h":56}
		}}},


"wall_tiles_ss" : {
		"type" : SS_TYPES.STATIC,
		"sprites" : {

			"tiles.png":
			{
				"frame": {"x":2,"y":2,"w":32,"h":16},
				"rotated": false,
				"trimmed": false,
				"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
				"sourceSize": {"w":32,"h":16}
			},
			"tiles_2.png":
			{
				"frame": {"x":36,"y":2,"w":32,"h":16},
				"rotated": false,
				"trimmed": false,
				"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
				"sourceSize": {"w":32,"h":16}
			},
			"tiles_3.png":
			{
				"frame": {"x":70,"y":2,"w":32,"h":16},
				"rotated": false,
				"trimmed": false,
				"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
				"sourceSize": {"w":32,"h":16}
			},
			"tiles_4.png":
			{
				"frame": {"x":2,"y":20,"w":32,"h":16},
				"rotated": false,
				"trimmed": false,
				"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
				"sourceSize": {"w":32,"h":16}
			},
			"wall_9slice_bc.png":
			{
				"frame": {"x":36,"y":20,"w":32,"h":26},
				"rotated": false,
				"trimmed": false,
				"spriteSourceSize": {"x":0,"y":0,"w":32,"h":26},
				"sourceSize": {"w":32,"h":26}
			},
			"wall_9slice_bl.png":
			{
				"frame": {"x":70,"y":20,"w":32,"h":26},
				"rotated": false,
				"trimmed": false,
				"spriteSourceSize": {"x":0,"y":0,"w":32,"h":26},
				"sourceSize": {"w":32,"h":26}
			},
			"wall_9slice_bm.png":
			{
				"frame": {"x":36,"y":20,"w":32,"h":26},
				"rotated": false,
				"trimmed": false,
				"spriteSourceSize": {"x":0,"y":0,"w":32,"h":26},
				"sourceSize": {"w":32,"h":26}
			},
			"wall_9slice_br.png":
			{
				"frame": {"x":2,"y":48,"w":32,"h":26},
				"rotated": false,
				"trimmed": false,
				"spriteSourceSize": {"x":0,"y":0,"w":32,"h":26},
				"sourceSize": {"w":32,"h":26}
			},
			"wall_9slice_mc.png":
			{
				"frame": {"x":36,"y":48,"w":32,"h":16},
				"rotated": false,
				"trimmed": false,
				"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
				"sourceSize": {"w":32,"h":16}
			},
			"wall_9slice_ml.png":
			{
				"frame": {"x":70,"y":48,"w":32,"h":16},
				"rotated": false,
				"trimmed": false,
				"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
				"sourceSize": {"w":32,"h":16}
			},
			"wall_9slice_mr.png":
			{
				"frame": {"x":2,"y":76,"w":32,"h":16},
				"rotated": false,
				"trimmed": false,
				"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
				"sourceSize": {"w":32,"h":16}
			},
			"wall_9slice_tc.png":
			{
				"frame": {"x":36,"y":76,"w":32,"h":16},
				"rotated": false,
				"trimmed": false,
				"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
				"sourceSize": {"w":32,"h":16}
			},
			"wall_9slice_tl.png":
			{
				"frame": {"x":70,"y":76,"w":32,"h":16},
				"rotated": false,
				"trimmed": false,
				"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
				"sourceSize": {"w":32,"h":16}
			},
			"wall_9slice_tr.png":
			{
				"frame": {"x":2,"y":94,"w":32,"h":16},
				"rotated": false,
				"trimmed": false,
				"spriteSourceSize": {"x":0,"y":0,"w":32,"h":16},
				"sourceSize": {"w":32,"h":16}
			},
			"wall_block.png":
			{
				"frame": {"x":36,"y":94,"w":32,"h":26},
				"rotated": false,
				"trimmed": false,
				"spriteSourceSize": {"x":0,"y":0,"w":32,"h":26},
				"sourceSize": {"w":32,"h":26}
			},
			"wall_block_center.png":
			{
				"frame": {"x":70,"y":94,"w":32,"h":26},
				"rotated": false,
				"trimmed": false,
				"spriteSourceSize": {"x":0,"y":0,"w":32,"h":26},
				"sourceSize": {"w":32,"h":26}
			},
			"wall_stright_horizontal.png":
			{
				"frame": {"x":2,"y":122,"w":32,"h":22},
				"rotated": false,
				"trimmed": false,
				"spriteSourceSize": {"x":0,"y":0,"w":32,"h":22},
				"sourceSize": {"w":32,"h":22}
			},
			"wall_stright_vertical.png":
			{
				"frame": {"x":36,"y":122,"w":32,"h":23},
				"rotated": false,
				"trimmed": false,
				"spriteSourceSize": {"x":0,"y":0,"w":32,"h":23},
				"sourceSize": {"w":32,"h":23}
			}}},

		"lb_ss" : {
				"type" : SS_TYPES.STATIC,
				"sprites" : {
					"1x1.gif":
					{
						"frame": {"x":2,"y":2,"w":2,"h":2},
						"rotated": false,
						"trimmed": false,
						"spriteSourceSize": {"x":0,"y":0,"w":2,"h":2},
						"sourceSize": {"w":2,"h":2}
					},
					"delete.png":
					{
						"frame": {"x":6,"y":2,"w":30,"h":30},
						"rotated": false,
						"trimmed": false,
						"spriteSourceSize": {"x":0,"y":0,"w":30,"h":30},
						"sourceSize": {"w":30,"h":30}
					}},
				}
};
